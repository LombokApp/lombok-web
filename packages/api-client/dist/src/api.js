"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * @stellariscloud/api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ViewerApi = exports.ViewerApiFactory = exports.ViewerApiFp = exports.ViewerApiAxiosParamCreator = exports.S3ConnectionsApi = exports.S3ConnectionsApiFactory = exports.S3ConnectionsApiFp = exports.S3ConnectionsApiAxiosParamCreator = exports.FoldersApi = exports.FoldersApiFactory = exports.FoldersApiFp = exports.FoldersApiAxiosParamCreator = exports.AuthApi = exports.AuthApiFactory = exports.AuthApiFp = exports.AuthApiAxiosParamCreator = exports.AppConfigApi = exports.AppConfigApiFactory = exports.AppConfigApiFp = exports.AppConfigApiAxiosParamCreator = exports.PlatformRole = exports.MediaType = exports.InlineResponse2007MethodEnum = exports.FolderPermissionName = void 0;
const axios_1 = require("axios");
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("./common");
// @ts-ignore
const base_1 = require("./base");
/**
 *
 * @export
 * @enum {string}
 */
var FolderPermissionName;
(function (FolderPermissionName) {
    FolderPermissionName["FolderRefresh"] = "folder_refresh";
    FolderPermissionName["FolderManageShares"] = "folder_manage_shares";
    FolderPermissionName["FolderForget"] = "folder_forget";
    FolderPermissionName["ObjectEdit"] = "object_edit";
    FolderPermissionName["ObjectManage"] = "object_manage";
    FolderPermissionName["TagCreate"] = "tag_create";
    FolderPermissionName["TagAssociate"] = "tag_associate";
})(FolderPermissionName = exports.FolderPermissionName || (exports.FolderPermissionName = {}));
/**
    * @export
    * @enum {string}
    */
var InlineResponse2007MethodEnum;
(function (InlineResponse2007MethodEnum) {
    InlineResponse2007MethodEnum["Put"] = "PUT";
    InlineResponse2007MethodEnum["Delete"] = "DELETE";
    InlineResponse2007MethodEnum["Get"] = "GET";
})(InlineResponse2007MethodEnum = exports.InlineResponse2007MethodEnum || (exports.InlineResponse2007MethodEnum = {}));
/**
 *
 * @export
 * @enum {string}
 */
var MediaType;
(function (MediaType) {
    MediaType["Image"] = "IMAGE";
    MediaType["Video"] = "VIDEO";
    MediaType["Audio"] = "AUDIO";
    MediaType["Document"] = "DOCUMENT";
    MediaType["Unknown"] = "UNKNOWN";
})(MediaType = exports.MediaType || (exports.MediaType = {}));
/**
 *
 * @export
 * @enum {string}
 */
var PlatformRole;
(function (PlatformRole) {
    PlatformRole["Anonymous"] = "ANONYMOUS";
    PlatformRole["Authenticated"] = "AUTHENTICATED";
    PlatformRole["Admin"] = "ADMIN";
})(PlatformRole = exports.PlatformRole || (exports.PlatformRole = {}));
/**
 * AppConfigApi - axios parameter creator
 * @export
 */
const AppConfigApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {string} key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppConfig: async (key, options = {}) => {
            // verify required parameter 'key' is not null or undefined
            (0, common_1.assertParamExists)('getAppConfig', 'key', key);
            const localVarPath = `/app-config/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {AppConfigCreateData} appConfigCreateData
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAppConfig: async (appConfigCreateData, options = {}) => {
            // verify required parameter 'appConfigCreateData' is not null or undefined
            (0, common_1.assertParamExists)('setAppConfig', 'appConfigCreateData', appConfigCreateData);
            const localVarPath = `/app-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(appConfigCreateData, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.AppConfigApiAxiosParamCreator = AppConfigApiAxiosParamCreator;
/**
 * AppConfigApi - functional programming interface
 * @export
 */
const AppConfigApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AppConfigApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @param {string} key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAppConfig(key, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAppConfig(key, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {AppConfigCreateData} appConfigCreateData
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setAppConfig(appConfigCreateData, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setAppConfig(appConfigCreateData, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.AppConfigApiFp = AppConfigApiFp;
/**
 * AppConfigApi - factory interface
 * @export
 */
const AppConfigApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AppConfigApiFp)(configuration);
    return {
        /**
         *
         * @param {string} key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppConfig(key, options) {
            return localVarFp.getAppConfig(key, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {AppConfigCreateData} appConfigCreateData
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAppConfig(appConfigCreateData, options) {
            return localVarFp.setAppConfig(appConfigCreateData, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AppConfigApiFactory = AppConfigApiFactory;
/**
 * AppConfigApi - object-oriented interface
 * @export
 * @class AppConfigApi
 * @extends {BaseAPI}
 */
class AppConfigApi extends base_1.BaseAPI {
    /**
     *
     * @param {AppConfigApiGetAppConfigRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppConfigApi
     */
    getAppConfig(requestParameters, options) {
        return (0, exports.AppConfigApiFp)(this.configuration).getAppConfig(requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {AppConfigApiSetAppConfigRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppConfigApi
     */
    setAppConfig(requestParameters, options) {
        return (0, exports.AppConfigApiFp)(this.configuration).setAppConfig(requestParameters.appConfigCreateData, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AppConfigApi = AppConfigApi;
/**
 * AuthApi - axios parameter creator
 * @export
 */
const AuthApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {LoginParams} loginParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginParams, options = {}) => {
            // verify required parameter 'loginParams' is not null or undefined
            (0, common_1.assertParamExists)('login', 'loginParams', loginParams);
            const localVarPath = `/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(loginParams, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options = {}) => {
            const localVarPath = `/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            // authentication RefreshToken required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "refresh_token", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: async (options = {}) => {
            const localVarPath = `/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication RefreshToken required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "refresh_token", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.AuthApiAxiosParamCreator = AuthApiAxiosParamCreator;
/**
 * AuthApi - functional programming interface
 * @export
 */
const AuthApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AuthApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @param {LoginParams} loginParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginParams, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginParams, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.AuthApiFp = AuthApiFp;
/**
 * AuthApi - factory interface
 * @export
 */
const AuthApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AuthApiFp)(configuration);
    return {
        /**
         *
         * @param {LoginParams} loginParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginParams, options) {
            return localVarFp.login(loginParams, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options) {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(options) {
            return localVarFp.refreshToken(options).then((request) => request(axios, basePath));
        },
    };
};
exports.AuthApiFactory = AuthApiFactory;
/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
class AuthApi extends base_1.BaseAPI {
    /**
     *
     * @param {AuthApiLoginRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    login(requestParameters, options) {
        return (0, exports.AuthApiFp)(this.configuration).login(requestParameters.loginParams, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    logout(options) {
        return (0, exports.AuthApiFp)(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    refreshToken(options) {
        return (0, exports.AuthApiFp)(this.configuration).refreshToken(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AuthApi = AuthApi;
/**
 * FoldersApi - axios parameter creator
 * @export
 */
const FoldersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {InlineObject} inlineObject
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolder: async (inlineObject, options = {}) => {
            // verify required parameter 'inlineObject' is not null or undefined
            (0, common_1.assertParamExists)('createFolder', 'inlineObject', inlineObject);
            const localVarPath = `/folders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(inlineObject, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} folderId
         * @param {CreateFolderSharePayload} createFolderSharePayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolderShare: async (folderId, createFolderSharePayload, options = {}) => {
            // verify required parameter 'folderId' is not null or undefined
            (0, common_1.assertParamExists)('createFolderShare', 'folderId', folderId);
            // verify required parameter 'createFolderSharePayload' is not null or undefined
            (0, common_1.assertParamExists)('createFolderShare', 'createFolderSharePayload', createFolderSharePayload);
            const localVarPath = `/folders/{folderId}/shares`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createFolderSharePayload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} folderId
         * @param {Array<object>} requestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPresignedURLs: async (folderId, requestBody, options = {}) => {
            // verify required parameter 'folderId' is not null or undefined
            (0, common_1.assertParamExists)('createPresignedURLs', 'folderId', folderId);
            // verify required parameter 'requestBody' is not null or undefined
            (0, common_1.assertParamExists)('createPresignedURLs', 'requestBody', requestBody);
            const localVarPath = `/folders/{folderId}/presigned-urls`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(requestBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} folderId
         * @param {InlineObject2} inlineObject2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTag: async (folderId, inlineObject2, options = {}) => {
            // verify required parameter 'folderId' is not null or undefined
            (0, common_1.assertParamExists)('createTag', 'folderId', folderId);
            // verify required parameter 'inlineObject2' is not null or undefined
            (0, common_1.assertParamExists)('createTag', 'inlineObject2', inlineObject2);
            const localVarPath = `/folders/{folderId}/tags`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(inlineObject2, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolder: async (folderId, options = {}) => {
            // verify required parameter 'folderId' is not null or undefined
            (0, common_1.assertParamExists)('deleteFolder', 'folderId', folderId);
            const localVarPath = `/folders/{folderId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} folderId
         * @param {string} objectKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolderObject: async (folderId, objectKey, options = {}) => {
            // verify required parameter 'folderId' is not null or undefined
            (0, common_1.assertParamExists)('deleteFolderObject', 'folderId', folderId);
            // verify required parameter 'objectKey' is not null or undefined
            (0, common_1.assertParamExists)('deleteFolderObject', 'objectKey', objectKey);
            const localVarPath = `/folders/{folderId}/objects/{objectKey}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
                .replace(`{${"objectKey"}}`, encodeURIComponent(String(objectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} folderId
         * @param {string} shareId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolderShare: async (folderId, shareId, options = {}) => {
            // verify required parameter 'folderId' is not null or undefined
            (0, common_1.assertParamExists)('deleteFolderShare', 'folderId', folderId);
            // verify required parameter 'shareId' is not null or undefined
            (0, common_1.assertParamExists)('deleteFolderShare', 'shareId', shareId);
            const localVarPath = `/folders/{folderId}/shares/{shareId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
                .replace(`{${"shareId"}}`, encodeURIComponent(String(shareId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} folderId
         * @param {string} tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag: async (folderId, tagId, options = {}) => {
            // verify required parameter 'folderId' is not null or undefined
            (0, common_1.assertParamExists)('deleteTag', 'folderId', folderId);
            // verify required parameter 'tagId' is not null or undefined
            (0, common_1.assertParamExists)('deleteTag', 'tagId', tagId);
            const localVarPath = `/folders/{folderId}/tags/{tagId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolder: async (folderId, options = {}) => {
            // verify required parameter 'folderId' is not null or undefined
            (0, common_1.assertParamExists)('getFolder', 'folderId', folderId);
            const localVarPath = `/folders/{folderId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderMetadata: async (folderId, options = {}) => {
            // verify required parameter 'folderId' is not null or undefined
            (0, common_1.assertParamExists)('getFolderMetadata', 'folderId', folderId);
            const localVarPath = `/folders/{folderId}/metadata`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} folderId
         * @param {string} objectKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderObject: async (folderId, objectKey, options = {}) => {
            // verify required parameter 'folderId' is not null or undefined
            (0, common_1.assertParamExists)('getFolderObject', 'folderId', folderId);
            // verify required parameter 'objectKey' is not null or undefined
            (0, common_1.assertParamExists)('getFolderObject', 'objectKey', objectKey);
            const localVarPath = `/folders/{folderId}/objects/{objectKey}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
                .replace(`{${"objectKey"}}`, encodeURIComponent(String(objectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} folderId
         * @param {string} [search]
         * @param {string} [tagId]
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFolderObjects: async (folderId, search, tagId, offset, limit, options = {}) => {
            // verify required parameter 'folderId' is not null or undefined
            (0, common_1.assertParamExists)('listFolderObjects', 'folderId', folderId);
            const localVarPath = `/folders/{folderId}/objects`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (tagId !== undefined) {
                localVarQueryParameter['tagId'] = tagId;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFolderShares: async (folderId, options = {}) => {
            // verify required parameter 'folderId' is not null or undefined
            (0, common_1.assertParamExists)('listFolderShares', 'folderId', folderId);
            const localVarPath = `/folders/{folderId}/shares`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFolders: async (options = {}) => {
            const localVarPath = `/folders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTags: async (folderId, options = {}) => {
            // verify required parameter 'folderId' is not null or undefined
            (0, common_1.assertParamExists)('listTags', 'folderId', folderId);
            const localVarPath = `/folders/{folderId}/tags`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshFolder: async (folderId, options = {}) => {
            // verify required parameter 'folderId' is not null or undefined
            (0, common_1.assertParamExists)('refreshFolder', 'folderId', folderId);
            const localVarPath = `/folders/{folderId}/refresh`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} folderId
         * @param {string} objectKey
         * @param {InlineObject1} inlineObject1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshFolderObjectS3Metadata: async (folderId, objectKey, inlineObject1, options = {}) => {
            // verify required parameter 'folderId' is not null or undefined
            (0, common_1.assertParamExists)('refreshFolderObjectS3Metadata', 'folderId', folderId);
            // verify required parameter 'objectKey' is not null or undefined
            (0, common_1.assertParamExists)('refreshFolderObjectS3Metadata', 'objectKey', objectKey);
            // verify required parameter 'inlineObject1' is not null or undefined
            (0, common_1.assertParamExists)('refreshFolderObjectS3Metadata', 'inlineObject1', inlineObject1);
            const localVarPath = `/folders/{folderId}/objects/{objectKey}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
                .replace(`{${"objectKey"}}`, encodeURIComponent(String(objectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(inlineObject1, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} folderId
         * @param {string} objectKey
         * @param {string} tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagObject: async (folderId, objectKey, tagId, options = {}) => {
            // verify required parameter 'folderId' is not null or undefined
            (0, common_1.assertParamExists)('tagObject', 'folderId', folderId);
            // verify required parameter 'objectKey' is not null or undefined
            (0, common_1.assertParamExists)('tagObject', 'objectKey', objectKey);
            // verify required parameter 'tagId' is not null or undefined
            (0, common_1.assertParamExists)('tagObject', 'tagId', tagId);
            const localVarPath = `/folders/{folderId}/objects/{objectKey}/{tagId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
                .replace(`{${"objectKey"}}`, encodeURIComponent(String(objectKey)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} folderId
         * @param {string} objectKey
         * @param {string} tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        untagObject: async (folderId, objectKey, tagId, options = {}) => {
            // verify required parameter 'folderId' is not null or undefined
            (0, common_1.assertParamExists)('untagObject', 'folderId', folderId);
            // verify required parameter 'objectKey' is not null or undefined
            (0, common_1.assertParamExists)('untagObject', 'objectKey', objectKey);
            // verify required parameter 'tagId' is not null or undefined
            (0, common_1.assertParamExists)('untagObject', 'tagId', tagId);
            const localVarPath = `/folders/{folderId}/objects/{objectKey}/{tagId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
                .replace(`{${"objectKey"}}`, encodeURIComponent(String(objectKey)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} folderId
         * @param {string} objectKey
         * @param {FolderObjectContentMetadata} folderObjectContentMetadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFolderObjectContentMetadata: async (folderId, objectKey, folderObjectContentMetadata, options = {}) => {
            // verify required parameter 'folderId' is not null or undefined
            (0, common_1.assertParamExists)('updateFolderObjectContentMetadata', 'folderId', folderId);
            // verify required parameter 'objectKey' is not null or undefined
            (0, common_1.assertParamExists)('updateFolderObjectContentMetadata', 'objectKey', objectKey);
            // verify required parameter 'folderObjectContentMetadata' is not null or undefined
            (0, common_1.assertParamExists)('updateFolderObjectContentMetadata', 'folderObjectContentMetadata', folderObjectContentMetadata);
            const localVarPath = `/folders/{folderId}/objects/{objectKey}/content-metadata`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
                .replace(`{${"objectKey"}}`, encodeURIComponent(String(objectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(folderObjectContentMetadata, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} folderId
         * @param {string} shareId
         * @param {UpdateFolderSharePayload} updateFolderSharePayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFolderShare: async (folderId, shareId, updateFolderSharePayload, options = {}) => {
            // verify required parameter 'folderId' is not null or undefined
            (0, common_1.assertParamExists)('updateFolderShare', 'folderId', folderId);
            // verify required parameter 'shareId' is not null or undefined
            (0, common_1.assertParamExists)('updateFolderShare', 'shareId', shareId);
            // verify required parameter 'updateFolderSharePayload' is not null or undefined
            (0, common_1.assertParamExists)('updateFolderShare', 'updateFolderSharePayload', updateFolderSharePayload);
            const localVarPath = `/folders/{folderId}/shares/{shareId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
                .replace(`{${"shareId"}}`, encodeURIComponent(String(shareId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateFolderSharePayload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} folderId
         * @param {string} tagId
         * @param {InlineObject3} inlineObject3
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag: async (folderId, tagId, inlineObject3, options = {}) => {
            // verify required parameter 'folderId' is not null or undefined
            (0, common_1.assertParamExists)('updateTag', 'folderId', folderId);
            // verify required parameter 'tagId' is not null or undefined
            (0, common_1.assertParamExists)('updateTag', 'tagId', tagId);
            // verify required parameter 'inlineObject3' is not null or undefined
            (0, common_1.assertParamExists)('updateTag', 'inlineObject3', inlineObject3);
            const localVarPath = `/folders/{folderId}/tags/{tagId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(inlineObject3, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.FoldersApiAxiosParamCreator = FoldersApiAxiosParamCreator;
/**
 * FoldersApi - functional programming interface
 * @export
 */
const FoldersApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.FoldersApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @param {InlineObject} inlineObject
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFolder(inlineObject, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFolder(inlineObject, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} folderId
         * @param {CreateFolderSharePayload} createFolderSharePayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFolderShare(folderId, createFolderSharePayload, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFolderShare(folderId, createFolderSharePayload, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} folderId
         * @param {Array<object>} requestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPresignedURLs(folderId, requestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPresignedURLs(folderId, requestBody, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} folderId
         * @param {InlineObject2} inlineObject2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTag(folderId, inlineObject2, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTag(folderId, inlineObject2, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFolder(folderId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFolder(folderId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} folderId
         * @param {string} objectKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFolderObject(folderId, objectKey, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFolderObject(folderId, objectKey, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} folderId
         * @param {string} shareId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFolderShare(folderId, shareId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFolderShare(folderId, shareId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} folderId
         * @param {string} tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTag(folderId, tagId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTag(folderId, tagId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolder(folderId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolder(folderId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolderMetadata(folderId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolderMetadata(folderId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} folderId
         * @param {string} objectKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolderObject(folderId, objectKey, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolderObject(folderId, objectKey, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} folderId
         * @param {string} [search]
         * @param {string} [tagId]
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFolderObjects(folderId, search, tagId, offset, limit, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFolderObjects(folderId, search, tagId, offset, limit, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFolderShares(folderId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFolderShares(folderId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFolders(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFolders(options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTags(folderId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTags(folderId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshFolder(folderId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshFolder(folderId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} folderId
         * @param {string} objectKey
         * @param {InlineObject1} inlineObject1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshFolderObjectS3Metadata(folderId, objectKey, inlineObject1, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshFolderObjectS3Metadata(folderId, objectKey, inlineObject1, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} folderId
         * @param {string} objectKey
         * @param {string} tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagObject(folderId, objectKey, tagId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagObject(folderId, objectKey, tagId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} folderId
         * @param {string} objectKey
         * @param {string} tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async untagObject(folderId, objectKey, tagId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.untagObject(folderId, objectKey, tagId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} folderId
         * @param {string} objectKey
         * @param {FolderObjectContentMetadata} folderObjectContentMetadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFolderObjectContentMetadata(folderId, objectKey, folderObjectContentMetadata, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFolderObjectContentMetadata(folderId, objectKey, folderObjectContentMetadata, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} folderId
         * @param {string} shareId
         * @param {UpdateFolderSharePayload} updateFolderSharePayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFolderShare(folderId, shareId, updateFolderSharePayload, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFolderShare(folderId, shareId, updateFolderSharePayload, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} folderId
         * @param {string} tagId
         * @param {InlineObject3} inlineObject3
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTag(folderId, tagId, inlineObject3, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTag(folderId, tagId, inlineObject3, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.FoldersApiFp = FoldersApiFp;
/**
 * FoldersApi - factory interface
 * @export
 */
const FoldersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.FoldersApiFp)(configuration);
    return {
        /**
         *
         * @param {InlineObject} inlineObject
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolder(inlineObject, options) {
            return localVarFp.createFolder(inlineObject, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} folderId
         * @param {CreateFolderSharePayload} createFolderSharePayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolderShare(folderId, createFolderSharePayload, options) {
            return localVarFp.createFolderShare(folderId, createFolderSharePayload, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} folderId
         * @param {Array<object>} requestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPresignedURLs(folderId, requestBody, options) {
            return localVarFp.createPresignedURLs(folderId, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} folderId
         * @param {InlineObject2} inlineObject2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTag(folderId, inlineObject2, options) {
            return localVarFp.createTag(folderId, inlineObject2, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolder(folderId, options) {
            return localVarFp.deleteFolder(folderId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} folderId
         * @param {string} objectKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolderObject(folderId, objectKey, options) {
            return localVarFp.deleteFolderObject(folderId, objectKey, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} folderId
         * @param {string} shareId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolderShare(folderId, shareId, options) {
            return localVarFp.deleteFolderShare(folderId, shareId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} folderId
         * @param {string} tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag(folderId, tagId, options) {
            return localVarFp.deleteTag(folderId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolder(folderId, options) {
            return localVarFp.getFolder(folderId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderMetadata(folderId, options) {
            return localVarFp.getFolderMetadata(folderId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} folderId
         * @param {string} objectKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderObject(folderId, objectKey, options) {
            return localVarFp.getFolderObject(folderId, objectKey, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} folderId
         * @param {string} [search]
         * @param {string} [tagId]
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFolderObjects(folderId, search, tagId, offset, limit, options) {
            return localVarFp.listFolderObjects(folderId, search, tagId, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFolderShares(folderId, options) {
            return localVarFp.listFolderShares(folderId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFolders(options) {
            return localVarFp.listFolders(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTags(folderId, options) {
            return localVarFp.listTags(folderId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshFolder(folderId, options) {
            return localVarFp.refreshFolder(folderId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} folderId
         * @param {string} objectKey
         * @param {InlineObject1} inlineObject1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshFolderObjectS3Metadata(folderId, objectKey, inlineObject1, options) {
            return localVarFp.refreshFolderObjectS3Metadata(folderId, objectKey, inlineObject1, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} folderId
         * @param {string} objectKey
         * @param {string} tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagObject(folderId, objectKey, tagId, options) {
            return localVarFp.tagObject(folderId, objectKey, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} folderId
         * @param {string} objectKey
         * @param {string} tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        untagObject(folderId, objectKey, tagId, options) {
            return localVarFp.untagObject(folderId, objectKey, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} folderId
         * @param {string} objectKey
         * @param {FolderObjectContentMetadata} folderObjectContentMetadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFolderObjectContentMetadata(folderId, objectKey, folderObjectContentMetadata, options) {
            return localVarFp.updateFolderObjectContentMetadata(folderId, objectKey, folderObjectContentMetadata, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} folderId
         * @param {string} shareId
         * @param {UpdateFolderSharePayload} updateFolderSharePayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFolderShare(folderId, shareId, updateFolderSharePayload, options) {
            return localVarFp.updateFolderShare(folderId, shareId, updateFolderSharePayload, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} folderId
         * @param {string} tagId
         * @param {InlineObject3} inlineObject3
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag(folderId, tagId, inlineObject3, options) {
            return localVarFp.updateTag(folderId, tagId, inlineObject3, options).then((request) => request(axios, basePath));
        },
    };
};
exports.FoldersApiFactory = FoldersApiFactory;
/**
 * FoldersApi - object-oriented interface
 * @export
 * @class FoldersApi
 * @extends {BaseAPI}
 */
class FoldersApi extends base_1.BaseAPI {
    /**
     *
     * @param {FoldersApiCreateFolderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    createFolder(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).createFolder(requestParameters.inlineObject, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {FoldersApiCreateFolderShareRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    createFolderShare(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).createFolderShare(requestParameters.folderId, requestParameters.createFolderSharePayload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {FoldersApiCreatePresignedURLsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    createPresignedURLs(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).createPresignedURLs(requestParameters.folderId, requestParameters.requestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {FoldersApiCreateTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    createTag(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).createTag(requestParameters.folderId, requestParameters.inlineObject2, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {FoldersApiDeleteFolderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    deleteFolder(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).deleteFolder(requestParameters.folderId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {FoldersApiDeleteFolderObjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    deleteFolderObject(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).deleteFolderObject(requestParameters.folderId, requestParameters.objectKey, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {FoldersApiDeleteFolderShareRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    deleteFolderShare(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).deleteFolderShare(requestParameters.folderId, requestParameters.shareId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {FoldersApiDeleteTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    deleteTag(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).deleteTag(requestParameters.folderId, requestParameters.tagId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {FoldersApiGetFolderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    getFolder(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).getFolder(requestParameters.folderId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {FoldersApiGetFolderMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    getFolderMetadata(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).getFolderMetadata(requestParameters.folderId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {FoldersApiGetFolderObjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    getFolderObject(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).getFolderObject(requestParameters.folderId, requestParameters.objectKey, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {FoldersApiListFolderObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    listFolderObjects(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).listFolderObjects(requestParameters.folderId, requestParameters.search, requestParameters.tagId, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {FoldersApiListFolderSharesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    listFolderShares(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).listFolderShares(requestParameters.folderId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    listFolders(options) {
        return (0, exports.FoldersApiFp)(this.configuration).listFolders(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {FoldersApiListTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    listTags(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).listTags(requestParameters.folderId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {FoldersApiRefreshFolderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    refreshFolder(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).refreshFolder(requestParameters.folderId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {FoldersApiRefreshFolderObjectS3MetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    refreshFolderObjectS3Metadata(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).refreshFolderObjectS3Metadata(requestParameters.folderId, requestParameters.objectKey, requestParameters.inlineObject1, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {FoldersApiTagObjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    tagObject(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).tagObject(requestParameters.folderId, requestParameters.objectKey, requestParameters.tagId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {FoldersApiUntagObjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    untagObject(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).untagObject(requestParameters.folderId, requestParameters.objectKey, requestParameters.tagId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {FoldersApiUpdateFolderObjectContentMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    updateFolderObjectContentMetadata(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).updateFolderObjectContentMetadata(requestParameters.folderId, requestParameters.objectKey, requestParameters.folderObjectContentMetadata, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {FoldersApiUpdateFolderShareRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    updateFolderShare(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).updateFolderShare(requestParameters.folderId, requestParameters.shareId, requestParameters.updateFolderSharePayload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {FoldersApiUpdateTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    updateTag(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).updateTag(requestParameters.folderId, requestParameters.tagId, requestParameters.inlineObject3, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.FoldersApi = FoldersApi;
/**
 * S3ConnectionsApi - axios parameter creator
 * @export
 */
const S3ConnectionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {InlineObject4} inlineObject4
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createS3Connection: async (inlineObject4, options = {}) => {
            // verify required parameter 'inlineObject4' is not null or undefined
            (0, common_1.assertParamExists)('createS3Connection', 'inlineObject4', inlineObject4);
            const localVarPath = `/s3-connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(inlineObject4, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} s3ConnectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteS3Connection: async (s3ConnectionId, options = {}) => {
            // verify required parameter 's3ConnectionId' is not null or undefined
            (0, common_1.assertParamExists)('deleteS3Connection', 's3ConnectionId', s3ConnectionId);
            const localVarPath = `/s3-connections/{s3ConnectionId}`
                .replace(`{${"s3ConnectionId"}}`, encodeURIComponent(String(s3ConnectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} s3ConnectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getS3Connection: async (s3ConnectionId, options = {}) => {
            // verify required parameter 's3ConnectionId' is not null or undefined
            (0, common_1.assertParamExists)('getS3Connection', 's3ConnectionId', s3ConnectionId);
            const localVarPath = `/s3-connections/{s3ConnectionId}`
                .replace(`{${"s3ConnectionId"}}`, encodeURIComponent(String(s3ConnectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listS3Connections: async (options = {}) => {
            const localVarPath = `/s3-connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {InlineObject5} inlineObject5
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testS3Connection: async (inlineObject5, options = {}) => {
            // verify required parameter 'inlineObject5' is not null or undefined
            (0, common_1.assertParamExists)('testS3Connection', 'inlineObject5', inlineObject5);
            const localVarPath = `/s3-connections/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(inlineObject5, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.S3ConnectionsApiAxiosParamCreator = S3ConnectionsApiAxiosParamCreator;
/**
 * S3ConnectionsApi - functional programming interface
 * @export
 */
const S3ConnectionsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.S3ConnectionsApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @param {InlineObject4} inlineObject4
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createS3Connection(inlineObject4, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createS3Connection(inlineObject4, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} s3ConnectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteS3Connection(s3ConnectionId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteS3Connection(s3ConnectionId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} s3ConnectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getS3Connection(s3ConnectionId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getS3Connection(s3ConnectionId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listS3Connections(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listS3Connections(options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {InlineObject5} inlineObject5
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testS3Connection(inlineObject5, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testS3Connection(inlineObject5, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.S3ConnectionsApiFp = S3ConnectionsApiFp;
/**
 * S3ConnectionsApi - factory interface
 * @export
 */
const S3ConnectionsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.S3ConnectionsApiFp)(configuration);
    return {
        /**
         *
         * @param {InlineObject4} inlineObject4
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createS3Connection(inlineObject4, options) {
            return localVarFp.createS3Connection(inlineObject4, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} s3ConnectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteS3Connection(s3ConnectionId, options) {
            return localVarFp.deleteS3Connection(s3ConnectionId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} s3ConnectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getS3Connection(s3ConnectionId, options) {
            return localVarFp.getS3Connection(s3ConnectionId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listS3Connections(options) {
            return localVarFp.listS3Connections(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {InlineObject5} inlineObject5
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testS3Connection(inlineObject5, options) {
            return localVarFp.testS3Connection(inlineObject5, options).then((request) => request(axios, basePath));
        },
    };
};
exports.S3ConnectionsApiFactory = S3ConnectionsApiFactory;
/**
 * S3ConnectionsApi - object-oriented interface
 * @export
 * @class S3ConnectionsApi
 * @extends {BaseAPI}
 */
class S3ConnectionsApi extends base_1.BaseAPI {
    /**
     *
     * @param {S3ConnectionsApiCreateS3ConnectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof S3ConnectionsApi
     */
    createS3Connection(requestParameters, options) {
        return (0, exports.S3ConnectionsApiFp)(this.configuration).createS3Connection(requestParameters.inlineObject4, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {S3ConnectionsApiDeleteS3ConnectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof S3ConnectionsApi
     */
    deleteS3Connection(requestParameters, options) {
        return (0, exports.S3ConnectionsApiFp)(this.configuration).deleteS3Connection(requestParameters.s3ConnectionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {S3ConnectionsApiGetS3ConnectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof S3ConnectionsApi
     */
    getS3Connection(requestParameters, options) {
        return (0, exports.S3ConnectionsApiFp)(this.configuration).getS3Connection(requestParameters.s3ConnectionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof S3ConnectionsApi
     */
    listS3Connections(options) {
        return (0, exports.S3ConnectionsApiFp)(this.configuration).listS3Connections(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {S3ConnectionsApiTestS3ConnectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof S3ConnectionsApi
     */
    testS3Connection(requestParameters, options) {
        return (0, exports.S3ConnectionsApiFp)(this.configuration).testS3Connection(requestParameters.inlineObject5, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.S3ConnectionsApi = S3ConnectionsApi;
/**
 * ViewerApi - axios parameter creator
 * @export
 */
const ViewerApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getViewer: async (options = {}) => {
            const localVarPath = `/viewer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.ViewerApiAxiosParamCreator = ViewerApiAxiosParamCreator;
/**
 * ViewerApi - functional programming interface
 * @export
 */
const ViewerApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ViewerApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getViewer(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getViewer(options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.ViewerApiFp = ViewerApiFp;
/**
 * ViewerApi - factory interface
 * @export
 */
const ViewerApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ViewerApiFp)(configuration);
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getViewer(options) {
            return localVarFp.getViewer(options).then((request) => request(axios, basePath));
        },
    };
};
exports.ViewerApiFactory = ViewerApiFactory;
/**
 * ViewerApi - object-oriented interface
 * @export
 * @class ViewerApi
 * @extends {BaseAPI}
 */
class ViewerApi extends base_1.BaseAPI {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewerApi
     */
    getViewer(options) {
        return (0, exports.ViewerApiFp)(this.configuration).getViewer(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ViewerApi = ViewerApi;
