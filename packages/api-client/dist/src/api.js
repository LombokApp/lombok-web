"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * @stellariscloud/api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkerApi = exports.WorkerApiFactory = exports.WorkerApiFp = exports.WorkerApiAxiosParamCreator = exports.ViewerApi = exports.ViewerApiFactory = exports.ViewerApiFp = exports.ViewerApiAxiosParamCreator = exports.ServerApi = exports.ServerApiFactory = exports.ServerApiFp = exports.ServerApiAxiosParamCreator = exports.FoldersApi = exports.FoldersApiFactory = exports.FoldersApiFp = exports.FoldersApiAxiosParamCreator = exports.AuthApi = exports.AuthApiFactory = exports.AuthApiFp = exports.AuthApiAxiosParamCreator = exports.SignedURLsRequestMethod = exports.ServerLocationType = exports.S3LocationDataProviderTypeEnum = exports.PlatformRole = exports.MediaType = exports.FolderPermissionName = exports.FolderOperationName = void 0;
const axios_1 = require("axios");
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("./common");
// @ts-ignore
const base_1 = require("./base");
/**
 *
 * @export
 * @enum {string}
 */
exports.FolderOperationName = {
    IndexFolder: 'IndexFolder',
    IndexFolderObject: 'IndexFolderObject',
    TranscribeAudio: 'TranscribeAudio',
    DetectObjects: 'DetectObjects'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.FolderPermissionName = {
    FolderRefresh: 'folder_refresh',
    FolderManageShares: 'folder_manage_shares',
    FolderForget: 'folder_forget',
    ObjectEdit: 'object_edit',
    ObjectManage: 'object_manage',
    TagCreate: 'tag_create',
    TagAssociate: 'tag_associate'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.MediaType = {
    Image: 'IMAGE',
    Video: 'VIDEO',
    Audio: 'AUDIO',
    Document: 'DOCUMENT',
    Unknown: 'UNKNOWN'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.PlatformRole = {
    Anonymous: 'ANONYMOUS',
    User: 'USER',
    Admin: 'ADMIN',
    Service: 'SERVICE'
};
exports.S3LocationDataProviderTypeEnum = {
    Server: 'SERVER',
    User: 'USER'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.ServerLocationType = {
    Metadata: 'USER_METADATA',
    Content: 'USER_CONTENT',
    Backup: 'USER_BACKUP'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.SignedURLsRequestMethod = {
    Put: 'PUT',
    Delete: 'DELETE',
    Get: 'GET'
};
/**
 * AuthApi - axios parameter creator
 * @export
 */
const AuthApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {LoginParams} loginParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginParams, options = {}) => {
            // verify required parameter 'loginParams' is not null or undefined
            (0, common_1.assertParamExists)('login', 'loginParams', loginParams);
            const localVarPath = `/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(loginParams, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options = {}) => {
            const localVarPath = `/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: async (options = {}) => {
            const localVarPath = `/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication RefreshToken required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "refresh_token", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Given a user\'s credentials, this endpoint will create a new user.
         * @param {SignupRequest} signupRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signup: async (signupRequest, options = {}) => {
            // verify required parameter 'signupRequest' is not null or undefined
            (0, common_1.assertParamExists)('signup', 'signupRequest', signupRequest);
            const localVarPath = `/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(signupRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.AuthApiAxiosParamCreator = AuthApiAxiosParamCreator;
/**
 * AuthApi - functional programming interface
 * @export
 */
const AuthApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AuthApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @param {LoginParams} loginParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginParams, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginParams, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Given a user\'s credentials, this endpoint will create a new user.
         * @param {SignupRequest} signupRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signup(signupRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signup(signupRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.AuthApiFp = AuthApiFp;
/**
 * AuthApi - factory interface
 * @export
 */
const AuthApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AuthApiFp)(configuration);
    return {
        /**
         *
         * @param {AuthApiLoginRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(requestParameters, options) {
            return localVarFp.login(requestParameters.loginParams, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options) {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(options) {
            return localVarFp.refreshToken(options).then((request) => request(axios, basePath));
        },
        /**
         * Given a user\'s credentials, this endpoint will create a new user.
         * @param {AuthApiSignupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signup(requestParameters, options) {
            return localVarFp.signup(requestParameters.signupRequest, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AuthApiFactory = AuthApiFactory;
/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
class AuthApi extends base_1.BaseAPI {
    /**
     *
     * @param {AuthApiLoginRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    login(requestParameters, options) {
        return (0, exports.AuthApiFp)(this.configuration).login(requestParameters.loginParams, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    logout(options) {
        return (0, exports.AuthApiFp)(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    refreshToken(options) {
        return (0, exports.AuthApiFp)(this.configuration).refreshToken(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Given a user\'s credentials, this endpoint will create a new user.
     * @param {AuthApiSignupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    signup(requestParameters, options) {
        return (0, exports.AuthApiFp)(this.configuration).signup(requestParameters.signupRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AuthApi = AuthApi;
/**
 * FoldersApi - axios parameter creator
 * @export
 */
const FoldersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {CreateFolderRequest} createFolderRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolder: async (createFolderRequest, options = {}) => {
            // verify required parameter 'createFolderRequest' is not null or undefined
            (0, common_1.assertParamExists)('createFolder', 'createFolderRequest', createFolderRequest);
            const localVarPath = `/folders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createFolderRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} folderId
         * @param {CreateFolderSharePayload} createFolderSharePayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolderShare: async (folderId, createFolderSharePayload, options = {}) => {
            // verify required parameter 'folderId' is not null or undefined
            (0, common_1.assertParamExists)('createFolderShare', 'folderId', folderId);
            // verify required parameter 'createFolderSharePayload' is not null or undefined
            (0, common_1.assertParamExists)('createFolderShare', 'createFolderSharePayload', createFolderSharePayload);
            const localVarPath = `/folders/{folderId}/shares`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createFolderSharePayload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} folderId
         * @param {Array<SignedURLsRequest>} signedURLsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPresignedUrls: async (folderId, signedURLsRequest, options = {}) => {
            // verify required parameter 'folderId' is not null or undefined
            (0, common_1.assertParamExists)('createPresignedUrls', 'folderId', folderId);
            // verify required parameter 'signedURLsRequest' is not null or undefined
            (0, common_1.assertParamExists)('createPresignedUrls', 'signedURLsRequest', signedURLsRequest);
            const localVarPath = `/folders/{folderId}/presigned-urls`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(signedURLsRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSocketAuthentication: async (folderId, options = {}) => {
            // verify required parameter 'folderId' is not null or undefined
            (0, common_1.assertParamExists)('createSocketAuthentication', 'folderId', folderId);
            const localVarPath = `/folders/{folderId}/socket-auth`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} folderId
         * @param {CreateTagRequest} createTagRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTag: async (folderId, createTagRequest, options = {}) => {
            // verify required parameter 'folderId' is not null or undefined
            (0, common_1.assertParamExists)('createTag', 'folderId', folderId);
            // verify required parameter 'createTagRequest' is not null or undefined
            (0, common_1.assertParamExists)('createTag', 'createTagRequest', createTagRequest);
            const localVarPath = `/folders/{folderId}/tags`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createTagRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolder: async (folderId, options = {}) => {
            // verify required parameter 'folderId' is not null or undefined
            (0, common_1.assertParamExists)('deleteFolder', 'folderId', folderId);
            const localVarPath = `/folders/{folderId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} folderId
         * @param {string} objectKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolderObject: async (folderId, objectKey, options = {}) => {
            // verify required parameter 'folderId' is not null or undefined
            (0, common_1.assertParamExists)('deleteFolderObject', 'folderId', folderId);
            // verify required parameter 'objectKey' is not null or undefined
            (0, common_1.assertParamExists)('deleteFolderObject', 'objectKey', objectKey);
            const localVarPath = `/folders/{folderId}/objects/{objectKey}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
                .replace(`{${"objectKey"}}`, encodeURIComponent(String(objectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} folderId
         * @param {string} shareId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolderShare: async (folderId, shareId, options = {}) => {
            // verify required parameter 'folderId' is not null or undefined
            (0, common_1.assertParamExists)('deleteFolderShare', 'folderId', folderId);
            // verify required parameter 'shareId' is not null or undefined
            (0, common_1.assertParamExists)('deleteFolderShare', 'shareId', shareId);
            const localVarPath = `/folders/{folderId}/shares/{shareId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
                .replace(`{${"shareId"}}`, encodeURIComponent(String(shareId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} folderId
         * @param {string} tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag: async (folderId, tagId, options = {}) => {
            // verify required parameter 'folderId' is not null or undefined
            (0, common_1.assertParamExists)('deleteTag', 'folderId', folderId);
            // verify required parameter 'tagId' is not null or undefined
            (0, common_1.assertParamExists)('deleteTag', 'tagId', tagId);
            const localVarPath = `/folders/{folderId}/tags/{tagId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} folderId
         * @param {FolderOperationRequestPayload} folderOperationRequestPayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enqueueFolderOperation: async (folderId, folderOperationRequestPayload, options = {}) => {
            // verify required parameter 'folderId' is not null or undefined
            (0, common_1.assertParamExists)('enqueueFolderOperation', 'folderId', folderId);
            // verify required parameter 'folderOperationRequestPayload' is not null or undefined
            (0, common_1.assertParamExists)('enqueueFolderOperation', 'folderOperationRequestPayload', folderOperationRequestPayload);
            const localVarPath = `/folders/{folderId}/operations`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(folderOperationRequestPayload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolder: async (folderId, options = {}) => {
            // verify required parameter 'folderId' is not null or undefined
            (0, common_1.assertParamExists)('getFolder', 'folderId', folderId);
            const localVarPath = `/folders/{folderId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderMetadata: async (folderId, options = {}) => {
            // verify required parameter 'folderId' is not null or undefined
            (0, common_1.assertParamExists)('getFolderMetadata', 'folderId', folderId);
            const localVarPath = `/folders/{folderId}/metadata`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} folderId
         * @param {string} objectKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderObject: async (folderId, objectKey, options = {}) => {
            // verify required parameter 'folderId' is not null or undefined
            (0, common_1.assertParamExists)('getFolderObject', 'folderId', folderId);
            // verify required parameter 'objectKey' is not null or undefined
            (0, common_1.assertParamExists)('getFolderObject', 'objectKey', objectKey);
            const localVarPath = `/folders/{folderId}/objects/{objectKey}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
                .replace(`{${"objectKey"}}`, encodeURIComponent(String(objectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexAllContent: async (folderId, options = {}) => {
            // verify required parameter 'folderId' is not null or undefined
            (0, common_1.assertParamExists)('indexAllContent', 'folderId', folderId);
            const localVarPath = `/folders/{folderId}/index-all`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} folderId
         * @param {string} [search]
         * @param {string} [tagId]
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFolderObjects: async (folderId, search, tagId, offset, limit, options = {}) => {
            // verify required parameter 'folderId' is not null or undefined
            (0, common_1.assertParamExists)('listFolderObjects', 'folderId', folderId);
            const localVarPath = `/folders/{folderId}/objects`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (tagId !== undefined) {
                localVarQueryParameter['tagId'] = tagId;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFolderOperations: async (folderId, options = {}) => {
            // verify required parameter 'folderId' is not null or undefined
            (0, common_1.assertParamExists)('listFolderOperations', 'folderId', folderId);
            const localVarPath = `/folders/{folderId}/operations`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFolderShares: async (folderId, options = {}) => {
            // verify required parameter 'folderId' is not null or undefined
            (0, common_1.assertParamExists)('listFolderShares', 'folderId', folderId);
            const localVarPath = `/folders/{folderId}/shares`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFolders: async (options = {}) => {
            const localVarPath = `/folders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTags: async (folderId, options = {}) => {
            // verify required parameter 'folderId' is not null or undefined
            (0, common_1.assertParamExists)('listTags', 'folderId', folderId);
            const localVarPath = `/folders/{folderId}/tags`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshFolder: async (folderId, options = {}) => {
            // verify required parameter 'folderId' is not null or undefined
            (0, common_1.assertParamExists)('refreshFolder', 'folderId', folderId);
            const localVarPath = `/folders/{folderId}/refresh`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} folderId
         * @param {string} objectKey
         * @param {RefreshFolderObjectS3MetadataRequest} refreshFolderObjectS3MetadataRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshFolderObjectS3Metadata: async (folderId, objectKey, refreshFolderObjectS3MetadataRequest, options = {}) => {
            // verify required parameter 'folderId' is not null or undefined
            (0, common_1.assertParamExists)('refreshFolderObjectS3Metadata', 'folderId', folderId);
            // verify required parameter 'objectKey' is not null or undefined
            (0, common_1.assertParamExists)('refreshFolderObjectS3Metadata', 'objectKey', objectKey);
            // verify required parameter 'refreshFolderObjectS3MetadataRequest' is not null or undefined
            (0, common_1.assertParamExists)('refreshFolderObjectS3Metadata', 'refreshFolderObjectS3MetadataRequest', refreshFolderObjectS3MetadataRequest);
            const localVarPath = `/folders/{folderId}/objects/{objectKey}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
                .replace(`{${"objectKey"}}`, encodeURIComponent(String(objectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(refreshFolderObjectS3MetadataRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} folderId
         * @param {string} objectKey
         * @param {string} tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagObject: async (folderId, objectKey, tagId, options = {}) => {
            // verify required parameter 'folderId' is not null or undefined
            (0, common_1.assertParamExists)('tagObject', 'folderId', folderId);
            // verify required parameter 'objectKey' is not null or undefined
            (0, common_1.assertParamExists)('tagObject', 'objectKey', objectKey);
            // verify required parameter 'tagId' is not null or undefined
            (0, common_1.assertParamExists)('tagObject', 'tagId', tagId);
            const localVarPath = `/folders/{folderId}/objects/{objectKey}/{tagId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
                .replace(`{${"objectKey"}}`, encodeURIComponent(String(objectKey)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} folderId
         * @param {string} objectKey
         * @param {string} tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        untagObject: async (folderId, objectKey, tagId, options = {}) => {
            // verify required parameter 'folderId' is not null or undefined
            (0, common_1.assertParamExists)('untagObject', 'folderId', folderId);
            // verify required parameter 'objectKey' is not null or undefined
            (0, common_1.assertParamExists)('untagObject', 'objectKey', objectKey);
            // verify required parameter 'tagId' is not null or undefined
            (0, common_1.assertParamExists)('untagObject', 'tagId', tagId);
            const localVarPath = `/folders/{folderId}/objects/{objectKey}/{tagId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
                .replace(`{${"objectKey"}}`, encodeURIComponent(String(objectKey)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} folderId
         * @param {string} shareId
         * @param {UpdateFolderSharePayload} updateFolderSharePayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFolderShare: async (folderId, shareId, updateFolderSharePayload, options = {}) => {
            // verify required parameter 'folderId' is not null or undefined
            (0, common_1.assertParamExists)('updateFolderShare', 'folderId', folderId);
            // verify required parameter 'shareId' is not null or undefined
            (0, common_1.assertParamExists)('updateFolderShare', 'shareId', shareId);
            // verify required parameter 'updateFolderSharePayload' is not null or undefined
            (0, common_1.assertParamExists)('updateFolderShare', 'updateFolderSharePayload', updateFolderSharePayload);
            const localVarPath = `/folders/{folderId}/shares/{shareId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
                .replace(`{${"shareId"}}`, encodeURIComponent(String(shareId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateFolderSharePayload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} folderId
         * @param {string} tagId
         * @param {CreateTagRequest} createTagRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag: async (folderId, tagId, createTagRequest, options = {}) => {
            // verify required parameter 'folderId' is not null or undefined
            (0, common_1.assertParamExists)('updateTag', 'folderId', folderId);
            // verify required parameter 'tagId' is not null or undefined
            (0, common_1.assertParamExists)('updateTag', 'tagId', tagId);
            // verify required parameter 'createTagRequest' is not null or undefined
            (0, common_1.assertParamExists)('updateTag', 'createTagRequest', createTagRequest);
            const localVarPath = `/folders/{folderId}/tags/{tagId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createTagRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.FoldersApiAxiosParamCreator = FoldersApiAxiosParamCreator;
/**
 * FoldersApi - functional programming interface
 * @export
 */
const FoldersApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.FoldersApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @param {CreateFolderRequest} createFolderRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFolder(createFolderRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFolder(createFolderRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} folderId
         * @param {CreateFolderSharePayload} createFolderSharePayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFolderShare(folderId, createFolderSharePayload, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFolderShare(folderId, createFolderSharePayload, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} folderId
         * @param {Array<SignedURLsRequest>} signedURLsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPresignedUrls(folderId, signedURLsRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPresignedUrls(folderId, signedURLsRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSocketAuthentication(folderId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSocketAuthentication(folderId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} folderId
         * @param {CreateTagRequest} createTagRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTag(folderId, createTagRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTag(folderId, createTagRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFolder(folderId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFolder(folderId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} folderId
         * @param {string} objectKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFolderObject(folderId, objectKey, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFolderObject(folderId, objectKey, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} folderId
         * @param {string} shareId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFolderShare(folderId, shareId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFolderShare(folderId, shareId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} folderId
         * @param {string} tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTag(folderId, tagId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTag(folderId, tagId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} folderId
         * @param {FolderOperationRequestPayload} folderOperationRequestPayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enqueueFolderOperation(folderId, folderOperationRequestPayload, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enqueueFolderOperation(folderId, folderOperationRequestPayload, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolder(folderId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolder(folderId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolderMetadata(folderId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolderMetadata(folderId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} folderId
         * @param {string} objectKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolderObject(folderId, objectKey, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolderObject(folderId, objectKey, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async indexAllContent(folderId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.indexAllContent(folderId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} folderId
         * @param {string} [search]
         * @param {string} [tagId]
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFolderObjects(folderId, search, tagId, offset, limit, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFolderObjects(folderId, search, tagId, offset, limit, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFolderOperations(folderId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFolderOperations(folderId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFolderShares(folderId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFolderShares(folderId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFolders(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFolders(options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTags(folderId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTags(folderId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshFolder(folderId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshFolder(folderId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} folderId
         * @param {string} objectKey
         * @param {RefreshFolderObjectS3MetadataRequest} refreshFolderObjectS3MetadataRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshFolderObjectS3Metadata(folderId, objectKey, refreshFolderObjectS3MetadataRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshFolderObjectS3Metadata(folderId, objectKey, refreshFolderObjectS3MetadataRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} folderId
         * @param {string} objectKey
         * @param {string} tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagObject(folderId, objectKey, tagId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagObject(folderId, objectKey, tagId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} folderId
         * @param {string} objectKey
         * @param {string} tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async untagObject(folderId, objectKey, tagId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.untagObject(folderId, objectKey, tagId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} folderId
         * @param {string} shareId
         * @param {UpdateFolderSharePayload} updateFolderSharePayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFolderShare(folderId, shareId, updateFolderSharePayload, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFolderShare(folderId, shareId, updateFolderSharePayload, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} folderId
         * @param {string} tagId
         * @param {CreateTagRequest} createTagRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTag(folderId, tagId, createTagRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTag(folderId, tagId, createTagRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.FoldersApiFp = FoldersApiFp;
/**
 * FoldersApi - factory interface
 * @export
 */
const FoldersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.FoldersApiFp)(configuration);
    return {
        /**
         *
         * @param {FoldersApiCreateFolderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolder(requestParameters, options) {
            return localVarFp.createFolder(requestParameters.createFolderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {FoldersApiCreateFolderShareRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolderShare(requestParameters, options) {
            return localVarFp.createFolderShare(requestParameters.folderId, requestParameters.createFolderSharePayload, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {FoldersApiCreatePresignedUrlsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPresignedUrls(requestParameters, options) {
            return localVarFp.createPresignedUrls(requestParameters.folderId, requestParameters.signedURLsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {FoldersApiCreateSocketAuthenticationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSocketAuthentication(requestParameters, options) {
            return localVarFp.createSocketAuthentication(requestParameters.folderId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {FoldersApiCreateTagRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTag(requestParameters, options) {
            return localVarFp.createTag(requestParameters.folderId, requestParameters.createTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {FoldersApiDeleteFolderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolder(requestParameters, options) {
            return localVarFp.deleteFolder(requestParameters.folderId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {FoldersApiDeleteFolderObjectRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolderObject(requestParameters, options) {
            return localVarFp.deleteFolderObject(requestParameters.folderId, requestParameters.objectKey, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {FoldersApiDeleteFolderShareRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolderShare(requestParameters, options) {
            return localVarFp.deleteFolderShare(requestParameters.folderId, requestParameters.shareId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {FoldersApiDeleteTagRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag(requestParameters, options) {
            return localVarFp.deleteTag(requestParameters.folderId, requestParameters.tagId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {FoldersApiEnqueueFolderOperationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enqueueFolderOperation(requestParameters, options) {
            return localVarFp.enqueueFolderOperation(requestParameters.folderId, requestParameters.folderOperationRequestPayload, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {FoldersApiGetFolderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolder(requestParameters, options) {
            return localVarFp.getFolder(requestParameters.folderId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {FoldersApiGetFolderMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderMetadata(requestParameters, options) {
            return localVarFp.getFolderMetadata(requestParameters.folderId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {FoldersApiGetFolderObjectRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderObject(requestParameters, options) {
            return localVarFp.getFolderObject(requestParameters.folderId, requestParameters.objectKey, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {FoldersApiIndexAllContentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexAllContent(requestParameters, options) {
            return localVarFp.indexAllContent(requestParameters.folderId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {FoldersApiListFolderObjectsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFolderObjects(requestParameters, options) {
            return localVarFp.listFolderObjects(requestParameters.folderId, requestParameters.search, requestParameters.tagId, requestParameters.offset, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {FoldersApiListFolderOperationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFolderOperations(requestParameters, options) {
            return localVarFp.listFolderOperations(requestParameters.folderId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {FoldersApiListFolderSharesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFolderShares(requestParameters, options) {
            return localVarFp.listFolderShares(requestParameters.folderId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFolders(options) {
            return localVarFp.listFolders(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {FoldersApiListTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTags(requestParameters, options) {
            return localVarFp.listTags(requestParameters.folderId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {FoldersApiRefreshFolderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshFolder(requestParameters, options) {
            return localVarFp.refreshFolder(requestParameters.folderId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {FoldersApiRefreshFolderObjectS3MetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshFolderObjectS3Metadata(requestParameters, options) {
            return localVarFp.refreshFolderObjectS3Metadata(requestParameters.folderId, requestParameters.objectKey, requestParameters.refreshFolderObjectS3MetadataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {FoldersApiTagObjectRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagObject(requestParameters, options) {
            return localVarFp.tagObject(requestParameters.folderId, requestParameters.objectKey, requestParameters.tagId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {FoldersApiUntagObjectRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        untagObject(requestParameters, options) {
            return localVarFp.untagObject(requestParameters.folderId, requestParameters.objectKey, requestParameters.tagId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {FoldersApiUpdateFolderShareRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFolderShare(requestParameters, options) {
            return localVarFp.updateFolderShare(requestParameters.folderId, requestParameters.shareId, requestParameters.updateFolderSharePayload, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {FoldersApiUpdateTagRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag(requestParameters, options) {
            return localVarFp.updateTag(requestParameters.folderId, requestParameters.tagId, requestParameters.createTagRequest, options).then((request) => request(axios, basePath));
        },
    };
};
exports.FoldersApiFactory = FoldersApiFactory;
/**
 * FoldersApi - object-oriented interface
 * @export
 * @class FoldersApi
 * @extends {BaseAPI}
 */
class FoldersApi extends base_1.BaseAPI {
    /**
     *
     * @param {FoldersApiCreateFolderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    createFolder(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).createFolder(requestParameters.createFolderRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {FoldersApiCreateFolderShareRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    createFolderShare(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).createFolderShare(requestParameters.folderId, requestParameters.createFolderSharePayload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {FoldersApiCreatePresignedUrlsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    createPresignedUrls(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).createPresignedUrls(requestParameters.folderId, requestParameters.signedURLsRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {FoldersApiCreateSocketAuthenticationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    createSocketAuthentication(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).createSocketAuthentication(requestParameters.folderId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {FoldersApiCreateTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    createTag(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).createTag(requestParameters.folderId, requestParameters.createTagRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {FoldersApiDeleteFolderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    deleteFolder(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).deleteFolder(requestParameters.folderId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {FoldersApiDeleteFolderObjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    deleteFolderObject(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).deleteFolderObject(requestParameters.folderId, requestParameters.objectKey, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {FoldersApiDeleteFolderShareRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    deleteFolderShare(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).deleteFolderShare(requestParameters.folderId, requestParameters.shareId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {FoldersApiDeleteTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    deleteTag(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).deleteTag(requestParameters.folderId, requestParameters.tagId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {FoldersApiEnqueueFolderOperationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    enqueueFolderOperation(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).enqueueFolderOperation(requestParameters.folderId, requestParameters.folderOperationRequestPayload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {FoldersApiGetFolderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    getFolder(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).getFolder(requestParameters.folderId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {FoldersApiGetFolderMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    getFolderMetadata(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).getFolderMetadata(requestParameters.folderId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {FoldersApiGetFolderObjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    getFolderObject(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).getFolderObject(requestParameters.folderId, requestParameters.objectKey, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {FoldersApiIndexAllContentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    indexAllContent(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).indexAllContent(requestParameters.folderId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {FoldersApiListFolderObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    listFolderObjects(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).listFolderObjects(requestParameters.folderId, requestParameters.search, requestParameters.tagId, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {FoldersApiListFolderOperationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    listFolderOperations(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).listFolderOperations(requestParameters.folderId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {FoldersApiListFolderSharesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    listFolderShares(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).listFolderShares(requestParameters.folderId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    listFolders(options) {
        return (0, exports.FoldersApiFp)(this.configuration).listFolders(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {FoldersApiListTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    listTags(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).listTags(requestParameters.folderId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {FoldersApiRefreshFolderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    refreshFolder(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).refreshFolder(requestParameters.folderId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {FoldersApiRefreshFolderObjectS3MetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    refreshFolderObjectS3Metadata(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).refreshFolderObjectS3Metadata(requestParameters.folderId, requestParameters.objectKey, requestParameters.refreshFolderObjectS3MetadataRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {FoldersApiTagObjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    tagObject(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).tagObject(requestParameters.folderId, requestParameters.objectKey, requestParameters.tagId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {FoldersApiUntagObjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    untagObject(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).untagObject(requestParameters.folderId, requestParameters.objectKey, requestParameters.tagId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {FoldersApiUpdateFolderShareRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    updateFolderShare(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).updateFolderShare(requestParameters.folderId, requestParameters.shareId, requestParameters.updateFolderSharePayload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {FoldersApiUpdateTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    updateTag(requestParameters, options) {
        return (0, exports.FoldersApiFp)(this.configuration).updateTag(requestParameters.folderId, requestParameters.tagId, requestParameters.createTagRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.FoldersApi = FoldersApi;
/**
 * ServerApi - axios parameter creator
 * @export
 */
const ServerApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {ServerLocationType} locationType
         * @param {ServerLocationInputData} serverLocationInputData
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addServerLocation: async (locationType, serverLocationInputData, options = {}) => {
            // verify required parameter 'locationType' is not null or undefined
            (0, common_1.assertParamExists)('addServerLocation', 'locationType', locationType);
            // verify required parameter 'serverLocationInputData' is not null or undefined
            (0, common_1.assertParamExists)('addServerLocation', 'serverLocationInputData', serverLocationInputData);
            const localVarPath = `/server/settings/locations/{locationType}`
                .replace(`{${"locationType"}}`, encodeURIComponent(String(locationType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(serverLocationInputData, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {CreateUserData} createUserData
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (createUserData, options = {}) => {
            // verify required parameter 'createUserData' is not null or undefined
            (0, common_1.assertParamExists)('createUser', 'createUserData', createUserData);
            const localVarPath = `/server/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createUserData, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {ServerLocationType} locationType
         * @param {string} locationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteServerLocation: async (locationType, locationId, options = {}) => {
            // verify required parameter 'locationType' is not null or undefined
            (0, common_1.assertParamExists)('deleteServerLocation', 'locationType', locationType);
            // verify required parameter 'locationId' is not null or undefined
            (0, common_1.assertParamExists)('deleteServerLocation', 'locationId', locationId);
            const localVarPath = `/server/settings/locations/{locationType}/{locationId}`
                .replace(`{${"locationType"}}`, encodeURIComponent(String(locationType)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (userId, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('deleteUser', 'userId', userId);
            const localVarPath = `/server/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettings: async (options = {}) => {
            const localVarPath = `/server/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (userId, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('getUser', 'userId', userId);
            const localVarPath = `/server/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {ServerLocationType} locationType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServerLocations: async (locationType, options = {}) => {
            // verify required parameter 'locationType' is not null or undefined
            (0, common_1.assertParamExists)('listServerLocations', 'locationType', locationType);
            const localVarPath = `/server/settings/server-locations/{locationType}`
                .replace(`{${"locationType"}}`, encodeURIComponent(String(locationType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers: async (options = {}) => {
            const localVarPath = `/server/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} settingsKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetSetting: async (settingsKey, options = {}) => {
            // verify required parameter 'settingsKey' is not null or undefined
            (0, common_1.assertParamExists)('resetSetting', 'settingsKey', settingsKey);
            const localVarPath = `/server/settings/{settingsKey}`
                .replace(`{${"settingsKey"}}`, encodeURIComponent(String(settingsKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} settingsKey
         * @param {UpdateSettingRequest} updateSettingRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSetting: async (settingsKey, updateSettingRequest, options = {}) => {
            // verify required parameter 'settingsKey' is not null or undefined
            (0, common_1.assertParamExists)('updateSetting', 'settingsKey', settingsKey);
            // verify required parameter 'updateSettingRequest' is not null or undefined
            (0, common_1.assertParamExists)('updateSetting', 'updateSettingRequest', updateSettingRequest);
            const localVarPath = `/server/settings/{settingsKey}`
                .replace(`{${"settingsKey"}}`, encodeURIComponent(String(settingsKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateSettingRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} userId
         * @param {UpdateUserData} updateUserData
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (userId, updateUserData, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('updateUser', 'userId', userId);
            // verify required parameter 'updateUserData' is not null or undefined
            (0, common_1.assertParamExists)('updateUser', 'updateUserData', updateUserData);
            const localVarPath = `/server/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateUserData, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.ServerApiAxiosParamCreator = ServerApiAxiosParamCreator;
/**
 * ServerApi - functional programming interface
 * @export
 */
const ServerApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ServerApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @param {ServerLocationType} locationType
         * @param {ServerLocationInputData} serverLocationInputData
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addServerLocation(locationType, serverLocationInputData, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addServerLocation(locationType, serverLocationInputData, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {CreateUserData} createUserData
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(createUserData, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(createUserData, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {ServerLocationType} locationType
         * @param {string} locationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteServerLocation(locationType, locationId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteServerLocation(locationType, locationId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(userId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(userId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSettings(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSettings(options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(userId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {ServerLocationType} locationType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listServerLocations(locationType, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listServerLocations(locationType, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsers(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} settingsKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetSetting(settingsKey, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetSetting(settingsKey, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} settingsKey
         * @param {UpdateSettingRequest} updateSettingRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSetting(settingsKey, updateSettingRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSetting(settingsKey, updateSettingRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} userId
         * @param {UpdateUserData} updateUserData
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(userId, updateUserData, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(userId, updateUserData, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.ServerApiFp = ServerApiFp;
/**
 * ServerApi - factory interface
 * @export
 */
const ServerApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ServerApiFp)(configuration);
    return {
        /**
         *
         * @param {ServerApiAddServerLocationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addServerLocation(requestParameters, options) {
            return localVarFp.addServerLocation(requestParameters.locationType, requestParameters.serverLocationInputData, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {ServerApiCreateUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(requestParameters, options) {
            return localVarFp.createUser(requestParameters.createUserData, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {ServerApiDeleteServerLocationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteServerLocation(requestParameters, options) {
            return localVarFp.deleteServerLocation(requestParameters.locationType, requestParameters.locationId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {ServerApiDeleteUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(requestParameters, options) {
            return localVarFp.deleteUser(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettings(options) {
            return localVarFp.getSettings(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {ServerApiGetUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(requestParameters, options) {
            return localVarFp.getUser(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {ServerApiListServerLocationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServerLocations(requestParameters, options) {
            return localVarFp.listServerLocations(requestParameters.locationType, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(options) {
            return localVarFp.listUsers(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {ServerApiResetSettingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetSetting(requestParameters, options) {
            return localVarFp.resetSetting(requestParameters.settingsKey, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {ServerApiUpdateSettingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSetting(requestParameters, options) {
            return localVarFp.updateSetting(requestParameters.settingsKey, requestParameters.updateSettingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {ServerApiUpdateUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(requestParameters, options) {
            return localVarFp.updateUser(requestParameters.userId, requestParameters.updateUserData, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ServerApiFactory = ServerApiFactory;
/**
 * ServerApi - object-oriented interface
 * @export
 * @class ServerApi
 * @extends {BaseAPI}
 */
class ServerApi extends base_1.BaseAPI {
    /**
     *
     * @param {ServerApiAddServerLocationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    addServerLocation(requestParameters, options) {
        return (0, exports.ServerApiFp)(this.configuration).addServerLocation(requestParameters.locationType, requestParameters.serverLocationInputData, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {ServerApiCreateUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    createUser(requestParameters, options) {
        return (0, exports.ServerApiFp)(this.configuration).createUser(requestParameters.createUserData, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {ServerApiDeleteServerLocationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    deleteServerLocation(requestParameters, options) {
        return (0, exports.ServerApiFp)(this.configuration).deleteServerLocation(requestParameters.locationType, requestParameters.locationId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {ServerApiDeleteUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    deleteUser(requestParameters, options) {
        return (0, exports.ServerApiFp)(this.configuration).deleteUser(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    getSettings(options) {
        return (0, exports.ServerApiFp)(this.configuration).getSettings(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {ServerApiGetUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    getUser(requestParameters, options) {
        return (0, exports.ServerApiFp)(this.configuration).getUser(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {ServerApiListServerLocationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    listServerLocations(requestParameters, options) {
        return (0, exports.ServerApiFp)(this.configuration).listServerLocations(requestParameters.locationType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    listUsers(options) {
        return (0, exports.ServerApiFp)(this.configuration).listUsers(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {ServerApiResetSettingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    resetSetting(requestParameters, options) {
        return (0, exports.ServerApiFp)(this.configuration).resetSetting(requestParameters.settingsKey, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {ServerApiUpdateSettingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    updateSetting(requestParameters, options) {
        return (0, exports.ServerApiFp)(this.configuration).updateSetting(requestParameters.settingsKey, requestParameters.updateSettingRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {ServerApiUpdateUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    updateUser(requestParameters, options) {
        return (0, exports.ServerApiFp)(this.configuration).updateUser(requestParameters.userId, requestParameters.updateUserData, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ServerApi = ServerApi;
/**
 * ViewerApi - axios parameter creator
 * @export
 */
const ViewerApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getViewer: async (options = {}) => {
            const localVarPath = `/viewer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {ViewerUpdatePayload} viewerUpdatePayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateViewer: async (viewerUpdatePayload, options = {}) => {
            // verify required parameter 'viewerUpdatePayload' is not null or undefined
            (0, common_1.assertParamExists)('updateViewer', 'viewerUpdatePayload', viewerUpdatePayload);
            const localVarPath = `/viewer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication AccessToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(viewerUpdatePayload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.ViewerApiAxiosParamCreator = ViewerApiAxiosParamCreator;
/**
 * ViewerApi - functional programming interface
 * @export
 */
const ViewerApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ViewerApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getViewer(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getViewer(options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {ViewerUpdatePayload} viewerUpdatePayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateViewer(viewerUpdatePayload, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateViewer(viewerUpdatePayload, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.ViewerApiFp = ViewerApiFp;
/**
 * ViewerApi - factory interface
 * @export
 */
const ViewerApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ViewerApiFp)(configuration);
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getViewer(options) {
            return localVarFp.getViewer(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {ViewerApiUpdateViewerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateViewer(requestParameters, options) {
            return localVarFp.updateViewer(requestParameters.viewerUpdatePayload, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ViewerApiFactory = ViewerApiFactory;
/**
 * ViewerApi - object-oriented interface
 * @export
 * @class ViewerApi
 * @extends {BaseAPI}
 */
class ViewerApi extends base_1.BaseAPI {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewerApi
     */
    getViewer(options) {
        return (0, exports.ViewerApiFp)(this.configuration).getViewer(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {ViewerApiUpdateViewerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewerApi
     */
    updateViewer(requestParameters, options) {
        return (0, exports.ViewerApiFp)(this.configuration).updateViewer(requestParameters.viewerUpdatePayload, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ViewerApi = ViewerApi;
/**
 * WorkerApi - axios parameter creator
 * @export
 */
const WorkerApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {string} operationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeJob: async (operationId, options = {}) => {
            // verify required parameter 'operationId' is not null or undefined
            (0, common_1.assertParamExists)('completeJob', 'operationId', operationId);
            const localVarPath = `/worker/{operationId}/complete`
                .replace(`{${"operationId"}}`, encodeURIComponent(String(operationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication WorkerServiceToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} operationId
         * @param {CreateMetadataUploadUrlsPayload} createMetadataUploadUrlsPayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMetadataUploadUrls: async (operationId, createMetadataUploadUrlsPayload, options = {}) => {
            // verify required parameter 'operationId' is not null or undefined
            (0, common_1.assertParamExists)('createMetadataUploadUrls', 'operationId', operationId);
            // verify required parameter 'createMetadataUploadUrlsPayload' is not null or undefined
            (0, common_1.assertParamExists)('createMetadataUploadUrls', 'createMetadataUploadUrlsPayload', createMetadataUploadUrlsPayload);
            const localVarPath = `/worker/{operationId}/metadata-upload-urls`
                .replace(`{${"operationId"}}`, encodeURIComponent(String(operationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication WorkerServiceToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createMetadataUploadUrlsPayload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} operationId
         * @param {CreateOutputUploadUrlsPayload} createOutputUploadUrlsPayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOutputUploadUrls: async (operationId, createOutputUploadUrlsPayload, options = {}) => {
            // verify required parameter 'operationId' is not null or undefined
            (0, common_1.assertParamExists)('createOutputUploadUrls', 'operationId', operationId);
            // verify required parameter 'createOutputUploadUrlsPayload' is not null or undefined
            (0, common_1.assertParamExists)('createOutputUploadUrls', 'createOutputUploadUrlsPayload', createOutputUploadUrlsPayload);
            const localVarPath = `/worker/{operationId}/output-upload-urls`
                .replace(`{${"operationId"}}`, encodeURIComponent(String(operationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication WorkerServiceToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createOutputUploadUrlsPayload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} operationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startJob: async (operationId, options = {}) => {
            // verify required parameter 'operationId' is not null or undefined
            (0, common_1.assertParamExists)('startJob', 'operationId', operationId);
            const localVarPath = `/worker/{operationId}/start`
                .replace(`{${"operationId"}}`, encodeURIComponent(String(operationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication WorkerServiceToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {Array<ContentAttibutesPayload>} contentAttibutesPayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContentAttributes: async (contentAttibutesPayload, options = {}) => {
            // verify required parameter 'contentAttibutesPayload' is not null or undefined
            (0, common_1.assertParamExists)('updateContentAttributes', 'contentAttibutesPayload', contentAttibutesPayload);
            const localVarPath = `/worker/content-attributes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication WorkerServiceToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(contentAttibutesPayload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {Array<ContentMetadataPayload>} contentMetadataPayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContentMetadata: async (contentMetadataPayload, options = {}) => {
            // verify required parameter 'contentMetadataPayload' is not null or undefined
            (0, common_1.assertParamExists)('updateContentMetadata', 'contentMetadataPayload', contentMetadataPayload);
            const localVarPath = `/worker/content-metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication WorkerServiceToken required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(contentMetadataPayload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.WorkerApiAxiosParamCreator = WorkerApiAxiosParamCreator;
/**
 * WorkerApi - functional programming interface
 * @export
 */
const WorkerApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.WorkerApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @param {string} operationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeJob(operationId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeJob(operationId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} operationId
         * @param {CreateMetadataUploadUrlsPayload} createMetadataUploadUrlsPayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMetadataUploadUrls(operationId, createMetadataUploadUrlsPayload, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMetadataUploadUrls(operationId, createMetadataUploadUrlsPayload, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} operationId
         * @param {CreateOutputUploadUrlsPayload} createOutputUploadUrlsPayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOutputUploadUrls(operationId, createOutputUploadUrlsPayload, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOutputUploadUrls(operationId, createOutputUploadUrlsPayload, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} operationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startJob(operationId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startJob(operationId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {Array<ContentAttibutesPayload>} contentAttibutesPayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateContentAttributes(contentAttibutesPayload, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateContentAttributes(contentAttibutesPayload, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {Array<ContentMetadataPayload>} contentMetadataPayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateContentMetadata(contentMetadataPayload, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateContentMetadata(contentMetadataPayload, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.WorkerApiFp = WorkerApiFp;
/**
 * WorkerApi - factory interface
 * @export
 */
const WorkerApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.WorkerApiFp)(configuration);
    return {
        /**
         *
         * @param {WorkerApiCompleteJobRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeJob(requestParameters, options) {
            return localVarFp.completeJob(requestParameters.operationId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {WorkerApiCreateMetadataUploadUrlsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMetadataUploadUrls(requestParameters, options) {
            return localVarFp.createMetadataUploadUrls(requestParameters.operationId, requestParameters.createMetadataUploadUrlsPayload, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {WorkerApiCreateOutputUploadUrlsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOutputUploadUrls(requestParameters, options) {
            return localVarFp.createOutputUploadUrls(requestParameters.operationId, requestParameters.createOutputUploadUrlsPayload, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {WorkerApiStartJobRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startJob(requestParameters, options) {
            return localVarFp.startJob(requestParameters.operationId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {WorkerApiUpdateContentAttributesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContentAttributes(requestParameters, options) {
            return localVarFp.updateContentAttributes(requestParameters.contentAttibutesPayload, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {WorkerApiUpdateContentMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContentMetadata(requestParameters, options) {
            return localVarFp.updateContentMetadata(requestParameters.contentMetadataPayload, options).then((request) => request(axios, basePath));
        },
    };
};
exports.WorkerApiFactory = WorkerApiFactory;
/**
 * WorkerApi - object-oriented interface
 * @export
 * @class WorkerApi
 * @extends {BaseAPI}
 */
class WorkerApi extends base_1.BaseAPI {
    /**
     *
     * @param {WorkerApiCompleteJobRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkerApi
     */
    completeJob(requestParameters, options) {
        return (0, exports.WorkerApiFp)(this.configuration).completeJob(requestParameters.operationId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {WorkerApiCreateMetadataUploadUrlsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkerApi
     */
    createMetadataUploadUrls(requestParameters, options) {
        return (0, exports.WorkerApiFp)(this.configuration).createMetadataUploadUrls(requestParameters.operationId, requestParameters.createMetadataUploadUrlsPayload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {WorkerApiCreateOutputUploadUrlsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkerApi
     */
    createOutputUploadUrls(requestParameters, options) {
        return (0, exports.WorkerApiFp)(this.configuration).createOutputUploadUrls(requestParameters.operationId, requestParameters.createOutputUploadUrlsPayload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {WorkerApiStartJobRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkerApi
     */
    startJob(requestParameters, options) {
        return (0, exports.WorkerApiFp)(this.configuration).startJob(requestParameters.operationId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {WorkerApiUpdateContentAttributesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkerApi
     */
    updateContentAttributes(requestParameters, options) {
        return (0, exports.WorkerApiFp)(this.configuration).updateContentAttributes(requestParameters.contentAttibutesPayload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {WorkerApiUpdateContentMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkerApi
     */
    updateContentMetadata(requestParameters, options) {
        return (0, exports.WorkerApiFp)(this.configuration).updateContentMetadata(requestParameters.contentMetadataPayload, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.WorkerApi = WorkerApi;
