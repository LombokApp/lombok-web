/* tslint:disable */
/* eslint-disable */
/**
 * @stellariscloud/api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ContentAttibutesPayload
 */
export interface ContentAttibutesPayload {
    /**
     * 
     * @type {string}
     * @memberof ContentAttibutesPayload
     */
    'folderId': string;
    /**
     * 
     * @type {string}
     * @memberof ContentAttibutesPayload
     */
    'objectKey': string;
    /**
     * 
     * @type {string}
     * @memberof ContentAttibutesPayload
     */
    'hash': string;
    /**
     * 
     * @type {ContentAttributesType}
     * @memberof ContentAttibutesPayload
     */
    'attributes': ContentAttributesType;
}
/**
 * 
 * @export
 * @interface ContentAttributesType
 */
export interface ContentAttributesType {
    /**
     * 
     * @type {MediaType}
     * @memberof ContentAttributesType
     */
    'mediaType': MediaType;
    /**
     * 
     * @type {string}
     * @memberof ContentAttributesType
     */
    'mimeType': string;
    /**
     * 
     * @type {number}
     * @memberof ContentAttributesType
     */
    'height': number;
    /**
     * 
     * @type {number}
     * @memberof ContentAttributesType
     */
    'width': number;
    /**
     * 
     * @type {number}
     * @memberof ContentAttributesType
     */
    'orientation': number;
    /**
     * 
     * @type {number}
     * @memberof ContentAttributesType
     */
    'lengthMs': number;
    /**
     * 
     * @type {number}
     * @memberof ContentAttributesType
     */
    'bitrate': number;
}


/**
 * 
 * @export
 * @interface ContentMetadataPayload
 */
export interface ContentMetadataPayload {
    /**
     * 
     * @type {string}
     * @memberof ContentMetadataPayload
     */
    'folderId': string;
    /**
     * 
     * @type {string}
     * @memberof ContentMetadataPayload
     */
    'objectKey': string;
    /**
     * 
     * @type {string}
     * @memberof ContentMetadataPayload
     */
    'hash': string;
    /**
     * 
     * @type {{ [key: string]: MetadataEntry | undefined; }}
     * @memberof ContentMetadataPayload
     */
    'metadata': { [key: string]: MetadataEntry | undefined; };
}
/**
 * 
 * @export
 * @interface CreateFolder200Response
 */
export interface CreateFolder200Response {
    /**
     * 
     * @type {FolderData}
     * @memberof CreateFolder200Response
     */
    'folder': FolderData;
}
/**
 * 
 * @export
 * @interface CreateFolderRequest
 */
export interface CreateFolderRequest {
    /**
     * 
     * @type {UserLocationInputData}
     * @memberof CreateFolderRequest
     */
    'metadataLocation'?: UserLocationInputData;
    /**
     * 
     * @type {UserLocationInputData}
     * @memberof CreateFolderRequest
     */
    'contentLocation': UserLocationInputData;
    /**
     * 
     * @type {string}
     * @memberof CreateFolderRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreateMetadataUploadUrls200Response
 */
export interface CreateMetadataUploadUrls200Response {
    /**
     * 
     * @type {Array<MetadataUploadUrlsResponse>}
     * @memberof CreateMetadataUploadUrls200Response
     */
    'metadataUploadUrls': Array<MetadataUploadUrlsResponse>;
}
/**
 * 
 * @export
 * @interface CreateMetadataUploadUrlsPayload
 */
export interface CreateMetadataUploadUrlsPayload {
    /**
     * 
     * @type {string}
     * @memberof CreateMetadataUploadUrlsPayload
     */
    'contentHash': string;
    /**
     * 
     * @type {Array<CreateMetadataUploadUrlsPayloadMetadataFilesInner>}
     * @memberof CreateMetadataUploadUrlsPayload
     */
    'metadataFiles': Array<CreateMetadataUploadUrlsPayloadMetadataFilesInner>;
}
/**
 * 
 * @export
 * @interface CreateMetadataUploadUrlsPayloadMetadataFilesInner
 */
export interface CreateMetadataUploadUrlsPayloadMetadataFilesInner {
    /**
     * 
     * @type {{ [key: string]: string | undefined; }}
     * @memberof CreateMetadataUploadUrlsPayloadMetadataFilesInner
     */
    'metadataHashes': { [key: string]: string | undefined; };
    /**
     * 
     * @type {string}
     * @memberof CreateMetadataUploadUrlsPayloadMetadataFilesInner
     */
    'objectKey': string;
    /**
     * 
     * @type {string}
     * @memberof CreateMetadataUploadUrlsPayloadMetadataFilesInner
     */
    'folderId': string;
}
/**
 * 
 * @export
 * @interface CreateOutputUploadUrls200Response
 */
export interface CreateOutputUploadUrls200Response {
    /**
     * 
     * @type {Array<OutputUploadUrlsResponse>}
     * @memberof CreateOutputUploadUrls200Response
     */
    'outputUploadUrls': Array<OutputUploadUrlsResponse>;
}
/**
 * 
 * @export
 * @interface CreateOutputUploadUrlsPayload
 */
export interface CreateOutputUploadUrlsPayload {
    /**
     * 
     * @type {Array<CreateOutputUploadUrlsPayloadOutputFilesInner>}
     * @memberof CreateOutputUploadUrlsPayload
     */
    'outputFiles': Array<CreateOutputUploadUrlsPayloadOutputFilesInner>;
}
/**
 * 
 * @export
 * @interface CreateOutputUploadUrlsPayloadOutputFilesInner
 */
export interface CreateOutputUploadUrlsPayloadOutputFilesInner {
    /**
     * 
     * @type {string}
     * @memberof CreateOutputUploadUrlsPayloadOutputFilesInner
     */
    'objectKey': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOutputUploadUrlsPayloadOutputFilesInner
     */
    'folderId': string;
}
/**
 * 
 * @export
 * @interface CreateServerWorkerKey200Response
 */
export interface CreateServerWorkerKey200Response {
    /**
     * 
     * @type {FolderWorkerKeyData}
     * @memberof CreateServerWorkerKey200Response
     */
    'workerKey': FolderWorkerKeyData;
    /**
     * 
     * @type {string}
     * @memberof CreateServerWorkerKey200Response
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface CreateSocketAuthentication200Response
 */
export interface CreateSocketAuthentication200Response {
    /**
     * 
     * @type {string}
     * @memberof CreateSocketAuthentication200Response
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface CreateUserData
 */
export interface CreateUserData {
    /**
     * 
     * @type {boolean}
     * @memberof CreateUserData
     */
    'isAdmin'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateUserData
     */
    'emailVerified'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateUserData
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserData
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserData
     */
    'email'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateUserData
     */
    'permissions'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateUserData
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface DeleteFolder200Response
 */
export interface DeleteFolder200Response {
    /**
     * 
     * @type {boolean}
     * @memberof DeleteFolder200Response
     */
    'success': boolean;
}
/**
 * 
 * @export
 * @interface ErrorData
 */
export interface ErrorData {
    /**
     * 
     * @type {string}
     * @memberof ErrorData
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof ErrorData
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorData
     */
    'detail'?: string;
    /**
     * 
     * @type {{ [key: string]: any | undefined; }}
     * @memberof ErrorData
     */
    'meta'?: { [key: string]: any | undefined; };
    /**
     * 
     * @type {string}
     * @memberof ErrorData
     */
    'pointer'?: string;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {Array<ErrorData>}
     * @memberof ErrorResponse
     */
    'errors': Array<ErrorData>;
}
/**
 * 
 * @export
 * @interface FolderAndPermission
 */
export interface FolderAndPermission {
    /**
     * 
     * @type {FolderData}
     * @memberof FolderAndPermission
     */
    'folder': FolderData;
    /**
     * 
     * @type {Array<string>}
     * @memberof FolderAndPermission
     */
    'permissions': Array<string>;
}
/**
 * 
 * @export
 * @interface FolderData
 */
export interface FolderData {
    /**
     * 
     * @type {string}
     * @memberof FolderData
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof FolderData
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof FolderData
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FolderData
     */
    'ownerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof FolderData
     */
    'name': string;
    /**
     * 
     * @type {StorageLocationData}
     * @memberof FolderData
     */
    'metadataLocation': StorageLocationData;
    /**
     * 
     * @type {StorageLocationData}
     * @memberof FolderData
     */
    'contentLocation': StorageLocationData;
}
/**
 * 
 * @export
 * @interface FolderObjectData
 */
export interface FolderObjectData {
    /**
     * 
     * @type {string}
     * @memberof FolderObjectData
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof FolderObjectData
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof FolderObjectData
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FolderObjectData
     */
    'objectKey': string;
    /**
     * 
     * @type {string}
     * @memberof FolderObjectData
     */
    'folderId': string;
    /**
     * 
     * @type {{ [key: string]: ContentAttributesType | undefined; }}
     * @memberof FolderObjectData
     */
    'contentAttributes': { [key: string]: ContentAttributesType | undefined; };
    /**
     * 
     * @type {{ [key: string]: { [key: string]: MetadataEntry | undefined; } | undefined; }}
     * @memberof FolderObjectData
     */
    'contentMetadata': { [key: string]: { [key: string]: MetadataEntry | undefined; } | undefined; };
    /**
     * 
     * @type {string}
     * @memberof FolderObjectData
     */
    'hash': string | null;
    /**
     * 
     * @type {number}
     * @memberof FolderObjectData
     */
    'lastModified': number;
    /**
     * 
     * @type {string}
     * @memberof FolderObjectData
     */
    'eTag': string;
    /**
     * 
     * @type {number}
     * @memberof FolderObjectData
     */
    'sizeBytes': number;
    /**
     * 
     * @type {MediaType}
     * @memberof FolderObjectData
     */
    'mediaType': MediaType;
    /**
     * 
     * @type {string}
     * @memberof FolderObjectData
     */
    'mimeType': string;
}


/**
 * 
 * @export
 * @interface FolderOperationData
 */
export interface FolderOperationData {
    /**
     * 
     * @type {string}
     * @memberof FolderOperationData
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof FolderOperationData
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof FolderOperationData
     */
    'id': string;
    /**
     * 
     * @type {FolderOperationName}
     * @memberof FolderOperationData
     */
    'operationName': FolderOperationName;
    /**
     * 
     * @type {{ [key: string]: any | undefined; }}
     * @memberof FolderOperationData
     */
    'operationData': { [key: string]: any | undefined; };
    /**
     * 
     * @type {boolean}
     * @memberof FolderOperationData
     */
    'started': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FolderOperationData
     */
    'completed': boolean;
    /**
     * 
     * @type {string}
     * @memberof FolderOperationData
     */
    'error': string | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const FolderOperationName = {
    IndexFolderObject: 'IndexFolderObject',
    TranscribeAudio: 'TranscribeAudio',
    DetectObjects: 'DetectObjects'
} as const;

export type FolderOperationName = typeof FolderOperationName[keyof typeof FolderOperationName];


/**
 * 
 * @export
 * @interface FolderOperationRequestPayload
 */
export interface FolderOperationRequestPayload {
    /**
     * 
     * @type {FolderOperationName}
     * @memberof FolderOperationRequestPayload
     */
    'operationName': FolderOperationName;
    /**
     * 
     * @type {{ [key: string]: any | undefined; }}
     * @memberof FolderOperationRequestPayload
     */
    'operationData': { [key: string]: any | undefined; };
}


/**
 * 
 * @export
 * @enum {string}
 */

export const FolderOperationSort = {
    CreatedAtAsc: 'createdAt-asc',
    CreatedAtDesc: 'createdAt-desc',
    UpdatedAtAsc: 'updatedAt-asc',
    UpdatedAtDesc: 'updatedAt-desc'
} as const;

export type FolderOperationSort = typeof FolderOperationSort[keyof typeof FolderOperationSort];


/**
 * 
 * @export
 * @enum {string}
 */

export const FolderOperationStatus = {
    Pending: 'PENDING',
    Failed: 'FAILED',
    Complete: 'COMPLETE'
} as const;

export type FolderOperationStatus = typeof FolderOperationStatus[keyof typeof FolderOperationStatus];


/**
 * 
 * @export
 * @interface FolderOperationsResponse
 */
export interface FolderOperationsResponse {
    /**
     * 
     * @type {ListServerWorkerKeys200ResponseMeta}
     * @memberof FolderOperationsResponse
     */
    'meta': ListServerWorkerKeys200ResponseMeta;
    /**
     * 
     * @type {Array<FolderOperationData>}
     * @memberof FolderOperationsResponse
     */
    'result': Array<FolderOperationData>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const FolderPermissionName = {
    FolderRefresh: 'folder_refresh',
    FolderManageShares: 'folder_manage_shares',
    FolderForget: 'folder_forget',
    ObjectEdit: 'object_edit',
    ObjectManage: 'object_manage',
    TagCreate: 'tag_create',
    TagAssociate: 'tag_associate'
} as const;

export type FolderPermissionName = typeof FolderPermissionName[keyof typeof FolderPermissionName];


/**
 * 
 * @export
 * @interface FolderWorkerData
 */
export interface FolderWorkerData {
    /**
     * 
     * @type {string}
     * @memberof FolderWorkerData
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FolderWorkerData
     */
    'externalId': string;
    /**
     * 
     * @type {boolean}
     * @memberof FolderWorkerData
     */
    'paused': boolean;
    /**
     * 
     * @type {{ [key: string]: FolderWorkerDataIpsValue | undefined; }}
     * @memberof FolderWorkerData
     */
    'ips': { [key: string]: FolderWorkerDataIpsValue | undefined; };
    /**
     * 
     * @type {Array<string>}
     * @memberof FolderWorkerData
     */
    'capabilities': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof FolderWorkerData
     */
    'firstSeen': string;
    /**
     * 
     * @type {string}
     * @memberof FolderWorkerData
     */
    'lastSeen': string;
    /**
     * 
     * @type {string}
     * @memberof FolderWorkerData
     */
    'keyId': string | null;
    /**
     * 
     * @type {string}
     * @memberof FolderWorkerData
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof FolderWorkerData
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface FolderWorkerDataIpsValue
 */
export interface FolderWorkerDataIpsValue {
    /**
     * 
     * @type {string}
     * @memberof FolderWorkerDataIpsValue
     */
    'lastSeen': string;
    /**
     * 
     * @type {string}
     * @memberof FolderWorkerDataIpsValue
     */
    'firstSeen': string;
}
/**
 * 
 * @export
 * @interface FolderWorkerKeyData
 */
export interface FolderWorkerKeyData {
    /**
     * 
     * @type {string}
     * @memberof FolderWorkerKeyData
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FolderWorkerKeyData
     */
    'accessTokenExpiresAt': string;
    /**
     * 
     * @type {string}
     * @memberof FolderWorkerKeyData
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof FolderWorkerKeyData
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const FolderWorkerKeySort = {
    CreatedAtAsc: 'createdAt-asc',
    CreatedAtDesc: 'createdAt-desc',
    UpdatedAtAsc: 'updatedAt-asc',
    UpdatedAtDesc: 'updatedAt-desc'
} as const;

export type FolderWorkerKeySort = typeof FolderWorkerKeySort[keyof typeof FolderWorkerKeySort];


/**
 * 
 * @export
 * @enum {string}
 */

export const FolderWorkerSort = {
    CreatedAtAsc: 'createdAt-asc',
    CreatedAtDesc: 'createdAt-desc',
    UpdatedAtAsc: 'updatedAt-asc',
    UpdatedAtDesc: 'updatedAt-desc',
    LastSeenAsc: 'lastSeen-asc',
    LastSeenDesc: 'lastSeen-desc',
    FirstSeenAsc: 'firstSeen-asc',
    FirstSeenDesc: 'firstSeen-desc'
} as const;

export type FolderWorkerSort = typeof FolderWorkerSort[keyof typeof FolderWorkerSort];


/**
 * 
 * @export
 * @interface GetFolder200Response
 */
export interface GetFolder200Response {
    /**
     * 
     * @type {Array<FolderPermissionName>}
     * @memberof GetFolder200Response
     */
    'permissions': Array<FolderPermissionName>;
    /**
     * 
     * @type {FolderData}
     * @memberof GetFolder200Response
     */
    'folder': FolderData;
}
/**
 * 
 * @export
 * @interface GetFolderMetadata200Response
 */
export interface GetFolderMetadata200Response {
    /**
     * 
     * @type {number}
     * @memberof GetFolderMetadata200Response
     */
    'totalSizeBytes': number;
    /**
     * 
     * @type {number}
     * @memberof GetFolderMetadata200Response
     */
    'totalCount': number;
}
/**
 * 
 * @export
 * @interface GetSettings200Response
 */
export interface GetSettings200Response {
    /**
     * 
     * @type {ServerSettings}
     * @memberof GetSettings200Response
     */
    'settings': ServerSettings;
}
/**
 * 
 * @export
 * @interface GetUser200Response
 */
export interface GetUser200Response {
    /**
     * 
     * @type {UserData}
     * @memberof GetUser200Response
     */
    'result': UserData;
}
/**
 * 
 * @export
 * @interface ListFolderObjects200Response
 */
export interface ListFolderObjects200Response {
    /**
     * 
     * @type {ListResponseMeta}
     * @memberof ListFolderObjects200Response
     */
    'meta': ListResponseMeta;
    /**
     * 
     * @type {Array<FolderObjectData>}
     * @memberof ListFolderObjects200Response
     */
    'result': Array<FolderObjectData>;
}
/**
 * 
 * @export
 * @interface ListFoldersResponse
 */
export interface ListFoldersResponse {
    /**
     * 
     * @type {ListServerWorkerKeys200ResponseMeta}
     * @memberof ListFoldersResponse
     */
    'meta': ListServerWorkerKeys200ResponseMeta;
    /**
     * 
     * @type {Array<FolderAndPermission>}
     * @memberof ListFoldersResponse
     */
    'result': Array<FolderAndPermission>;
}
/**
 * 
 * @export
 * @interface ListResponseMeta
 */
export interface ListResponseMeta {
    /**
     * 
     * @type {number}
     * @memberof ListResponseMeta
     */
    'totalCount': number;
}
/**
 * 
 * @export
 * @interface ListServerWorkerKeys200Response
 */
export interface ListServerWorkerKeys200Response {
    /**
     * 
     * @type {Array<FolderWorkerKeyData>}
     * @memberof ListServerWorkerKeys200Response
     */
    'result': Array<FolderWorkerKeyData>;
    /**
     * 
     * @type {ListServerWorkerKeys200ResponseMeta}
     * @memberof ListServerWorkerKeys200Response
     */
    'meta': ListServerWorkerKeys200ResponseMeta;
}
/**
 * 
 * @export
 * @interface ListServerWorkerKeys200ResponseMeta
 */
export interface ListServerWorkerKeys200ResponseMeta {
    /**
     * 
     * @type {number}
     * @memberof ListServerWorkerKeys200ResponseMeta
     */
    'totalCount': number;
}
/**
 * 
 * @export
 * @interface ListServerWorkers200Response
 */
export interface ListServerWorkers200Response {
    /**
     * 
     * @type {Array<FolderWorkerData>}
     * @memberof ListServerWorkers200Response
     */
    'result': Array<FolderWorkerData>;
    /**
     * 
     * @type {ListServerWorkerKeys200ResponseMeta}
     * @memberof ListServerWorkers200Response
     */
    'meta': ListServerWorkerKeys200ResponseMeta;
}
/**
 * 
 * @export
 * @interface ListUsersResponse
 */
export interface ListUsersResponse {
    /**
     * 
     * @type {ListServerWorkerKeys200ResponseMeta}
     * @memberof ListUsersResponse
     */
    'meta': ListServerWorkerKeys200ResponseMeta;
    /**
     * 
     * @type {Array<UserData>}
     * @memberof ListUsersResponse
     */
    'result': Array<UserData>;
}
/**
 * 
 * @export
 * @interface LoginParams
 */
export interface LoginParams {
    /**
     * 
     * @type {string}
     * @memberof LoginParams
     */
    'login': string;
    /**
     * 
     * @type {string}
     * @memberof LoginParams
     */
    'password': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const MediaType = {
    Image: 'IMAGE',
    Video: 'VIDEO',
    Audio: 'AUDIO',
    Document: 'DOCUMENT',
    Unknown: 'UNKNOWN'
} as const;

export type MediaType = typeof MediaType[keyof typeof MediaType];


/**
 * 
 * @export
 * @interface MetadataEntry
 */
export interface MetadataEntry {
    /**
     * 
     * @type {string}
     * @memberof MetadataEntry
     */
    'mimeType': string;
    /**
     * 
     * @type {number}
     * @memberof MetadataEntry
     */
    'size': number;
    /**
     * 
     * @type {string}
     * @memberof MetadataEntry
     */
    'hash': string;
}
/**
 * 
 * @export
 * @interface MetadataUploadUrlsResponse
 */
export interface MetadataUploadUrlsResponse {
    /**
     * 
     * @type {string}
     * @memberof MetadataUploadUrlsResponse
     */
    'folderId': string;
    /**
     * 
     * @type {string}
     * @memberof MetadataUploadUrlsResponse
     */
    'objectKey': string;
    /**
     * 
     * @type {{ [key: string]: string | undefined; }}
     * @memberof MetadataUploadUrlsResponse
     */
    'urls': { [key: string]: string | undefined; };
}
/**
 * 
 * @export
 * @interface OutputUploadUrlsResponse
 */
export interface OutputUploadUrlsResponse {
    /**
     * 
     * @type {string}
     * @memberof OutputUploadUrlsResponse
     */
    'folderId': string;
    /**
     * 
     * @type {string}
     * @memberof OutputUploadUrlsResponse
     */
    'objectKey': string;
    /**
     * 
     * @type {string}
     * @memberof OutputUploadUrlsResponse
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface RefreshFolderObjectS3MetadataRequest
 */
export interface RefreshFolderObjectS3MetadataRequest {
    /**
     * 
     * @type {string}
     * @memberof RefreshFolderObjectS3MetadataRequest
     */
    'eTag'?: string;
}
/**
 * 
 * @export
 * @interface ServerLocationData
 */
export interface ServerLocationData {
    /**
     * 
     * @type {string}
     * @memberof ServerLocationData
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ServerLocationData
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ServerLocationData
     */
    'endpoint': string;
    /**
     * 
     * @type {string}
     * @memberof ServerLocationData
     */
    'accessKeyId': string;
    /**
     * 
     * @type {string}
     * @memberof ServerLocationData
     */
    'region': string;
    /**
     * 
     * @type {string}
     * @memberof ServerLocationData
     */
    'bucket': string;
    /**
     * 
     * @type {string}
     * @memberof ServerLocationData
     */
    'prefix'?: string;
}
/**
 * 
 * @export
 * @interface ServerLocationInputData
 */
export interface ServerLocationInputData {
    /**
     * 
     * @type {string}
     * @memberof ServerLocationInputData
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ServerLocationInputData
     */
    'endpoint': string;
    /**
     * 
     * @type {string}
     * @memberof ServerLocationInputData
     */
    'accessKeyId': string;
    /**
     * 
     * @type {string}
     * @memberof ServerLocationInputData
     */
    'secretAccessKey': string;
    /**
     * 
     * @type {string}
     * @memberof ServerLocationInputData
     */
    'region': string;
    /**
     * 
     * @type {string}
     * @memberof ServerLocationInputData
     */
    'bucket': string;
    /**
     * 
     * @type {string}
     * @memberof ServerLocationInputData
     */
    'prefix'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ServerLocationType = {
    Metadata: 'USER_METADATA',
    Content: 'USER_CONTENT',
    Backup: 'USER_BACKUP'
} as const;

export type ServerLocationType = typeof ServerLocationType[keyof typeof ServerLocationType];


/**
 * 
 * @export
 * @interface ServerSettings
 */
export interface ServerSettings {
    /**
     * 
     * @type {boolean}
     * @memberof ServerSettings
     */
    'SIGNUP_ENABLED': boolean;
}
/**
 * 
 * @export
 * @interface SessionResponse
 */
export interface SessionResponse {
    /**
     * 
     * @type {string}
     * @memberof SessionResponse
     */
    'accessToken': string;
    /**
     * 
     * @type {string}
     * @memberof SessionResponse
     */
    'refreshToken': string;
    /**
     * 
     * @type {string}
     * @memberof SessionResponse
     */
    'expiresAt': string;
}
/**
 * 
 * @export
 * @interface SignedURLsRequest
 */
export interface SignedURLsRequest {
    /**
     * 
     * @type {string}
     * @memberof SignedURLsRequest
     */
    'objectIdentifier': string;
    /**
     * 
     * @type {SignedURLsRequestMethod}
     * @memberof SignedURLsRequest
     */
    'method': SignedURLsRequestMethod;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const SignedURLsRequestMethod = {
    Put: 'PUT',
    Delete: 'DELETE',
    Get: 'GET'
} as const;

export type SignedURLsRequestMethod = typeof SignedURLsRequestMethod[keyof typeof SignedURLsRequestMethod];


/**
 * 
 * @export
 * @interface Signup201Response
 */
export interface Signup201Response {
    /**
     * 
     * @type {UserData}
     * @memberof Signup201Response
     */
    'user': UserData;
}
/**
 * 
 * @export
 * @interface SignupParams
 */
export interface SignupParams {
    /**
     * 
     * @type {string}
     * @memberof SignupParams
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof SignupParams
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SignupParams
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface StartJob200ResponseInner
 */
export interface StartJob200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof StartJob200ResponseInner
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof StartJob200ResponseInner
     */
    'objectKey': string;
    /**
     * 
     * @type {string}
     * @memberof StartJob200ResponseInner
     */
    'folderId': string;
}
/**
 * 
 * @export
 * @interface StorageLocationData
 */
export interface StorageLocationData {
    /**
     * 
     * @type {string}
     * @memberof StorageLocationData
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof StorageLocationData
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof StorageLocationData
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof StorageLocationData
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageLocationData
     */
    'providerType': StorageLocationDataProviderTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof StorageLocationData
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof StorageLocationData
     */
    'endpoint': string;
    /**
     * 
     * @type {string}
     * @memberof StorageLocationData
     */
    'region'?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageLocationData
     */
    'bucket': string;
    /**
     * 
     * @type {string}
     * @memberof StorageLocationData
     */
    'prefix'?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageLocationData
     */
    'accessKeyId': string;
}

export const StorageLocationDataProviderTypeEnum = {
    Server: 'SERVER',
    User: 'USER'
} as const;

export type StorageLocationDataProviderTypeEnum = typeof StorageLocationDataProviderTypeEnum[keyof typeof StorageLocationDataProviderTypeEnum];

/**
 * 
 * @export
 * @interface UpdateSettingRequest
 */
export interface UpdateSettingRequest {
    /**
     * 
     * @type {any}
     * @memberof UpdateSettingRequest
     */
    'value': any;
}
/**
 * 
 * @export
 * @interface UpdateUserData
 */
export interface UpdateUserData {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserData
     */
    'isAdmin'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserData
     */
    'emailVerified'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserData
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserData
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserData
     */
    'email'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateUserData
     */
    'permissions'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UserData
 */
export interface UserData {
    /**
     * 
     * @type {string}
     * @memberof UserData
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserData
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserData
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserData
     */
    'name': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserData
     */
    'email': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserData
     */
    'emailVerified': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserData
     */
    'isAdmin': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserData
     */
    'username'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserData
     */
    'permissions': Array<string>;
}
/**
 * 
 * @export
 * @interface UserLocationInputData
 */
export interface UserLocationInputData {
    /**
     * 
     * @type {string}
     * @memberof UserLocationInputData
     */
    'serverLocationId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLocationInputData
     */
    'userLocationId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLocationInputData
     */
    'userLocationBucketOverride'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLocationInputData
     */
    'userLocationPrefixOverride'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLocationInputData
     */
    'accessKeyId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLocationInputData
     */
    'secretAccessKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLocationInputData
     */
    'endpoint'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLocationInputData
     */
    'bucket'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLocationInputData
     */
    'region'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLocationInputData
     */
    'prefix'?: string;
}
/**
 * 
 * @export
 * @interface ViewerUpdatePayload
 */
export interface ViewerUpdatePayload {
    /**
     * 
     * @type {string}
     * @memberof ViewerUpdatePayload
     */
    'name': string;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {LoginParams} loginParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginParams: LoginParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginParams' is not null or undefined
            assertParamExists('login', 'loginParams', loginParams)
            const localVarPath = `/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication RefreshToken required
            await setApiKeyToObject(localVarQueryParameter, "refresh_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Given a user\'s credentials, this endpoint will create a new user.
         * @param {SignupParams} signupParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signup: async (signupParams: SignupParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signupParams' is not null or undefined
            assertParamExists('signup', 'signupParams', signupParams)
            const localVarPath = `/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signupParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {LoginParams} loginParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginParams: LoginParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Given a user\'s credentials, this endpoint will create a new user.
         * @param {SignupParams} signupParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signup(signupParams: SignupParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Signup201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signup(signupParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @param {AuthApiLoginRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(requestParameters: AuthApiLoginRequest, options?: AxiosRequestConfig): AxiosPromise<SessionResponse> {
            return localVarFp.login(requestParameters.loginParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(options?: AxiosRequestConfig): AxiosPromise<SessionResponse> {
            return localVarFp.refreshToken(options).then((request) => request(axios, basePath));
        },
        /**
         * Given a user\'s credentials, this endpoint will create a new user.
         * @param {AuthApiSignupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signup(requestParameters: AuthApiSignupRequest, options?: AxiosRequestConfig): AxiosPromise<Signup201Response> {
            return localVarFp.signup(requestParameters.signupParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for login operation in AuthApi.
 * @export
 * @interface AuthApiLoginRequest
 */
export interface AuthApiLoginRequest {
    /**
     * 
     * @type {LoginParams}
     * @memberof AuthApiLogin
     */
    readonly loginParams: LoginParams
}

/**
 * Request parameters for signup operation in AuthApi.
 * @export
 * @interface AuthApiSignupRequest
 */
export interface AuthApiSignupRequest {
    /**
     * 
     * @type {SignupParams}
     * @memberof AuthApiSignup
     */
    readonly signupParams: SignupParams
}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @param {AuthApiLoginRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public login(requestParameters: AuthApiLoginRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).login(requestParameters.loginParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public logout(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public refreshToken(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).refreshToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Given a user\'s credentials, this endpoint will create a new user.
     * @param {AuthApiSignupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public signup(requestParameters: AuthApiSignupRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).signup(requestParameters.signupParams, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FoldersApi - axios parameter creator
 * @export
 */
export const FoldersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateFolderRequest} createFolderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolder: async (createFolderRequest: CreateFolderRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createFolderRequest' is not null or undefined
            assertParamExists('createFolder', 'createFolderRequest', createFolderRequest)
            const localVarPath = `/folders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFolderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} folderId 
         * @param {Array<SignedURLsRequest>} signedURLsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPresignedUrls: async (folderId: string, signedURLsRequest: Array<SignedURLsRequest>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('createPresignedUrls', 'folderId', folderId)
            // verify required parameter 'signedURLsRequest' is not null or undefined
            assertParamExists('createPresignedUrls', 'signedURLsRequest', signedURLsRequest)
            const localVarPath = `/folders/{folderId}/presigned-urls`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signedURLsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSocketAuthentication: async (folderId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('createSocketAuthentication', 'folderId', folderId)
            const localVarPath = `/folders/{folderId}/socket-auth`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolder: async (folderId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('deleteFolder', 'folderId', folderId)
            const localVarPath = `/folders/{folderId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} folderId 
         * @param {string} objectKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolderObject: async (folderId: string, objectKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('deleteFolderObject', 'folderId', folderId)
            // verify required parameter 'objectKey' is not null or undefined
            assertParamExists('deleteFolderObject', 'objectKey', objectKey)
            const localVarPath = `/folders/{folderId}/objects/{objectKey}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
                .replace(`{${"objectKey"}}`, encodeURIComponent(String(objectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} folderId 
         * @param {FolderOperationRequestPayload} folderOperationRequestPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enqueueFolderOperation: async (folderId: string, folderOperationRequestPayload: FolderOperationRequestPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('enqueueFolderOperation', 'folderId', folderId)
            // verify required parameter 'folderOperationRequestPayload' is not null or undefined
            assertParamExists('enqueueFolderOperation', 'folderOperationRequestPayload', folderOperationRequestPayload)
            const localVarPath = `/folders/{folderId}/operations`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(folderOperationRequestPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolder: async (folderId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('getFolder', 'folderId', folderId)
            const localVarPath = `/folders/{folderId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderMetadata: async (folderId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('getFolderMetadata', 'folderId', folderId)
            const localVarPath = `/folders/{folderId}/metadata`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} folderId 
         * @param {string} objectKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderObject: async (folderId: string, objectKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('getFolderObject', 'folderId', folderId)
            // verify required parameter 'objectKey' is not null or undefined
            assertParamExists('getFolderObject', 'objectKey', objectKey)
            const localVarPath = `/folders/{folderId}/objects/{objectKey}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
                .replace(`{${"objectKey"}}`, encodeURIComponent(String(objectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexAllContent: async (folderId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('indexAllContent', 'folderId', folderId)
            const localVarPath = `/folders/{folderId}/index-all`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} folderId 
         * @param {string} [search] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFolderObjects: async (folderId: string, search?: string, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('listFolderObjects', 'folderId', folderId)
            const localVarPath = `/folders/{folderId}/objects`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} folderId 
         * @param {FolderOperationSort} [sort] 
         * @param {FolderOperationStatus} [status] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFolderOperations: async (folderId: string, sort?: FolderOperationSort, status?: FolderOperationStatus, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('listFolderOperations', 'folderId', folderId)
            const localVarPath = `/folders/{folderId}/operations`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFolders: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/folders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshFolder: async (folderId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('refreshFolder', 'folderId', folderId)
            const localVarPath = `/folders/{folderId}/refresh`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} folderId 
         * @param {string} objectKey 
         * @param {RefreshFolderObjectS3MetadataRequest} refreshFolderObjectS3MetadataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshFolderObjectS3Metadata: async (folderId: string, objectKey: string, refreshFolderObjectS3MetadataRequest: RefreshFolderObjectS3MetadataRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('refreshFolderObjectS3Metadata', 'folderId', folderId)
            // verify required parameter 'objectKey' is not null or undefined
            assertParamExists('refreshFolderObjectS3Metadata', 'objectKey', objectKey)
            // verify required parameter 'refreshFolderObjectS3MetadataRequest' is not null or undefined
            assertParamExists('refreshFolderObjectS3Metadata', 'refreshFolderObjectS3MetadataRequest', refreshFolderObjectS3MetadataRequest)
            const localVarPath = `/folders/{folderId}/objects/{objectKey}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
                .replace(`{${"objectKey"}}`, encodeURIComponent(String(objectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshFolderObjectS3MetadataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FoldersApi - functional programming interface
 * @export
 */
export const FoldersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FoldersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateFolderRequest} createFolderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFolder(createFolderRequest: CreateFolderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateFolder200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFolder(createFolderRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} folderId 
         * @param {Array<SignedURLsRequest>} signedURLsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPresignedUrls(folderId: string, signedURLsRequest: Array<SignedURLsRequest>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPresignedUrls(folderId, signedURLsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSocketAuthentication(folderId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateSocketAuthentication200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSocketAuthentication(folderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFolder(folderId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteFolder200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFolder(folderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} folderId 
         * @param {string} objectKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFolderObject(folderId: string, objectKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteFolder200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFolderObject(folderId, objectKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} folderId 
         * @param {FolderOperationRequestPayload} folderOperationRequestPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enqueueFolderOperation(folderId: string, folderOperationRequestPayload: FolderOperationRequestPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderOperationData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enqueueFolderOperation(folderId, folderOperationRequestPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolder(folderId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFolder200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolder(folderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolderMetadata(folderId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFolderMetadata200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolderMetadata(folderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} folderId 
         * @param {string} objectKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolderObject(folderId: string, objectKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderObjectData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolderObject(folderId, objectKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async indexAllContent(folderId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.indexAllContent(folderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} folderId 
         * @param {string} [search] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFolderObjects(folderId: string, search?: string, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListFolderObjects200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFolderObjects(folderId, search, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} folderId 
         * @param {FolderOperationSort} [sort] 
         * @param {FolderOperationStatus} [status] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFolderOperations(folderId: string, sort?: FolderOperationSort, status?: FolderOperationStatus, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderOperationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFolderOperations(folderId, sort, status, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFolders(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListFoldersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFolders(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshFolder(folderId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshFolder(folderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} folderId 
         * @param {string} objectKey 
         * @param {RefreshFolderObjectS3MetadataRequest} refreshFolderObjectS3MetadataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshFolderObjectS3Metadata(folderId: string, objectKey: string, refreshFolderObjectS3MetadataRequest: RefreshFolderObjectS3MetadataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderObjectData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshFolderObjectS3Metadata(folderId, objectKey, refreshFolderObjectS3MetadataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FoldersApi - factory interface
 * @export
 */
export const FoldersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FoldersApiFp(configuration)
    return {
        /**
         * 
         * @param {FoldersApiCreateFolderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolder(requestParameters: FoldersApiCreateFolderRequest, options?: AxiosRequestConfig): AxiosPromise<CreateFolder200Response> {
            return localVarFp.createFolder(requestParameters.createFolderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FoldersApiCreatePresignedUrlsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPresignedUrls(requestParameters: FoldersApiCreatePresignedUrlsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.createPresignedUrls(requestParameters.folderId, requestParameters.signedURLsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FoldersApiCreateSocketAuthenticationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSocketAuthentication(requestParameters: FoldersApiCreateSocketAuthenticationRequest, options?: AxiosRequestConfig): AxiosPromise<CreateSocketAuthentication200Response> {
            return localVarFp.createSocketAuthentication(requestParameters.folderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FoldersApiDeleteFolderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolder(requestParameters: FoldersApiDeleteFolderRequest, options?: AxiosRequestConfig): AxiosPromise<DeleteFolder200Response> {
            return localVarFp.deleteFolder(requestParameters.folderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FoldersApiDeleteFolderObjectRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolderObject(requestParameters: FoldersApiDeleteFolderObjectRequest, options?: AxiosRequestConfig): AxiosPromise<DeleteFolder200Response> {
            return localVarFp.deleteFolderObject(requestParameters.folderId, requestParameters.objectKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FoldersApiEnqueueFolderOperationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enqueueFolderOperation(requestParameters: FoldersApiEnqueueFolderOperationRequest, options?: AxiosRequestConfig): AxiosPromise<FolderOperationData> {
            return localVarFp.enqueueFolderOperation(requestParameters.folderId, requestParameters.folderOperationRequestPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FoldersApiGetFolderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolder(requestParameters: FoldersApiGetFolderRequest, options?: AxiosRequestConfig): AxiosPromise<GetFolder200Response> {
            return localVarFp.getFolder(requestParameters.folderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FoldersApiGetFolderMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderMetadata(requestParameters: FoldersApiGetFolderMetadataRequest, options?: AxiosRequestConfig): AxiosPromise<GetFolderMetadata200Response> {
            return localVarFp.getFolderMetadata(requestParameters.folderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FoldersApiGetFolderObjectRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderObject(requestParameters: FoldersApiGetFolderObjectRequest, options?: AxiosRequestConfig): AxiosPromise<FolderObjectData> {
            return localVarFp.getFolderObject(requestParameters.folderId, requestParameters.objectKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FoldersApiIndexAllContentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexAllContent(requestParameters: FoldersApiIndexAllContentRequest, options?: AxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.indexAllContent(requestParameters.folderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FoldersApiListFolderObjectsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFolderObjects(requestParameters: FoldersApiListFolderObjectsRequest, options?: AxiosRequestConfig): AxiosPromise<ListFolderObjects200Response> {
            return localVarFp.listFolderObjects(requestParameters.folderId, requestParameters.search, requestParameters.offset, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FoldersApiListFolderOperationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFolderOperations(requestParameters: FoldersApiListFolderOperationsRequest, options?: AxiosRequestConfig): AxiosPromise<FolderOperationsResponse> {
            return localVarFp.listFolderOperations(requestParameters.folderId, requestParameters.sort, requestParameters.status, requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFolders(options?: AxiosRequestConfig): AxiosPromise<ListFoldersResponse> {
            return localVarFp.listFolders(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FoldersApiRefreshFolderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshFolder(requestParameters: FoldersApiRefreshFolderRequest, options?: AxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.refreshFolder(requestParameters.folderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FoldersApiRefreshFolderObjectS3MetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshFolderObjectS3Metadata(requestParameters: FoldersApiRefreshFolderObjectS3MetadataRequest, options?: AxiosRequestConfig): AxiosPromise<FolderObjectData> {
            return localVarFp.refreshFolderObjectS3Metadata(requestParameters.folderId, requestParameters.objectKey, requestParameters.refreshFolderObjectS3MetadataRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createFolder operation in FoldersApi.
 * @export
 * @interface FoldersApiCreateFolderRequest
 */
export interface FoldersApiCreateFolderRequest {
    /**
     * 
     * @type {CreateFolderRequest}
     * @memberof FoldersApiCreateFolder
     */
    readonly createFolderRequest: CreateFolderRequest
}

/**
 * Request parameters for createPresignedUrls operation in FoldersApi.
 * @export
 * @interface FoldersApiCreatePresignedUrlsRequest
 */
export interface FoldersApiCreatePresignedUrlsRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiCreatePresignedUrls
     */
    readonly folderId: string

    /**
     * 
     * @type {Array<SignedURLsRequest>}
     * @memberof FoldersApiCreatePresignedUrls
     */
    readonly signedURLsRequest: Array<SignedURLsRequest>
}

/**
 * Request parameters for createSocketAuthentication operation in FoldersApi.
 * @export
 * @interface FoldersApiCreateSocketAuthenticationRequest
 */
export interface FoldersApiCreateSocketAuthenticationRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiCreateSocketAuthentication
     */
    readonly folderId: string
}

/**
 * Request parameters for deleteFolder operation in FoldersApi.
 * @export
 * @interface FoldersApiDeleteFolderRequest
 */
export interface FoldersApiDeleteFolderRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiDeleteFolder
     */
    readonly folderId: string
}

/**
 * Request parameters for deleteFolderObject operation in FoldersApi.
 * @export
 * @interface FoldersApiDeleteFolderObjectRequest
 */
export interface FoldersApiDeleteFolderObjectRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiDeleteFolderObject
     */
    readonly folderId: string

    /**
     * 
     * @type {string}
     * @memberof FoldersApiDeleteFolderObject
     */
    readonly objectKey: string
}

/**
 * Request parameters for enqueueFolderOperation operation in FoldersApi.
 * @export
 * @interface FoldersApiEnqueueFolderOperationRequest
 */
export interface FoldersApiEnqueueFolderOperationRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiEnqueueFolderOperation
     */
    readonly folderId: string

    /**
     * 
     * @type {FolderOperationRequestPayload}
     * @memberof FoldersApiEnqueueFolderOperation
     */
    readonly folderOperationRequestPayload: FolderOperationRequestPayload
}

/**
 * Request parameters for getFolder operation in FoldersApi.
 * @export
 * @interface FoldersApiGetFolderRequest
 */
export interface FoldersApiGetFolderRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiGetFolder
     */
    readonly folderId: string
}

/**
 * Request parameters for getFolderMetadata operation in FoldersApi.
 * @export
 * @interface FoldersApiGetFolderMetadataRequest
 */
export interface FoldersApiGetFolderMetadataRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiGetFolderMetadata
     */
    readonly folderId: string
}

/**
 * Request parameters for getFolderObject operation in FoldersApi.
 * @export
 * @interface FoldersApiGetFolderObjectRequest
 */
export interface FoldersApiGetFolderObjectRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiGetFolderObject
     */
    readonly folderId: string

    /**
     * 
     * @type {string}
     * @memberof FoldersApiGetFolderObject
     */
    readonly objectKey: string
}

/**
 * Request parameters for indexAllContent operation in FoldersApi.
 * @export
 * @interface FoldersApiIndexAllContentRequest
 */
export interface FoldersApiIndexAllContentRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiIndexAllContent
     */
    readonly folderId: string
}

/**
 * Request parameters for listFolderObjects operation in FoldersApi.
 * @export
 * @interface FoldersApiListFolderObjectsRequest
 */
export interface FoldersApiListFolderObjectsRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiListFolderObjects
     */
    readonly folderId: string

    /**
     * 
     * @type {string}
     * @memberof FoldersApiListFolderObjects
     */
    readonly search?: string

    /**
     * 
     * @type {number}
     * @memberof FoldersApiListFolderObjects
     */
    readonly offset?: number

    /**
     * 
     * @type {number}
     * @memberof FoldersApiListFolderObjects
     */
    readonly limit?: number
}

/**
 * Request parameters for listFolderOperations operation in FoldersApi.
 * @export
 * @interface FoldersApiListFolderOperationsRequest
 */
export interface FoldersApiListFolderOperationsRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiListFolderOperations
     */
    readonly folderId: string

    /**
     * 
     * @type {FolderOperationSort}
     * @memberof FoldersApiListFolderOperations
     */
    readonly sort?: FolderOperationSort

    /**
     * 
     * @type {FolderOperationStatus}
     * @memberof FoldersApiListFolderOperations
     */
    readonly status?: FolderOperationStatus

    /**
     * 
     * @type {number}
     * @memberof FoldersApiListFolderOperations
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof FoldersApiListFolderOperations
     */
    readonly offset?: number
}

/**
 * Request parameters for refreshFolder operation in FoldersApi.
 * @export
 * @interface FoldersApiRefreshFolderRequest
 */
export interface FoldersApiRefreshFolderRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiRefreshFolder
     */
    readonly folderId: string
}

/**
 * Request parameters for refreshFolderObjectS3Metadata operation in FoldersApi.
 * @export
 * @interface FoldersApiRefreshFolderObjectS3MetadataRequest
 */
export interface FoldersApiRefreshFolderObjectS3MetadataRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiRefreshFolderObjectS3Metadata
     */
    readonly folderId: string

    /**
     * 
     * @type {string}
     * @memberof FoldersApiRefreshFolderObjectS3Metadata
     */
    readonly objectKey: string

    /**
     * 
     * @type {RefreshFolderObjectS3MetadataRequest}
     * @memberof FoldersApiRefreshFolderObjectS3Metadata
     */
    readonly refreshFolderObjectS3MetadataRequest: RefreshFolderObjectS3MetadataRequest
}

/**
 * FoldersApi - object-oriented interface
 * @export
 * @class FoldersApi
 * @extends {BaseAPI}
 */
export class FoldersApi extends BaseAPI {
    /**
     * 
     * @param {FoldersApiCreateFolderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public createFolder(requestParameters: FoldersApiCreateFolderRequest, options?: AxiosRequestConfig) {
        return FoldersApiFp(this.configuration).createFolder(requestParameters.createFolderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FoldersApiCreatePresignedUrlsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public createPresignedUrls(requestParameters: FoldersApiCreatePresignedUrlsRequest, options?: AxiosRequestConfig) {
        return FoldersApiFp(this.configuration).createPresignedUrls(requestParameters.folderId, requestParameters.signedURLsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FoldersApiCreateSocketAuthenticationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public createSocketAuthentication(requestParameters: FoldersApiCreateSocketAuthenticationRequest, options?: AxiosRequestConfig) {
        return FoldersApiFp(this.configuration).createSocketAuthentication(requestParameters.folderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FoldersApiDeleteFolderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public deleteFolder(requestParameters: FoldersApiDeleteFolderRequest, options?: AxiosRequestConfig) {
        return FoldersApiFp(this.configuration).deleteFolder(requestParameters.folderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FoldersApiDeleteFolderObjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public deleteFolderObject(requestParameters: FoldersApiDeleteFolderObjectRequest, options?: AxiosRequestConfig) {
        return FoldersApiFp(this.configuration).deleteFolderObject(requestParameters.folderId, requestParameters.objectKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FoldersApiEnqueueFolderOperationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public enqueueFolderOperation(requestParameters: FoldersApiEnqueueFolderOperationRequest, options?: AxiosRequestConfig) {
        return FoldersApiFp(this.configuration).enqueueFolderOperation(requestParameters.folderId, requestParameters.folderOperationRequestPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FoldersApiGetFolderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public getFolder(requestParameters: FoldersApiGetFolderRequest, options?: AxiosRequestConfig) {
        return FoldersApiFp(this.configuration).getFolder(requestParameters.folderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FoldersApiGetFolderMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public getFolderMetadata(requestParameters: FoldersApiGetFolderMetadataRequest, options?: AxiosRequestConfig) {
        return FoldersApiFp(this.configuration).getFolderMetadata(requestParameters.folderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FoldersApiGetFolderObjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public getFolderObject(requestParameters: FoldersApiGetFolderObjectRequest, options?: AxiosRequestConfig) {
        return FoldersApiFp(this.configuration).getFolderObject(requestParameters.folderId, requestParameters.objectKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FoldersApiIndexAllContentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public indexAllContent(requestParameters: FoldersApiIndexAllContentRequest, options?: AxiosRequestConfig) {
        return FoldersApiFp(this.configuration).indexAllContent(requestParameters.folderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FoldersApiListFolderObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public listFolderObjects(requestParameters: FoldersApiListFolderObjectsRequest, options?: AxiosRequestConfig) {
        return FoldersApiFp(this.configuration).listFolderObjects(requestParameters.folderId, requestParameters.search, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FoldersApiListFolderOperationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public listFolderOperations(requestParameters: FoldersApiListFolderOperationsRequest, options?: AxiosRequestConfig) {
        return FoldersApiFp(this.configuration).listFolderOperations(requestParameters.folderId, requestParameters.sort, requestParameters.status, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public listFolders(options?: AxiosRequestConfig) {
        return FoldersApiFp(this.configuration).listFolders(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FoldersApiRefreshFolderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public refreshFolder(requestParameters: FoldersApiRefreshFolderRequest, options?: AxiosRequestConfig) {
        return FoldersApiFp(this.configuration).refreshFolder(requestParameters.folderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FoldersApiRefreshFolderObjectS3MetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public refreshFolderObjectS3Metadata(requestParameters: FoldersApiRefreshFolderObjectS3MetadataRequest, options?: AxiosRequestConfig) {
        return FoldersApiFp(this.configuration).refreshFolderObjectS3Metadata(requestParameters.folderId, requestParameters.objectKey, requestParameters.refreshFolderObjectS3MetadataRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ServerApi - axios parameter creator
 * @export
 */
export const ServerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ServerLocationType} locationType 
         * @param {ServerLocationInputData} serverLocationInputData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addServerLocation: async (locationType: ServerLocationType, serverLocationInputData: ServerLocationInputData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationType' is not null or undefined
            assertParamExists('addServerLocation', 'locationType', locationType)
            // verify required parameter 'serverLocationInputData' is not null or undefined
            assertParamExists('addServerLocation', 'serverLocationInputData', serverLocationInputData)
            const localVarPath = `/server/settings/locations/{locationType}`
                .replace(`{${"locationType"}}`, encodeURIComponent(String(locationType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serverLocationInputData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServerWorkerKey: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server/worker-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateUserData} createUserData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (createUserData: CreateUserData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserData' is not null or undefined
            assertParamExists('createUser', 'createUserData', createUserData)
            const localVarPath = `/server/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ServerLocationType} locationType 
         * @param {string} locationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteServerLocation: async (locationType: ServerLocationType, locationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationType' is not null or undefined
            assertParamExists('deleteServerLocation', 'locationType', locationType)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('deleteServerLocation', 'locationId', locationId)
            const localVarPath = `/server/settings/locations/{locationType}/{locationId}`
                .replace(`{${"locationType"}}`, encodeURIComponent(String(locationType)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workerKeyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteServerWorkerKey: async (workerKeyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workerKeyId' is not null or undefined
            assertParamExists('deleteServerWorkerKey', 'workerKeyId', workerKeyId)
            const localVarPath = `/server/worker-keys/{workerKeyId}`
                .replace(`{${"workerKeyId"}}`, encodeURIComponent(String(workerKeyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUser', 'userId', userId)
            const localVarPath = `/server/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettings: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUser', 'userId', userId)
            const localVarPath = `/server/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ServerLocationType} locationType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServerLocations: async (locationType: ServerLocationType, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationType' is not null or undefined
            assertParamExists('listServerLocations', 'locationType', locationType)
            const localVarPath = `/server/settings/server-locations/{locationType}`
                .replace(`{${"locationType"}}`, encodeURIComponent(String(locationType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FolderWorkerKeySort} [sort] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServerWorkerKeys: async (sort?: FolderWorkerKeySort, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server/worker-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FolderWorkerSort} [sort] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServerWorkers: async (sort?: FolderWorkerSort, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server/workers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} settingsKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetSetting: async (settingsKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'settingsKey' is not null or undefined
            assertParamExists('resetSetting', 'settingsKey', settingsKey)
            const localVarPath = `/server/settings/{settingsKey}`
                .replace(`{${"settingsKey"}}`, encodeURIComponent(String(settingsKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} settingsKey 
         * @param {UpdateSettingRequest} updateSettingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSetting: async (settingsKey: string, updateSettingRequest: UpdateSettingRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'settingsKey' is not null or undefined
            assertParamExists('updateSetting', 'settingsKey', settingsKey)
            // verify required parameter 'updateSettingRequest' is not null or undefined
            assertParamExists('updateSetting', 'updateSettingRequest', updateSettingRequest)
            const localVarPath = `/server/settings/{settingsKey}`
                .replace(`{${"settingsKey"}}`, encodeURIComponent(String(settingsKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSettingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {UpdateUserData} updateUserData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (userId: string, updateUserData: UpdateUserData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUser', 'userId', userId)
            // verify required parameter 'updateUserData' is not null or undefined
            assertParamExists('updateUser', 'updateUserData', updateUserData)
            const localVarPath = `/server/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServerApi - functional programming interface
 * @export
 */
export const ServerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ServerLocationType} locationType 
         * @param {ServerLocationInputData} serverLocationInputData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addServerLocation(locationType: ServerLocationType, serverLocationInputData: ServerLocationInputData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerLocationData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addServerLocation(locationType, serverLocationInputData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createServerWorkerKey(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateServerWorkerKey200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createServerWorkerKey(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CreateUserData} createUserData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(createUserData: CreateUserData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Signup201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(createUserData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ServerLocationType} locationType 
         * @param {string} locationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteServerLocation(locationType: ServerLocationType, locationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteServerLocation(locationType, locationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} workerKeyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteServerWorkerKey(workerKeyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteFolder200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteServerWorkerKey(workerKeyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSettings(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSettings200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSettings(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ServerLocationType} locationType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listServerLocations(locationType: ServerLocationType, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServerLocationData>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listServerLocations(locationType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {FolderWorkerKeySort} [sort] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listServerWorkerKeys(sort?: FolderWorkerKeySort, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListServerWorkerKeys200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listServerWorkerKeys(sort, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {FolderWorkerSort} [sort] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listServerWorkers(sort?: FolderWorkerSort, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListServerWorkers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listServerWorkers(sort, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsers(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListUsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} settingsKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetSetting(settingsKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSettings200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetSetting(settingsKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} settingsKey 
         * @param {UpdateSettingRequest} updateSettingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSetting(settingsKey: string, updateSettingRequest: UpdateSettingRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSettings200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSetting(settingsKey, updateSettingRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} userId 
         * @param {UpdateUserData} updateUserData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(userId: string, updateUserData: UpdateUserData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Signup201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(userId, updateUserData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServerApi - factory interface
 * @export
 */
export const ServerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServerApiFp(configuration)
    return {
        /**
         * 
         * @param {ServerApiAddServerLocationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addServerLocation(requestParameters: ServerApiAddServerLocationRequest, options?: AxiosRequestConfig): AxiosPromise<ServerLocationData> {
            return localVarFp.addServerLocation(requestParameters.locationType, requestParameters.serverLocationInputData, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServerWorkerKey(options?: AxiosRequestConfig): AxiosPromise<CreateServerWorkerKey200Response> {
            return localVarFp.createServerWorkerKey(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ServerApiCreateUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(requestParameters: ServerApiCreateUserRequest, options?: AxiosRequestConfig): AxiosPromise<Signup201Response> {
            return localVarFp.createUser(requestParameters.createUserData, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ServerApiDeleteServerLocationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteServerLocation(requestParameters: ServerApiDeleteServerLocationRequest, options?: AxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.deleteServerLocation(requestParameters.locationType, requestParameters.locationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ServerApiDeleteServerWorkerKeyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteServerWorkerKey(requestParameters: ServerApiDeleteServerWorkerKeyRequest, options?: AxiosRequestConfig): AxiosPromise<DeleteFolder200Response> {
            return localVarFp.deleteServerWorkerKey(requestParameters.workerKeyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ServerApiDeleteUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(requestParameters: ServerApiDeleteUserRequest, options?: AxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.deleteUser(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettings(options?: AxiosRequestConfig): AxiosPromise<GetSettings200Response> {
            return localVarFp.getSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ServerApiGetUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(requestParameters: ServerApiGetUserRequest, options?: AxiosRequestConfig): AxiosPromise<GetUser200Response> {
            return localVarFp.getUser(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ServerApiListServerLocationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServerLocations(requestParameters: ServerApiListServerLocationsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ServerLocationData>> {
            return localVarFp.listServerLocations(requestParameters.locationType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ServerApiListServerWorkerKeysRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServerWorkerKeys(requestParameters: ServerApiListServerWorkerKeysRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ListServerWorkerKeys200Response> {
            return localVarFp.listServerWorkerKeys(requestParameters.sort, requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ServerApiListServerWorkersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServerWorkers(requestParameters: ServerApiListServerWorkersRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ListServerWorkers200Response> {
            return localVarFp.listServerWorkers(requestParameters.sort, requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(options?: AxiosRequestConfig): AxiosPromise<ListUsersResponse> {
            return localVarFp.listUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ServerApiResetSettingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetSetting(requestParameters: ServerApiResetSettingRequest, options?: AxiosRequestConfig): AxiosPromise<GetSettings200Response> {
            return localVarFp.resetSetting(requestParameters.settingsKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ServerApiUpdateSettingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSetting(requestParameters: ServerApiUpdateSettingRequest, options?: AxiosRequestConfig): AxiosPromise<GetSettings200Response> {
            return localVarFp.updateSetting(requestParameters.settingsKey, requestParameters.updateSettingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ServerApiUpdateUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(requestParameters: ServerApiUpdateUserRequest, options?: AxiosRequestConfig): AxiosPromise<Signup201Response> {
            return localVarFp.updateUser(requestParameters.userId, requestParameters.updateUserData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addServerLocation operation in ServerApi.
 * @export
 * @interface ServerApiAddServerLocationRequest
 */
export interface ServerApiAddServerLocationRequest {
    /**
     * 
     * @type {ServerLocationType}
     * @memberof ServerApiAddServerLocation
     */
    readonly locationType: ServerLocationType

    /**
     * 
     * @type {ServerLocationInputData}
     * @memberof ServerApiAddServerLocation
     */
    readonly serverLocationInputData: ServerLocationInputData
}

/**
 * Request parameters for createUser operation in ServerApi.
 * @export
 * @interface ServerApiCreateUserRequest
 */
export interface ServerApiCreateUserRequest {
    /**
     * 
     * @type {CreateUserData}
     * @memberof ServerApiCreateUser
     */
    readonly createUserData: CreateUserData
}

/**
 * Request parameters for deleteServerLocation operation in ServerApi.
 * @export
 * @interface ServerApiDeleteServerLocationRequest
 */
export interface ServerApiDeleteServerLocationRequest {
    /**
     * 
     * @type {ServerLocationType}
     * @memberof ServerApiDeleteServerLocation
     */
    readonly locationType: ServerLocationType

    /**
     * 
     * @type {string}
     * @memberof ServerApiDeleteServerLocation
     */
    readonly locationId: string
}

/**
 * Request parameters for deleteServerWorkerKey operation in ServerApi.
 * @export
 * @interface ServerApiDeleteServerWorkerKeyRequest
 */
export interface ServerApiDeleteServerWorkerKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof ServerApiDeleteServerWorkerKey
     */
    readonly workerKeyId: string
}

/**
 * Request parameters for deleteUser operation in ServerApi.
 * @export
 * @interface ServerApiDeleteUserRequest
 */
export interface ServerApiDeleteUserRequest {
    /**
     * 
     * @type {string}
     * @memberof ServerApiDeleteUser
     */
    readonly userId: string
}

/**
 * Request parameters for getUser operation in ServerApi.
 * @export
 * @interface ServerApiGetUserRequest
 */
export interface ServerApiGetUserRequest {
    /**
     * 
     * @type {string}
     * @memberof ServerApiGetUser
     */
    readonly userId: string
}

/**
 * Request parameters for listServerLocations operation in ServerApi.
 * @export
 * @interface ServerApiListServerLocationsRequest
 */
export interface ServerApiListServerLocationsRequest {
    /**
     * 
     * @type {ServerLocationType}
     * @memberof ServerApiListServerLocations
     */
    readonly locationType: ServerLocationType
}

/**
 * Request parameters for listServerWorkerKeys operation in ServerApi.
 * @export
 * @interface ServerApiListServerWorkerKeysRequest
 */
export interface ServerApiListServerWorkerKeysRequest {
    /**
     * 
     * @type {FolderWorkerKeySort}
     * @memberof ServerApiListServerWorkerKeys
     */
    readonly sort?: FolderWorkerKeySort

    /**
     * 
     * @type {number}
     * @memberof ServerApiListServerWorkerKeys
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof ServerApiListServerWorkerKeys
     */
    readonly offset?: number
}

/**
 * Request parameters for listServerWorkers operation in ServerApi.
 * @export
 * @interface ServerApiListServerWorkersRequest
 */
export interface ServerApiListServerWorkersRequest {
    /**
     * 
     * @type {FolderWorkerSort}
     * @memberof ServerApiListServerWorkers
     */
    readonly sort?: FolderWorkerSort

    /**
     * 
     * @type {number}
     * @memberof ServerApiListServerWorkers
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof ServerApiListServerWorkers
     */
    readonly offset?: number
}

/**
 * Request parameters for resetSetting operation in ServerApi.
 * @export
 * @interface ServerApiResetSettingRequest
 */
export interface ServerApiResetSettingRequest {
    /**
     * 
     * @type {string}
     * @memberof ServerApiResetSetting
     */
    readonly settingsKey: string
}

/**
 * Request parameters for updateSetting operation in ServerApi.
 * @export
 * @interface ServerApiUpdateSettingRequest
 */
export interface ServerApiUpdateSettingRequest {
    /**
     * 
     * @type {string}
     * @memberof ServerApiUpdateSetting
     */
    readonly settingsKey: string

    /**
     * 
     * @type {UpdateSettingRequest}
     * @memberof ServerApiUpdateSetting
     */
    readonly updateSettingRequest: UpdateSettingRequest
}

/**
 * Request parameters for updateUser operation in ServerApi.
 * @export
 * @interface ServerApiUpdateUserRequest
 */
export interface ServerApiUpdateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof ServerApiUpdateUser
     */
    readonly userId: string

    /**
     * 
     * @type {UpdateUserData}
     * @memberof ServerApiUpdateUser
     */
    readonly updateUserData: UpdateUserData
}

/**
 * ServerApi - object-oriented interface
 * @export
 * @class ServerApi
 * @extends {BaseAPI}
 */
export class ServerApi extends BaseAPI {
    /**
     * 
     * @param {ServerApiAddServerLocationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public addServerLocation(requestParameters: ServerApiAddServerLocationRequest, options?: AxiosRequestConfig) {
        return ServerApiFp(this.configuration).addServerLocation(requestParameters.locationType, requestParameters.serverLocationInputData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public createServerWorkerKey(options?: AxiosRequestConfig) {
        return ServerApiFp(this.configuration).createServerWorkerKey(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ServerApiCreateUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public createUser(requestParameters: ServerApiCreateUserRequest, options?: AxiosRequestConfig) {
        return ServerApiFp(this.configuration).createUser(requestParameters.createUserData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ServerApiDeleteServerLocationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public deleteServerLocation(requestParameters: ServerApiDeleteServerLocationRequest, options?: AxiosRequestConfig) {
        return ServerApiFp(this.configuration).deleteServerLocation(requestParameters.locationType, requestParameters.locationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ServerApiDeleteServerWorkerKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public deleteServerWorkerKey(requestParameters: ServerApiDeleteServerWorkerKeyRequest, options?: AxiosRequestConfig) {
        return ServerApiFp(this.configuration).deleteServerWorkerKey(requestParameters.workerKeyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ServerApiDeleteUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public deleteUser(requestParameters: ServerApiDeleteUserRequest, options?: AxiosRequestConfig) {
        return ServerApiFp(this.configuration).deleteUser(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public getSettings(options?: AxiosRequestConfig) {
        return ServerApiFp(this.configuration).getSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ServerApiGetUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public getUser(requestParameters: ServerApiGetUserRequest, options?: AxiosRequestConfig) {
        return ServerApiFp(this.configuration).getUser(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ServerApiListServerLocationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public listServerLocations(requestParameters: ServerApiListServerLocationsRequest, options?: AxiosRequestConfig) {
        return ServerApiFp(this.configuration).listServerLocations(requestParameters.locationType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ServerApiListServerWorkerKeysRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public listServerWorkerKeys(requestParameters: ServerApiListServerWorkerKeysRequest = {}, options?: AxiosRequestConfig) {
        return ServerApiFp(this.configuration).listServerWorkerKeys(requestParameters.sort, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ServerApiListServerWorkersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public listServerWorkers(requestParameters: ServerApiListServerWorkersRequest = {}, options?: AxiosRequestConfig) {
        return ServerApiFp(this.configuration).listServerWorkers(requestParameters.sort, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public listUsers(options?: AxiosRequestConfig) {
        return ServerApiFp(this.configuration).listUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ServerApiResetSettingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public resetSetting(requestParameters: ServerApiResetSettingRequest, options?: AxiosRequestConfig) {
        return ServerApiFp(this.configuration).resetSetting(requestParameters.settingsKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ServerApiUpdateSettingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public updateSetting(requestParameters: ServerApiUpdateSettingRequest, options?: AxiosRequestConfig) {
        return ServerApiFp(this.configuration).updateSetting(requestParameters.settingsKey, requestParameters.updateSettingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ServerApiUpdateUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public updateUser(requestParameters: ServerApiUpdateUserRequest, options?: AxiosRequestConfig) {
        return ServerApiFp(this.configuration).updateUser(requestParameters.userId, requestParameters.updateUserData, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ViewerApi - axios parameter creator
 * @export
 */
export const ViewerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getViewer: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/viewer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ViewerUpdatePayload} viewerUpdatePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateViewer: async (viewerUpdatePayload: ViewerUpdatePayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'viewerUpdatePayload' is not null or undefined
            assertParamExists('updateViewer', 'viewerUpdatePayload', viewerUpdatePayload)
            const localVarPath = `/viewer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(viewerUpdatePayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ViewerApi - functional programming interface
 * @export
 */
export const ViewerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ViewerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getViewer(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Signup201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getViewer(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ViewerUpdatePayload} viewerUpdatePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateViewer(viewerUpdatePayload: ViewerUpdatePayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Signup201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateViewer(viewerUpdatePayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ViewerApi - factory interface
 * @export
 */
export const ViewerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ViewerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getViewer(options?: AxiosRequestConfig): AxiosPromise<Signup201Response> {
            return localVarFp.getViewer(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ViewerApiUpdateViewerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateViewer(requestParameters: ViewerApiUpdateViewerRequest, options?: AxiosRequestConfig): AxiosPromise<Signup201Response> {
            return localVarFp.updateViewer(requestParameters.viewerUpdatePayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for updateViewer operation in ViewerApi.
 * @export
 * @interface ViewerApiUpdateViewerRequest
 */
export interface ViewerApiUpdateViewerRequest {
    /**
     * 
     * @type {ViewerUpdatePayload}
     * @memberof ViewerApiUpdateViewer
     */
    readonly viewerUpdatePayload: ViewerUpdatePayload
}

/**
 * ViewerApi - object-oriented interface
 * @export
 * @class ViewerApi
 * @extends {BaseAPI}
 */
export class ViewerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewerApi
     */
    public getViewer(options?: AxiosRequestConfig) {
        return ViewerApiFp(this.configuration).getViewer(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ViewerApiUpdateViewerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewerApi
     */
    public updateViewer(requestParameters: ViewerApiUpdateViewerRequest, options?: AxiosRequestConfig) {
        return ViewerApiFp(this.configuration).updateViewer(requestParameters.viewerUpdatePayload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorkerApi - axios parameter creator
 * @export
 */
export const WorkerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} operationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeJob: async (operationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'operationId' is not null or undefined
            assertParamExists('completeJob', 'operationId', operationId)
            const localVarPath = `/worker/{operationId}/complete`
                .replace(`{${"operationId"}}`, encodeURIComponent(String(operationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication WorkerAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} operationId 
         * @param {CreateMetadataUploadUrlsPayload} createMetadataUploadUrlsPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMetadataUploadUrls: async (operationId: string, createMetadataUploadUrlsPayload: CreateMetadataUploadUrlsPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'operationId' is not null or undefined
            assertParamExists('createMetadataUploadUrls', 'operationId', operationId)
            // verify required parameter 'createMetadataUploadUrlsPayload' is not null or undefined
            assertParamExists('createMetadataUploadUrls', 'createMetadataUploadUrlsPayload', createMetadataUploadUrlsPayload)
            const localVarPath = `/worker/{operationId}/metadata-upload-urls`
                .replace(`{${"operationId"}}`, encodeURIComponent(String(operationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication WorkerAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMetadataUploadUrlsPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} operationId 
         * @param {CreateOutputUploadUrlsPayload} createOutputUploadUrlsPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOutputUploadUrls: async (operationId: string, createOutputUploadUrlsPayload: CreateOutputUploadUrlsPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'operationId' is not null or undefined
            assertParamExists('createOutputUploadUrls', 'operationId', operationId)
            // verify required parameter 'createOutputUploadUrlsPayload' is not null or undefined
            assertParamExists('createOutputUploadUrls', 'createOutputUploadUrlsPayload', createOutputUploadUrlsPayload)
            const localVarPath = `/worker/{operationId}/output-upload-urls`
                .replace(`{${"operationId"}}`, encodeURIComponent(String(operationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication WorkerAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOutputUploadUrlsPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSocketAuthentication: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/worker/socket`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication WorkerAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} operationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startJob: async (operationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'operationId' is not null or undefined
            assertParamExists('startJob', 'operationId', operationId)
            const localVarPath = `/worker/{operationId}/start`
                .replace(`{${"operationId"}}`, encodeURIComponent(String(operationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication WorkerAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<ContentAttibutesPayload>} contentAttibutesPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContentAttributes: async (contentAttibutesPayload: Array<ContentAttibutesPayload>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentAttibutesPayload' is not null or undefined
            assertParamExists('updateContentAttributes', 'contentAttibutesPayload', contentAttibutesPayload)
            const localVarPath = `/worker/content-attributes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication WorkerAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contentAttibutesPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<ContentMetadataPayload>} contentMetadataPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContentMetadata: async (contentMetadataPayload: Array<ContentMetadataPayload>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentMetadataPayload' is not null or undefined
            assertParamExists('updateContentMetadata', 'contentMetadataPayload', contentMetadataPayload)
            const localVarPath = `/worker/content-metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication WorkerAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contentMetadataPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkerApi - functional programming interface
 * @export
 */
export const WorkerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} operationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeJob(operationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeJob(operationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} operationId 
         * @param {CreateMetadataUploadUrlsPayload} createMetadataUploadUrlsPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMetadataUploadUrls(operationId: string, createMetadataUploadUrlsPayload: CreateMetadataUploadUrlsPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMetadataUploadUrls200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMetadataUploadUrls(operationId, createMetadataUploadUrlsPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} operationId 
         * @param {CreateOutputUploadUrlsPayload} createOutputUploadUrlsPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOutputUploadUrls(operationId: string, createOutputUploadUrlsPayload: CreateOutputUploadUrlsPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOutputUploadUrls200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOutputUploadUrls(operationId, createOutputUploadUrlsPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSocketAuthentication(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateSocketAuthentication200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSocketAuthentication(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} operationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startJob(operationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StartJob200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startJob(operationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<ContentAttibutesPayload>} contentAttibutesPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateContentAttributes(contentAttibutesPayload: Array<ContentAttibutesPayload>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateContentAttributes(contentAttibutesPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<ContentMetadataPayload>} contentMetadataPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateContentMetadata(contentMetadataPayload: Array<ContentMetadataPayload>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateContentMetadata(contentMetadataPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WorkerApi - factory interface
 * @export
 */
export const WorkerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkerApiFp(configuration)
    return {
        /**
         * 
         * @param {WorkerApiCompleteJobRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeJob(requestParameters: WorkerApiCompleteJobRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.completeJob(requestParameters.operationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WorkerApiCreateMetadataUploadUrlsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMetadataUploadUrls(requestParameters: WorkerApiCreateMetadataUploadUrlsRequest, options?: AxiosRequestConfig): AxiosPromise<CreateMetadataUploadUrls200Response> {
            return localVarFp.createMetadataUploadUrls(requestParameters.operationId, requestParameters.createMetadataUploadUrlsPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WorkerApiCreateOutputUploadUrlsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOutputUploadUrls(requestParameters: WorkerApiCreateOutputUploadUrlsRequest, options?: AxiosRequestConfig): AxiosPromise<CreateOutputUploadUrls200Response> {
            return localVarFp.createOutputUploadUrls(requestParameters.operationId, requestParameters.createOutputUploadUrlsPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSocketAuthentication(options?: AxiosRequestConfig): AxiosPromise<CreateSocketAuthentication200Response> {
            return localVarFp.createSocketAuthentication(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WorkerApiStartJobRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startJob(requestParameters: WorkerApiStartJobRequest, options?: AxiosRequestConfig): AxiosPromise<Array<StartJob200ResponseInner>> {
            return localVarFp.startJob(requestParameters.operationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WorkerApiUpdateContentAttributesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContentAttributes(requestParameters: WorkerApiUpdateContentAttributesRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateContentAttributes(requestParameters.contentAttibutesPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WorkerApiUpdateContentMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContentMetadata(requestParameters: WorkerApiUpdateContentMetadataRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateContentMetadata(requestParameters.contentMetadataPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for completeJob operation in WorkerApi.
 * @export
 * @interface WorkerApiCompleteJobRequest
 */
export interface WorkerApiCompleteJobRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkerApiCompleteJob
     */
    readonly operationId: string
}

/**
 * Request parameters for createMetadataUploadUrls operation in WorkerApi.
 * @export
 * @interface WorkerApiCreateMetadataUploadUrlsRequest
 */
export interface WorkerApiCreateMetadataUploadUrlsRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkerApiCreateMetadataUploadUrls
     */
    readonly operationId: string

    /**
     * 
     * @type {CreateMetadataUploadUrlsPayload}
     * @memberof WorkerApiCreateMetadataUploadUrls
     */
    readonly createMetadataUploadUrlsPayload: CreateMetadataUploadUrlsPayload
}

/**
 * Request parameters for createOutputUploadUrls operation in WorkerApi.
 * @export
 * @interface WorkerApiCreateOutputUploadUrlsRequest
 */
export interface WorkerApiCreateOutputUploadUrlsRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkerApiCreateOutputUploadUrls
     */
    readonly operationId: string

    /**
     * 
     * @type {CreateOutputUploadUrlsPayload}
     * @memberof WorkerApiCreateOutputUploadUrls
     */
    readonly createOutputUploadUrlsPayload: CreateOutputUploadUrlsPayload
}

/**
 * Request parameters for startJob operation in WorkerApi.
 * @export
 * @interface WorkerApiStartJobRequest
 */
export interface WorkerApiStartJobRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkerApiStartJob
     */
    readonly operationId: string
}

/**
 * Request parameters for updateContentAttributes operation in WorkerApi.
 * @export
 * @interface WorkerApiUpdateContentAttributesRequest
 */
export interface WorkerApiUpdateContentAttributesRequest {
    /**
     * 
     * @type {Array<ContentAttibutesPayload>}
     * @memberof WorkerApiUpdateContentAttributes
     */
    readonly contentAttibutesPayload: Array<ContentAttibutesPayload>
}

/**
 * Request parameters for updateContentMetadata operation in WorkerApi.
 * @export
 * @interface WorkerApiUpdateContentMetadataRequest
 */
export interface WorkerApiUpdateContentMetadataRequest {
    /**
     * 
     * @type {Array<ContentMetadataPayload>}
     * @memberof WorkerApiUpdateContentMetadata
     */
    readonly contentMetadataPayload: Array<ContentMetadataPayload>
}

/**
 * WorkerApi - object-oriented interface
 * @export
 * @class WorkerApi
 * @extends {BaseAPI}
 */
export class WorkerApi extends BaseAPI {
    /**
     * 
     * @param {WorkerApiCompleteJobRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkerApi
     */
    public completeJob(requestParameters: WorkerApiCompleteJobRequest, options?: AxiosRequestConfig) {
        return WorkerApiFp(this.configuration).completeJob(requestParameters.operationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {WorkerApiCreateMetadataUploadUrlsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkerApi
     */
    public createMetadataUploadUrls(requestParameters: WorkerApiCreateMetadataUploadUrlsRequest, options?: AxiosRequestConfig) {
        return WorkerApiFp(this.configuration).createMetadataUploadUrls(requestParameters.operationId, requestParameters.createMetadataUploadUrlsPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {WorkerApiCreateOutputUploadUrlsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkerApi
     */
    public createOutputUploadUrls(requestParameters: WorkerApiCreateOutputUploadUrlsRequest, options?: AxiosRequestConfig) {
        return WorkerApiFp(this.configuration).createOutputUploadUrls(requestParameters.operationId, requestParameters.createOutputUploadUrlsPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkerApi
     */
    public createSocketAuthentication(options?: AxiosRequestConfig) {
        return WorkerApiFp(this.configuration).createSocketAuthentication(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {WorkerApiStartJobRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkerApi
     */
    public startJob(requestParameters: WorkerApiStartJobRequest, options?: AxiosRequestConfig) {
        return WorkerApiFp(this.configuration).startJob(requestParameters.operationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {WorkerApiUpdateContentAttributesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkerApi
     */
    public updateContentAttributes(requestParameters: WorkerApiUpdateContentAttributesRequest, options?: AxiosRequestConfig) {
        return WorkerApiFp(this.configuration).updateContentAttributes(requestParameters.contentAttibutesPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {WorkerApiUpdateContentMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkerApi
     */
    public updateContentMetadata(requestParameters: WorkerApiUpdateContentMetadataRequest, options?: AxiosRequestConfig) {
        return WorkerApiFp(this.configuration).updateContentMetadata(requestParameters.contentMetadataPayload, options).then((request) => request(this.axios, this.basePath));
    }
}



