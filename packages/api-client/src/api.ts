/* tslint:disable */
/* eslint-disable */
/**
 * @stellariscloud/api
 * The Stellaris Cloud core API
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AccessKeyBucketsListResponseDTO
 */
export interface AccessKeyBucketsListResponseDTO {
    /**
     * 
     * @type {Array<AccessKeyBucketsListResponseDTOResultInner>}
     * @memberof AccessKeyBucketsListResponseDTO
     */
    'result': Array<AccessKeyBucketsListResponseDTOResultInner>;
}
/**
 * 
 * @export
 * @interface AccessKeyBucketsListResponseDTOResultInner
 */
export interface AccessKeyBucketsListResponseDTOResultInner {
    /**
     * 
     * @type {string}
     * @memberof AccessKeyBucketsListResponseDTOResultInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AccessKeyBucketsListResponseDTOResultInner
     */
    'createdDate'?: string;
}
/**
 * 
 * @export
 * @interface AccessKeyGetResponse
 */
export interface AccessKeyGetResponse {
    /**
     * 
     * @type {AccessKeyListResponseResultInner}
     * @memberof AccessKeyGetResponse
     */
    'accessKey': AccessKeyListResponseResultInner;
}
/**
 * 
 * @export
 * @interface AccessKeyListResponse
 */
export interface AccessKeyListResponse {
    /**
     * 
     * @type {UserListResponseMeta}
     * @memberof AccessKeyListResponse
     */
    'meta': UserListResponseMeta;
    /**
     * 
     * @type {Array<AccessKeyListResponseResultInner>}
     * @memberof AccessKeyListResponse
     */
    'result': Array<AccessKeyListResponseResultInner>;
}
/**
 * 
 * @export
 * @interface AccessKeyListResponseResultInner
 */
export interface AccessKeyListResponseResultInner {
    /**
     * 
     * @type {string}
     * @memberof AccessKeyListResponseResultInner
     */
    'accessKeyId': string;
    /**
     * 
     * @type {string}
     * @memberof AccessKeyListResponseResultInner
     */
    'accessKeyHashId': string;
    /**
     * 
     * @type {string}
     * @memberof AccessKeyListResponseResultInner
     */
    'endpoint': string;
    /**
     * 
     * @type {string}
     * @memberof AccessKeyListResponseResultInner
     */
    'endpointDomain': string;
    /**
     * 
     * @type {string}
     * @memberof AccessKeyListResponseResultInner
     */
    'region': string;
    /**
     * 
     * @type {number}
     * @memberof AccessKeyListResponseResultInner
     */
    'folderCount': number;
}
/**
 * 
 * @export
 * @interface AccessKeyPublicDTO
 */
export interface AccessKeyPublicDTO {
    /**
     * 
     * @type {string}
     * @memberof AccessKeyPublicDTO
     */
    'accessKeyId': string;
    /**
     * 
     * @type {string}
     * @memberof AccessKeyPublicDTO
     */
    'accessKeyHashId': string;
    /**
     * 
     * @type {string}
     * @memberof AccessKeyPublicDTO
     */
    'endpoint': string;
    /**
     * 
     * @type {string}
     * @memberof AccessKeyPublicDTO
     */
    'endpointDomain': string;
    /**
     * 
     * @type {string}
     * @memberof AccessKeyPublicDTO
     */
    'region': string;
    /**
     * 
     * @type {number}
     * @memberof AccessKeyPublicDTO
     */
    'folderCount': number;
}
/**
 * 
 * @export
 * @interface AccessKeyRotateResponse
 */
export interface AccessKeyRotateResponse {
    /**
     * 
     * @type {string}
     * @memberof AccessKeyRotateResponse
     */
    'accessKeyHashId': string;
}
/**
 * 
 * @export
 * @interface AppDTO
 */
export interface AppDTO {
    /**
     * 
     * @type {string}
     * @memberof AppDTO
     */
    'identifier': string;
    /**
     * 
     * @type {string}
     * @memberof AppDTO
     */
    'publicKey': string;
    /**
     * 
     * @type {AppDTOConfig}
     * @memberof AppDTO
     */
    'config': AppDTOConfig;
    /**
     * 
     * @type {Array<AppDTOManifestInner>}
     * @memberof AppDTO
     */
    'manifest': Array<AppDTOManifestInner>;
    /**
     * 
     * @type {Array<AppDTOConnectedWorkersInner>}
     * @memberof AppDTO
     */
    'connectedWorkers': Array<AppDTOConnectedWorkersInner>;
    /**
     * 
     * @type {string}
     * @memberof AppDTO
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof AppDTO
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface AppDTOConfig
 */
export interface AppDTOConfig {
    /**
     * 
     * @type {string}
     * @memberof AppDTOConfig
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof AppDTOConfig
     */
    'requiresStorage': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof AppDTOConfig
     */
    'emittableEvents': Array<string>;
    /**
     * 
     * @type {Array<AppDTOConfigTasksInner>}
     * @memberof AppDTOConfig
     */
    'tasks': Array<AppDTOConfigTasksInner>;
    /**
     * 
     * @type {Array<AppDTOConfigMenuItemsInner>}
     * @memberof AppDTOConfig
     */
    'menuItems': Array<AppDTOConfigMenuItemsInner>;
}
/**
 * 
 * @export
 * @interface AppDTOConfigMenuItemsInner
 */
export interface AppDTOConfigMenuItemsInner {
    /**
     * 
     * @type {string}
     * @memberof AppDTOConfigMenuItemsInner
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof AppDTOConfigMenuItemsInner
     */
    'iconPath'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppDTOConfigMenuItemsInner
     */
    'uiName': string;
}
/**
 * 
 * @export
 * @interface AppDTOConfigTasksInner
 */
export interface AppDTOConfigTasksInner {
    /**
     * 
     * @type {string}
     * @memberof AppDTOConfigTasksInner
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof AppDTOConfigTasksInner
     */
    'label': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AppDTOConfigTasksInner
     */
    'eventTriggers': Array<string>;
    /**
     * 
     * @type {AppDTOConfigTasksInnerFolderAction}
     * @memberof AppDTOConfigTasksInner
     */
    'folderAction'?: AppDTOConfigTasksInnerFolderAction;
    /**
     * 
     * @type {AppDTOConfigTasksInnerFolderAction}
     * @memberof AppDTOConfigTasksInner
     */
    'objectAction'?: AppDTOConfigTasksInnerFolderAction;
    /**
     * 
     * @type {string}
     * @memberof AppDTOConfigTasksInner
     */
    'description': string;
    /**
     * 
     * @type {{ [key: string]: AppDTOConfigTasksInnerInputParamsValue; }}
     * @memberof AppDTOConfigTasksInner
     */
    'inputParams'?: { [key: string]: AppDTOConfigTasksInnerInputParamsValue; };
}
/**
 * 
 * @export
 * @interface AppDTOConfigTasksInnerFolderAction
 */
export interface AppDTOConfigTasksInnerFolderAction {
    /**
     * 
     * @type {string}
     * @memberof AppDTOConfigTasksInnerFolderAction
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface AppDTOConfigTasksInnerInputParamsValue
 */
export interface AppDTOConfigTasksInnerInputParamsValue {
    /**
     * 
     * @type {string}
     * @memberof AppDTOConfigTasksInnerInputParamsValue
     */
    'type': AppDTOConfigTasksInnerInputParamsValueTypeEnum;
    /**
     * 
     * @type {AppDTOConfigTasksInnerInputParamsValueDefault}
     * @memberof AppDTOConfigTasksInnerInputParamsValue
     */
    'default'?: AppDTOConfigTasksInnerInputParamsValueDefault;
}

export const AppDTOConfigTasksInnerInputParamsValueTypeEnum = {
    Boolean: 'boolean',
    String: 'string',
    Number: 'number'
} as const;

export type AppDTOConfigTasksInnerInputParamsValueTypeEnum = typeof AppDTOConfigTasksInnerInputParamsValueTypeEnum[keyof typeof AppDTOConfigTasksInnerInputParamsValueTypeEnum];

/**
 * @type AppDTOConfigTasksInnerInputParamsValueDefault
 * @export
 */
export type AppDTOConfigTasksInnerInputParamsValueDefault = boolean | number | string;

/**
 * 
 * @export
 * @interface AppDTOConnectedWorkersInner
 */
export interface AppDTOConnectedWorkersInner {
    /**
     * 
     * @type {string}
     * @memberof AppDTOConnectedWorkersInner
     */
    'appIdentifier': string;
    /**
     * 
     * @type {string}
     * @memberof AppDTOConnectedWorkersInner
     */
    'workerId': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AppDTOConnectedWorkersInner
     */
    'handledTaskKeys': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof AppDTOConnectedWorkersInner
     */
    'socketClientId': string;
    /**
     * 
     * @type {string}
     * @memberof AppDTOConnectedWorkersInner
     */
    'ip': string;
}
/**
 * 
 * @export
 * @interface AppDTOManifestInner
 */
export interface AppDTOManifestInner {
    /**
     * 
     * @type {string}
     * @memberof AppDTOManifestInner
     */
    'path': string;
    /**
     * 
     * @type {string}
     * @memberof AppDTOManifestInner
     */
    'hash': string;
    /**
     * 
     * @type {number}
     * @memberof AppDTOManifestInner
     */
    'size': number;
}
/**
 * 
 * @export
 * @interface AppGetResponse
 */
export interface AppGetResponse {
    /**
     * 
     * @type {AppListResponseResultInner}
     * @memberof AppGetResponse
     */
    'app': AppListResponseResultInner;
}
/**
 * 
 * @export
 * @interface AppListResponse
 */
export interface AppListResponse {
    /**
     * 
     * @type {UserListResponseMeta}
     * @memberof AppListResponse
     */
    'meta': UserListResponseMeta;
    /**
     * 
     * @type {Array<AppListResponseResultInner>}
     * @memberof AppListResponse
     */
    'result': Array<AppListResponseResultInner>;
}
/**
 * 
 * @export
 * @interface AppListResponseResultInner
 */
export interface AppListResponseResultInner {
    /**
     * 
     * @type {string}
     * @memberof AppListResponseResultInner
     */
    'identifier': string;
    /**
     * 
     * @type {string}
     * @memberof AppListResponseResultInner
     */
    'publicKey': string;
    /**
     * 
     * @type {AppDTOConfig}
     * @memberof AppListResponseResultInner
     */
    'config': AppDTOConfig;
    /**
     * 
     * @type {Array<AppDTOManifestInner>}
     * @memberof AppListResponseResultInner
     */
    'manifest': Array<AppDTOManifestInner>;
    /**
     * 
     * @type {Array<AppDTOConnectedWorkersInner>}
     * @memberof AppListResponseResultInner
     */
    'connectedWorkers': Array<AppDTOConnectedWorkersInner>;
    /**
     * 
     * @type {string}
     * @memberof AppListResponseResultInner
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof AppListResponseResultInner
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface EventDTO
 */
export interface EventDTO {
    /**
     * 
     * @type {string}
     * @memberof EventDTO
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EventDTO
     */
    'eventKey': string;
    /**
     * 
     * @type {string}
     * @memberof EventDTO
     */
    'level': EventDTOLevelEnum;
    /**
     * 
     * @type {string}
     * @memberof EventDTO
     */
    'emitterIdentifier': string;
    /**
     * 
     * @type {EventDTOLocationContext}
     * @memberof EventDTO
     */
    'locationContext'?: EventDTOLocationContext;
    /**
     * 
     * @type {any}
     * @memberof EventDTO
     */
    'data'?: any;
    /**
     * 
     * @type {string}
     * @memberof EventDTO
     */
    'createdAt': string;
}

export const EventDTOLevelEnum = {
    Trace: 'TRACE',
    Debug: 'DEBUG',
    Info: 'INFO',
    Warn: 'WARN',
    Error: 'ERROR'
} as const;

export type EventDTOLevelEnum = typeof EventDTOLevelEnum[keyof typeof EventDTOLevelEnum];

/**
 * 
 * @export
 * @interface EventDTOLocationContext
 */
export interface EventDTOLocationContext {
    /**
     * 
     * @type {string}
     * @memberof EventDTOLocationContext
     */
    'folderId': string;
    /**
     * 
     * @type {string}
     * @memberof EventDTOLocationContext
     */
    'objectKey'?: string;
}
/**
 * 
 * @export
 * @interface EventGetResponse
 */
export interface EventGetResponse {
    /**
     * 
     * @type {EventGetResponseEvent}
     * @memberof EventGetResponse
     */
    'event': EventGetResponseEvent;
}
/**
 * 
 * @export
 * @interface EventGetResponseEvent
 */
export interface EventGetResponseEvent {
    /**
     * 
     * @type {string}
     * @memberof EventGetResponseEvent
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EventGetResponseEvent
     */
    'eventKey': string;
    /**
     * 
     * @type {string}
     * @memberof EventGetResponseEvent
     */
    'level': EventGetResponseEventLevelEnum;
    /**
     * 
     * @type {string}
     * @memberof EventGetResponseEvent
     */
    'emitterIdentifier': string;
    /**
     * 
     * @type {EventDTOLocationContext}
     * @memberof EventGetResponseEvent
     */
    'locationContext'?: EventDTOLocationContext;
    /**
     * 
     * @type {any}
     * @memberof EventGetResponseEvent
     */
    'data'?: any;
    /**
     * 
     * @type {string}
     * @memberof EventGetResponseEvent
     */
    'createdAt': string;
}

export const EventGetResponseEventLevelEnum = {
    Trace: 'TRACE',
    Debug: 'DEBUG',
    Info: 'INFO',
    Warn: 'WARN',
    Error: 'ERROR'
} as const;

export type EventGetResponseEventLevelEnum = typeof EventGetResponseEventLevelEnum[keyof typeof EventGetResponseEventLevelEnum];

/**
 * 
 * @export
 * @interface EventListResponse
 */
export interface EventListResponse {
    /**
     * 
     * @type {UserListResponseMeta}
     * @memberof EventListResponse
     */
    'meta': UserListResponseMeta;
    /**
     * 
     * @type {Array<EventGetResponseEvent>}
     * @memberof EventListResponse
     */
    'result': Array<EventGetResponseEvent>;
}
/**
 * 
 * @export
 * @interface FolderCreateInputDTO
 */
export interface FolderCreateInputDTO {
    /**
     * 
     * @type {string}
     * @memberof FolderCreateInputDTO
     */
    'name': string;
    /**
     * 
     * @type {FolderCreateInputDTOMetadataLocation}
     * @memberof FolderCreateInputDTO
     */
    'metadataLocation': FolderCreateInputDTOMetadataLocation;
    /**
     * 
     * @type {FolderCreateInputDTOMetadataLocation}
     * @memberof FolderCreateInputDTO
     */
    'contentLocation': FolderCreateInputDTOMetadataLocation;
}
/**
 * @type FolderCreateInputDTOMetadataLocation
 * @export
 */
export type FolderCreateInputDTOMetadataLocation = StorageLocationInputDTOOneOf | StorageLocationInputDTOOneOf1 | StorageLocationInputDTOOneOf2;

/**
 * 
 * @export
 * @interface FolderCreateResponse
 */
export interface FolderCreateResponse {
    /**
     * 
     * @type {FolderGetResponseFolder}
     * @memberof FolderCreateResponse
     */
    'folder': FolderGetResponseFolder;
}
/**
 * 
 * @export
 * @interface FolderCreateSignedUrlInputDTOInner
 */
export interface FolderCreateSignedUrlInputDTOInner {
    /**
     * 
     * @type {string}
     * @memberof FolderCreateSignedUrlInputDTOInner
     */
    'objectIdentifier': string;
    /**
     * 
     * @type {string}
     * @memberof FolderCreateSignedUrlInputDTOInner
     */
    'method': FolderCreateSignedUrlInputDTOInnerMethodEnum;
}

export const FolderCreateSignedUrlInputDTOInnerMethodEnum = {
    Delete: 'DELETE',
    Put: 'PUT',
    Get: 'GET'
} as const;

export type FolderCreateSignedUrlInputDTOInnerMethodEnum = typeof FolderCreateSignedUrlInputDTOInnerMethodEnum[keyof typeof FolderCreateSignedUrlInputDTOInnerMethodEnum];

/**
 * 
 * @export
 * @interface FolderCreateSignedUrlsResponse
 */
export interface FolderCreateSignedUrlsResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof FolderCreateSignedUrlsResponse
     */
    'urls': Array<string>;
}
/**
 * 
 * @export
 * @interface FolderDTO
 */
export interface FolderDTO {
    /**
     * 
     * @type {string}
     * @memberof FolderDTO
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FolderDTO
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof FolderDTO
     */
    'name': string;
    /**
     * 
     * @type {FolderDTOMetadataLocation}
     * @memberof FolderDTO
     */
    'metadataLocation': FolderDTOMetadataLocation;
    /**
     * 
     * @type {FolderDTOMetadataLocation}
     * @memberof FolderDTO
     */
    'contentLocation': FolderDTOMetadataLocation;
    /**
     * 
     * @type {string}
     * @memberof FolderDTO
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof FolderDTO
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface FolderDTOMetadataLocation
 */
export interface FolderDTOMetadataLocation {
    /**
     * 
     * @type {string}
     * @memberof FolderDTOMetadataLocation
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FolderDTOMetadataLocation
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof FolderDTOMetadataLocation
     */
    'providerType': FolderDTOMetadataLocationProviderTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof FolderDTOMetadataLocation
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof FolderDTOMetadataLocation
     */
    'endpoint': string;
    /**
     * 
     * @type {string}
     * @memberof FolderDTOMetadataLocation
     */
    'region': string;
    /**
     * 
     * @type {string}
     * @memberof FolderDTOMetadataLocation
     */
    'bucket': string;
    /**
     * 
     * @type {string}
     * @memberof FolderDTOMetadataLocation
     */
    'prefix'?: string;
    /**
     * 
     * @type {string}
     * @memberof FolderDTOMetadataLocation
     */
    'accessKeyId': string;
    /**
     * 
     * @type {string}
     * @memberof FolderDTOMetadataLocation
     */
    'accessKeyHashId': string;
}

export const FolderDTOMetadataLocationProviderTypeEnum = {
    Server: 'SERVER',
    User: 'USER'
} as const;

export type FolderDTOMetadataLocationProviderTypeEnum = typeof FolderDTOMetadataLocationProviderTypeEnum[keyof typeof FolderDTOMetadataLocationProviderTypeEnum];

/**
 * 
 * @export
 * @interface FolderGetMetadataResponse
 */
export interface FolderGetMetadataResponse {
    /**
     * 
     * @type {number}
     * @memberof FolderGetMetadataResponse
     */
    'totalCount': number;
    /**
     * 
     * @type {number}
     * @memberof FolderGetMetadataResponse
     */
    'totalSizeBytes': number;
}
/**
 * 
 * @export
 * @interface FolderGetResponse
 */
export interface FolderGetResponse {
    /**
     * 
     * @type {FolderGetResponseFolder}
     * @memberof FolderGetResponse
     */
    'folder': FolderGetResponseFolder;
    /**
     * 
     * @type {Array<string>}
     * @memberof FolderGetResponse
     */
    'permissions': Array<FolderGetResponsePermissionsEnum>;
}

export const FolderGetResponsePermissionsEnum = {
    FolderReindex: 'FOLDER_REINDEX',
    FolderForget: 'FOLDER_FORGET',
    ObjectEdit: 'OBJECT_EDIT',
    ObjectManage: 'OBJECT_MANAGE'
} as const;

export type FolderGetResponsePermissionsEnum = typeof FolderGetResponsePermissionsEnum[keyof typeof FolderGetResponsePermissionsEnum];

/**
 * 
 * @export
 * @interface FolderGetResponseFolder
 */
export interface FolderGetResponseFolder {
    /**
     * 
     * @type {string}
     * @memberof FolderGetResponseFolder
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FolderGetResponseFolder
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof FolderGetResponseFolder
     */
    'name': string;
    /**
     * 
     * @type {FolderDTOMetadataLocation}
     * @memberof FolderGetResponseFolder
     */
    'metadataLocation': FolderDTOMetadataLocation;
    /**
     * 
     * @type {FolderDTOMetadataLocation}
     * @memberof FolderGetResponseFolder
     */
    'contentLocation': FolderDTOMetadataLocation;
    /**
     * 
     * @type {string}
     * @memberof FolderGetResponseFolder
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof FolderGetResponseFolder
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface FolderListResponse
 */
export interface FolderListResponse {
    /**
     * 
     * @type {UserListResponseMeta}
     * @memberof FolderListResponse
     */
    'meta': UserListResponseMeta;
    /**
     * 
     * @type {Array<FolderListResponseResultInner>}
     * @memberof FolderListResponse
     */
    'result': Array<FolderListResponseResultInner>;
}
/**
 * 
 * @export
 * @interface FolderListResponseResultInner
 */
export interface FolderListResponseResultInner {
    /**
     * 
     * @type {FolderGetResponseFolder}
     * @memberof FolderListResponseResultInner
     */
    'folder': FolderGetResponseFolder;
    /**
     * 
     * @type {Array<string>}
     * @memberof FolderListResponseResultInner
     */
    'permissions': Array<FolderListResponseResultInnerPermissionsEnum>;
}

export const FolderListResponseResultInnerPermissionsEnum = {
    FolderReindex: 'FOLDER_REINDEX',
    FolderForget: 'FOLDER_FORGET',
    ObjectEdit: 'OBJECT_EDIT',
    ObjectManage: 'OBJECT_MANAGE'
} as const;

export type FolderListResponseResultInnerPermissionsEnum = typeof FolderListResponseResultInnerPermissionsEnum[keyof typeof FolderListResponseResultInnerPermissionsEnum];

/**
 * 
 * @export
 * @interface FolderObjectContentAttributesDTO
 */
export interface FolderObjectContentAttributesDTO {
    /**
     * 
     * @type {string}
     * @memberof FolderObjectContentAttributesDTO
     */
    'mediaType': FolderObjectContentAttributesDTOMediaTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof FolderObjectContentAttributesDTO
     */
    'mimeType': string;
    /**
     * 
     * @type {number}
     * @memberof FolderObjectContentAttributesDTO
     */
    'height': number;
    /**
     * 
     * @type {number}
     * @memberof FolderObjectContentAttributesDTO
     */
    'width': number;
    /**
     * 
     * @type {number}
     * @memberof FolderObjectContentAttributesDTO
     */
    'orientation': number;
    /**
     * 
     * @type {number}
     * @memberof FolderObjectContentAttributesDTO
     */
    'lengthMs': number;
    /**
     * 
     * @type {number}
     * @memberof FolderObjectContentAttributesDTO
     */
    'bitrate': number;
}

export const FolderObjectContentAttributesDTOMediaTypeEnum = {
    Image: 'IMAGE',
    Video: 'VIDEO',
    Audio: 'AUDIO',
    Document: 'DOCUMENT',
    Unknown: 'UNKNOWN'
} as const;

export type FolderObjectContentAttributesDTOMediaTypeEnum = typeof FolderObjectContentAttributesDTOMediaTypeEnum[keyof typeof FolderObjectContentAttributesDTOMediaTypeEnum];

/**
 * 
 * @export
 * @interface FolderObjectDTO
 */
export interface FolderObjectDTO {
    /**
     * 
     * @type {string}
     * @memberof FolderObjectDTO
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FolderObjectDTO
     */
    'objectKey': string;
    /**
     * 
     * @type {string}
     * @memberof FolderObjectDTO
     */
    'folderId': string;
    /**
     * 
     * @type {string}
     * @memberof FolderObjectDTO
     */
    'hash'?: string;
    /**
     * 
     * @type {number}
     * @memberof FolderObjectDTO
     */
    'lastModified': number;
    /**
     * 
     * @type {string}
     * @memberof FolderObjectDTO
     */
    'eTag': string;
    /**
     * 
     * @type {number}
     * @memberof FolderObjectDTO
     */
    'sizeBytes': number;
    /**
     * 
     * @type {string}
     * @memberof FolderObjectDTO
     */
    'mimeType': string;
    /**
     * 
     * @type {string}
     * @memberof FolderObjectDTO
     */
    'mediaType': FolderObjectDTOMediaTypeEnum;
    /**
     * 
     * @type {{ [key: string]: FolderObjectDTOContentAttributesValue; }}
     * @memberof FolderObjectDTO
     */
    'contentAttributes': { [key: string]: FolderObjectDTOContentAttributesValue; };
    /**
     * 
     * @type {{ [key: string]: { [key: string]: FolderObjectDTOContentMetadataValueValue; }; }}
     * @memberof FolderObjectDTO
     */
    'contentMetadata': { [key: string]: { [key: string]: FolderObjectDTOContentMetadataValueValue; }; };
}

export const FolderObjectDTOMediaTypeEnum = {
    Image: 'IMAGE',
    Video: 'VIDEO',
    Audio: 'AUDIO',
    Document: 'DOCUMENT',
    Unknown: 'UNKNOWN'
} as const;

export type FolderObjectDTOMediaTypeEnum = typeof FolderObjectDTOMediaTypeEnum[keyof typeof FolderObjectDTOMediaTypeEnum];

/**
 * 
 * @export
 * @interface FolderObjectDTOContentAttributesValue
 */
export interface FolderObjectDTOContentAttributesValue {
    /**
     * 
     * @type {string}
     * @memberof FolderObjectDTOContentAttributesValue
     */
    'mediaType': FolderObjectDTOContentAttributesValueMediaTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof FolderObjectDTOContentAttributesValue
     */
    'mimeType': string;
    /**
     * 
     * @type {number}
     * @memberof FolderObjectDTOContentAttributesValue
     */
    'height': number;
    /**
     * 
     * @type {number}
     * @memberof FolderObjectDTOContentAttributesValue
     */
    'width': number;
    /**
     * 
     * @type {number}
     * @memberof FolderObjectDTOContentAttributesValue
     */
    'orientation': number;
    /**
     * 
     * @type {number}
     * @memberof FolderObjectDTOContentAttributesValue
     */
    'lengthMs': number;
    /**
     * 
     * @type {number}
     * @memberof FolderObjectDTOContentAttributesValue
     */
    'bitrate': number;
}

export const FolderObjectDTOContentAttributesValueMediaTypeEnum = {
    Image: 'IMAGE',
    Video: 'VIDEO',
    Audio: 'AUDIO',
    Document: 'DOCUMENT',
    Unknown: 'UNKNOWN'
} as const;

export type FolderObjectDTOContentAttributesValueMediaTypeEnum = typeof FolderObjectDTOContentAttributesValueMediaTypeEnum[keyof typeof FolderObjectDTOContentAttributesValueMediaTypeEnum];

/**
 * 
 * @export
 * @interface FolderObjectDTOContentMetadataValueValue
 */
export interface FolderObjectDTOContentMetadataValueValue {
    /**
     * 
     * @type {string}
     * @memberof FolderObjectDTOContentMetadataValueValue
     */
    'mimeType': string;
    /**
     * 
     * @type {number}
     * @memberof FolderObjectDTOContentMetadataValueValue
     */
    'size': number;
    /**
     * 
     * @type {string}
     * @memberof FolderObjectDTOContentMetadataValueValue
     */
    'hash': string;
}
/**
 * 
 * @export
 * @interface FolderObjectGetResponse
 */
export interface FolderObjectGetResponse {
    /**
     * 
     * @type {FolderObjectListResponseResultInner}
     * @memberof FolderObjectGetResponse
     */
    'folderObject': FolderObjectListResponseResultInner;
}
/**
 * 
 * @export
 * @interface FolderObjectListResponse
 */
export interface FolderObjectListResponse {
    /**
     * 
     * @type {UserListResponseMeta}
     * @memberof FolderObjectListResponse
     */
    'meta': UserListResponseMeta;
    /**
     * 
     * @type {Array<FolderObjectListResponseResultInner>}
     * @memberof FolderObjectListResponse
     */
    'result': Array<FolderObjectListResponseResultInner>;
}
/**
 * 
 * @export
 * @interface FolderObjectListResponseResultInner
 */
export interface FolderObjectListResponseResultInner {
    /**
     * 
     * @type {string}
     * @memberof FolderObjectListResponseResultInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FolderObjectListResponseResultInner
     */
    'objectKey': string;
    /**
     * 
     * @type {string}
     * @memberof FolderObjectListResponseResultInner
     */
    'folderId': string;
    /**
     * 
     * @type {string}
     * @memberof FolderObjectListResponseResultInner
     */
    'hash'?: string;
    /**
     * 
     * @type {number}
     * @memberof FolderObjectListResponseResultInner
     */
    'lastModified': number;
    /**
     * 
     * @type {string}
     * @memberof FolderObjectListResponseResultInner
     */
    'eTag': string;
    /**
     * 
     * @type {number}
     * @memberof FolderObjectListResponseResultInner
     */
    'sizeBytes': number;
    /**
     * 
     * @type {string}
     * @memberof FolderObjectListResponseResultInner
     */
    'mimeType': string;
    /**
     * 
     * @type {string}
     * @memberof FolderObjectListResponseResultInner
     */
    'mediaType': FolderObjectListResponseResultInnerMediaTypeEnum;
    /**
     * 
     * @type {{ [key: string]: FolderObjectDTOContentAttributesValue; }}
     * @memberof FolderObjectListResponseResultInner
     */
    'contentAttributes': { [key: string]: FolderObjectDTOContentAttributesValue; };
    /**
     * 
     * @type {{ [key: string]: { [key: string]: FolderObjectDTOContentMetadataValueValue; }; }}
     * @memberof FolderObjectListResponseResultInner
     */
    'contentMetadata': { [key: string]: { [key: string]: FolderObjectDTOContentMetadataValueValue; }; };
}

export const FolderObjectListResponseResultInnerMediaTypeEnum = {
    Image: 'IMAGE',
    Video: 'VIDEO',
    Audio: 'AUDIO',
    Document: 'DOCUMENT',
    Unknown: 'UNKNOWN'
} as const;

export type FolderObjectListResponseResultInnerMediaTypeEnum = typeof FolderObjectListResponseResultInnerMediaTypeEnum[keyof typeof FolderObjectListResponseResultInnerMediaTypeEnum];

/**
 * 
 * @export
 * @interface FolderShareCreateInputDTO
 */
export interface FolderShareCreateInputDTO {
    /**
     * 
     * @type {Array<string>}
     * @memberof FolderShareCreateInputDTO
     */
    'permissions': Array<FolderShareCreateInputDTOPermissionsEnum>;
}

export const FolderShareCreateInputDTOPermissionsEnum = {
    FolderReindex: 'FOLDER_REINDEX',
    FolderForget: 'FOLDER_FORGET',
    ObjectEdit: 'OBJECT_EDIT',
    ObjectManage: 'OBJECT_MANAGE'
} as const;

export type FolderShareCreateInputDTOPermissionsEnum = typeof FolderShareCreateInputDTOPermissionsEnum[keyof typeof FolderShareCreateInputDTOPermissionsEnum];

/**
 * 
 * @export
 * @interface FolderShareGetResponse
 */
export interface FolderShareGetResponse {
    /**
     * 
     * @type {FolderShareGetResponseShare}
     * @memberof FolderShareGetResponse
     */
    'share': FolderShareGetResponseShare;
}
/**
 * 
 * @export
 * @interface FolderShareGetResponseShare
 */
export interface FolderShareGetResponseShare {
    /**
     * 
     * @type {string}
     * @memberof FolderShareGetResponseShare
     */
    'userId': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof FolderShareGetResponseShare
     */
    'permissions': Array<FolderShareGetResponseSharePermissionsEnum>;
}

export const FolderShareGetResponseSharePermissionsEnum = {
    FolderReindex: 'FOLDER_REINDEX',
    FolderForget: 'FOLDER_FORGET',
    ObjectEdit: 'OBJECT_EDIT',
    ObjectManage: 'OBJECT_MANAGE'
} as const;

export type FolderShareGetResponseSharePermissionsEnum = typeof FolderShareGetResponseSharePermissionsEnum[keyof typeof FolderShareGetResponseSharePermissionsEnum];

/**
 * 
 * @export
 * @interface FolderShareListResponse
 */
export interface FolderShareListResponse {
    /**
     * 
     * @type {UserListResponseMeta}
     * @memberof FolderShareListResponse
     */
    'meta': UserListResponseMeta;
    /**
     * 
     * @type {Array<FolderShareGetResponseShare>}
     * @memberof FolderShareListResponse
     */
    'result': Array<FolderShareGetResponseShare>;
}
/**
 * 
 * @export
 * @interface FolderShareUserListResponse
 */
export interface FolderShareUserListResponse {
    /**
     * 
     * @type {UserListResponseMeta}
     * @memberof FolderShareUserListResponse
     */
    'meta': UserListResponseMeta;
    /**
     * 
     * @type {Array<FolderShareUserListResponseResultInner>}
     * @memberof FolderShareUserListResponse
     */
    'result': Array<FolderShareUserListResponseResultInner>;
}
/**
 * 
 * @export
 * @interface FolderShareUserListResponseResultInner
 */
export interface FolderShareUserListResponseResultInner {
    /**
     * 
     * @type {string}
     * @memberof FolderShareUserListResponseResultInner
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof FolderShareUserListResponseResultInner
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface LoginCredentialsDTO
 */
export interface LoginCredentialsDTO {
    /**
     * 
     * @type {string}
     * @memberof LoginCredentialsDTO
     */
    'login': string;
    /**
     * 
     * @type {string}
     * @memberof LoginCredentialsDTO
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface LoginResponse
 */
export interface LoginResponse {
    /**
     * 
     * @type {LoginResponseSession}
     * @memberof LoginResponse
     */
    'session': LoginResponseSession;
}
/**
 * 
 * @export
 * @interface LoginResponseSession
 */
export interface LoginResponseSession {
    /**
     * 
     * @type {string}
     * @memberof LoginResponseSession
     */
    'accessToken': string;
    /**
     * 
     * @type {string}
     * @memberof LoginResponseSession
     */
    'refreshToken': string;
    /**
     * 
     * @type {string}
     * @memberof LoginResponseSession
     */
    'expiresAt': string;
}
/**
 * 
 * @export
 * @interface RotateAccessKeyInputDTO
 */
export interface RotateAccessKeyInputDTO {
    /**
     * 
     * @type {string}
     * @memberof RotateAccessKeyInputDTO
     */
    'accessKeyId': string;
    /**
     * 
     * @type {string}
     * @memberof RotateAccessKeyInputDTO
     */
    'secretAccessKey': string;
}
/**
 * 
 * @export
 * @interface ServerStorageLocationDTO
 */
export interface ServerStorageLocationDTO {
    /**
     * 
     * @type {string}
     * @memberof ServerStorageLocationDTO
     */
    'accessKeyHashId': string;
    /**
     * 
     * @type {string}
     * @memberof ServerStorageLocationDTO
     */
    'accessKeyId': string;
    /**
     * 
     * @type {string}
     * @memberof ServerStorageLocationDTO
     */
    'endpoint': string;
    /**
     * 
     * @type {string}
     * @memberof ServerStorageLocationDTO
     */
    'bucket': string;
    /**
     * 
     * @type {string}
     * @memberof ServerStorageLocationDTO
     */
    'region': string;
    /**
     * 
     * @type {string}
     * @memberof ServerStorageLocationDTO
     */
    'prefix': string;
}
/**
 * 
 * @export
 * @interface ServerStorageLocationGetResponse
 */
export interface ServerStorageLocationGetResponse {
    /**
     * 
     * @type {ServerStorageLocationGetResponseServerStorageLocation}
     * @memberof ServerStorageLocationGetResponse
     */
    'serverStorageLocation'?: ServerStorageLocationGetResponseServerStorageLocation;
}
/**
 * 
 * @export
 * @interface ServerStorageLocationGetResponseServerStorageLocation
 */
export interface ServerStorageLocationGetResponseServerStorageLocation {
    /**
     * 
     * @type {string}
     * @memberof ServerStorageLocationGetResponseServerStorageLocation
     */
    'accessKeyHashId': string;
    /**
     * 
     * @type {string}
     * @memberof ServerStorageLocationGetResponseServerStorageLocation
     */
    'accessKeyId': string;
    /**
     * 
     * @type {string}
     * @memberof ServerStorageLocationGetResponseServerStorageLocation
     */
    'endpoint': string;
    /**
     * 
     * @type {string}
     * @memberof ServerStorageLocationGetResponseServerStorageLocation
     */
    'bucket': string;
    /**
     * 
     * @type {string}
     * @memberof ServerStorageLocationGetResponseServerStorageLocation
     */
    'region': string;
    /**
     * 
     * @type {string}
     * @memberof ServerStorageLocationGetResponseServerStorageLocation
     */
    'prefix': string;
}
/**
 * 
 * @export
 * @interface ServerStorageLocationInputDTO
 */
export interface ServerStorageLocationInputDTO {
    /**
     * 
     * @type {string}
     * @memberof ServerStorageLocationInputDTO
     */
    'accessKeyId': string;
    /**
     * 
     * @type {string}
     * @memberof ServerStorageLocationInputDTO
     */
    'secretAccessKey': string;
    /**
     * 
     * @type {string}
     * @memberof ServerStorageLocationInputDTO
     */
    'endpoint': string;
    /**
     * 
     * @type {string}
     * @memberof ServerStorageLocationInputDTO
     */
    'bucket': string;
    /**
     * 
     * @type {string}
     * @memberof ServerStorageLocationInputDTO
     */
    'region': string;
    /**
     * 
     * @type {string}
     * @memberof ServerStorageLocationInputDTO
     */
    'prefix'?: string | null;
}
/**
 * 
 * @export
 * @interface SetSettingInputDTO
 */
export interface SetSettingInputDTO {
    /**
     * 
     * @type {any}
     * @memberof SetSettingInputDTO
     */
    'value'?: any;
}
/**
 * 
 * @export
 * @interface SettingSetResponse
 */
export interface SettingSetResponse {
    /**
     * 
     * @type {string}
     * @memberof SettingSetResponse
     */
    'settingKey': string;
    /**
     * 
     * @type {any}
     * @memberof SettingSetResponse
     */
    'settingValue'?: any;
}
/**
 * 
 * @export
 * @interface SettingsGetResponse
 */
export interface SettingsGetResponse {
    /**
     * 
     * @type {SettingsGetResponseSettings}
     * @memberof SettingsGetResponse
     */
    'settings': SettingsGetResponseSettings;
}
/**
 * 
 * @export
 * @interface SettingsGetResponseSettings
 */
export interface SettingsGetResponseSettings {
    /**
     * 
     * @type {boolean}
     * @memberof SettingsGetResponseSettings
     */
    'SIGNUP_ENABLED'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof SettingsGetResponseSettings
     */
    'SIGNUP_PERMISSIONS'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SettingsGetResponseSettings
     */
    'SERVER_HOSTNAME'?: string;
}
/**
 * 
 * @export
 * @interface SignupCredentialsDTO
 */
export interface SignupCredentialsDTO {
    /**
     * 
     * @type {string}
     * @memberof SignupCredentialsDTO
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof SignupCredentialsDTO
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignupCredentialsDTO
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface SignupResponse
 */
export interface SignupResponse {
    /**
     * 
     * @type {SignupResponseUser}
     * @memberof SignupResponse
     */
    'user': SignupResponseUser;
}
/**
 * 
 * @export
 * @interface SignupResponseUser
 */
export interface SignupResponseUser {
    /**
     * 
     * @type {string}
     * @memberof SignupResponseUser
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SignupResponseUser
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SignupResponseUser
     */
    'email': string;
    /**
     * 
     * @type {boolean}
     * @memberof SignupResponseUser
     */
    'emailVerified': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SignupResponseUser
     */
    'isAdmin': boolean;
    /**
     * 
     * @type {string}
     * @memberof SignupResponseUser
     */
    'username': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SignupResponseUser
     */
    'permissions': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SignupResponseUser
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof SignupResponseUser
     */
    'updatedAt': string;
}
/**
 * @type StorageLocationInputDTO
 * @export
 */
export type StorageLocationInputDTO = StorageLocationInputDTOOneOf | StorageLocationInputDTOOneOf1 | StorageLocationInputDTOOneOf2;

/**
 * 
 * @export
 * @interface StorageLocationInputDTOOneOf
 */
export interface StorageLocationInputDTOOneOf {
    /**
     * 
     * @type {string}
     * @memberof StorageLocationInputDTOOneOf
     */
    'accessKeyId': string;
    /**
     * 
     * @type {string}
     * @memberof StorageLocationInputDTOOneOf
     */
    'secretAccessKey': string;
    /**
     * 
     * @type {string}
     * @memberof StorageLocationInputDTOOneOf
     */
    'endpoint': string;
    /**
     * 
     * @type {string}
     * @memberof StorageLocationInputDTOOneOf
     */
    'bucket': string;
    /**
     * 
     * @type {string}
     * @memberof StorageLocationInputDTOOneOf
     */
    'region': string;
    /**
     * 
     * @type {string}
     * @memberof StorageLocationInputDTOOneOf
     */
    'prefix'?: string;
}
/**
 * 
 * @export
 * @interface StorageLocationInputDTOOneOf1
 */
export interface StorageLocationInputDTOOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof StorageLocationInputDTOOneOf1
     */
    'storageProvisionId': string;
}
/**
 * 
 * @export
 * @interface StorageLocationInputDTOOneOf2
 */
export interface StorageLocationInputDTOOneOf2 {
    /**
     * 
     * @type {string}
     * @memberof StorageLocationInputDTOOneOf2
     */
    'userLocationId': string;
    /**
     * 
     * @type {string}
     * @memberof StorageLocationInputDTOOneOf2
     */
    'userLocationBucketOverride': string;
    /**
     * 
     * @type {string}
     * @memberof StorageLocationInputDTOOneOf2
     */
    'userLocationPrefixOverride'?: string;
}
/**
 * 
 * @export
 * @interface TaskDTO
 */
export interface TaskDTO {
    /**
     * 
     * @type {string}
     * @memberof TaskDTO
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TaskDTO
     */
    'taskKey': string;
    /**
     * 
     * @type {string}
     * @memberof TaskDTO
     */
    'ownerIdentifier': string;
    /**
     * 
     * @type {string}
     * @memberof TaskDTO
     */
    'triggeringEventId': string;
    /**
     * 
     * @type {string}
     * @memberof TaskDTO
     */
    'subjectFolderId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskDTO
     */
    'subjectObjectKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskDTO
     */
    'handlerId'?: string;
    /**
     * 
     * @type {{ [key: string]: TaskGetResponseTaskInputDataValue; }}
     * @memberof TaskDTO
     */
    'inputData': { [key: string]: TaskGetResponseTaskInputDataValue; };
    /**
     * 
     * @type {string}
     * @memberof TaskDTO
     */
    'errorAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskDTO
     */
    'errorCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskDTO
     */
    'errorMessage'?: string;
    /**
     * 
     * @type {TaskGetResponseTaskTaskDescription}
     * @memberof TaskDTO
     */
    'taskDescription': TaskGetResponseTaskTaskDescription;
    /**
     * 
     * @type {Array<any>}
     * @memberof TaskDTO
     */
    'updates': Array<any>;
    /**
     * 
     * @type {string}
     * @memberof TaskDTO
     */
    'startedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskDTO
     */
    'completedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskDTO
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof TaskDTO
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface TaskGetResponse
 */
export interface TaskGetResponse {
    /**
     * 
     * @type {TaskGetResponseTask}
     * @memberof TaskGetResponse
     */
    'task': TaskGetResponseTask;
}
/**
 * 
 * @export
 * @interface TaskGetResponseTask
 */
export interface TaskGetResponseTask {
    /**
     * 
     * @type {string}
     * @memberof TaskGetResponseTask
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TaskGetResponseTask
     */
    'taskKey': string;
    /**
     * 
     * @type {string}
     * @memberof TaskGetResponseTask
     */
    'ownerIdentifier': string;
    /**
     * 
     * @type {string}
     * @memberof TaskGetResponseTask
     */
    'triggeringEventId': string;
    /**
     * 
     * @type {string}
     * @memberof TaskGetResponseTask
     */
    'subjectFolderId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskGetResponseTask
     */
    'subjectObjectKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskGetResponseTask
     */
    'handlerId'?: string;
    /**
     * 
     * @type {{ [key: string]: TaskGetResponseTaskInputDataValue; }}
     * @memberof TaskGetResponseTask
     */
    'inputData': { [key: string]: TaskGetResponseTaskInputDataValue; };
    /**
     * 
     * @type {string}
     * @memberof TaskGetResponseTask
     */
    'errorAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskGetResponseTask
     */
    'errorCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskGetResponseTask
     */
    'errorMessage'?: string;
    /**
     * 
     * @type {TaskGetResponseTaskTaskDescription}
     * @memberof TaskGetResponseTask
     */
    'taskDescription': TaskGetResponseTaskTaskDescription;
    /**
     * 
     * @type {Array<any>}
     * @memberof TaskGetResponseTask
     */
    'updates': Array<any>;
    /**
     * 
     * @type {string}
     * @memberof TaskGetResponseTask
     */
    'startedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskGetResponseTask
     */
    'completedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskGetResponseTask
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof TaskGetResponseTask
     */
    'updatedAt': string;
}
/**
 * @type TaskGetResponseTaskInputDataValue
 * @export
 */
export type TaskGetResponseTaskInputDataValue = number | string;

/**
 * 
 * @export
 * @interface TaskGetResponseTaskTaskDescription
 */
export interface TaskGetResponseTaskTaskDescription {
    /**
     * 
     * @type {string}
     * @memberof TaskGetResponseTaskTaskDescription
     */
    'textKey': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof TaskGetResponseTaskTaskDescription
     */
    'variables': { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface TaskListResponse
 */
export interface TaskListResponse {
    /**
     * 
     * @type {UserListResponseMeta}
     * @memberof TaskListResponse
     */
    'meta': UserListResponseMeta;
    /**
     * 
     * @type {Array<TaskGetResponseTask>}
     * @memberof TaskListResponse
     */
    'result': Array<TaskGetResponseTask>;
}
/**
 * 
 * @export
 * @interface TokenRefreshResponse
 */
export interface TokenRefreshResponse {
    /**
     * 
     * @type {LoginResponseSession}
     * @memberof TokenRefreshResponse
     */
    'session': LoginResponseSession;
}
/**
 * 
 * @export
 * @interface TriggerAppTaskInputDTO
 */
export interface TriggerAppTaskInputDTO {
    /**
     * 
     * @type {string}
     * @memberof TriggerAppTaskInputDTO
     */
    'objectKey'?: string;
    /**
     * 
     * @type {any}
     * @memberof TriggerAppTaskInputDTO
     */
    'inputParams'?: any;
}
/**
 * 
 * @export
 * @interface UserCreateInputDTO
 */
export interface UserCreateInputDTO {
    /**
     * 
     * @type {string}
     * @memberof UserCreateInputDTO
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCreateInputDTO
     */
    'email'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserCreateInputDTO
     */
    'emailVerified'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserCreateInputDTO
     */
    'isAdmin'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserCreateInputDTO
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof UserCreateInputDTO
     */
    'password': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserCreateInputDTO
     */
    'permissions'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UserDTO
 */
export interface UserDTO {
    /**
     * 
     * @type {string}
     * @memberof UserDTO
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserDTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UserDTO
     */
    'email': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserDTO
     */
    'emailVerified': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserDTO
     */
    'isAdmin': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserDTO
     */
    'username': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserDTO
     */
    'permissions': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UserDTO
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserDTO
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface UserGetResponse
 */
export interface UserGetResponse {
    /**
     * 
     * @type {SignupResponseUser}
     * @memberof UserGetResponse
     */
    'user': SignupResponseUser;
}
/**
 * 
 * @export
 * @interface UserListResponse
 */
export interface UserListResponse {
    /**
     * 
     * @type {UserListResponseMeta}
     * @memberof UserListResponse
     */
    'meta': UserListResponseMeta;
    /**
     * 
     * @type {Array<UserListResponseResultInner>}
     * @memberof UserListResponse
     */
    'result': Array<UserListResponseResultInner>;
}
/**
 * 
 * @export
 * @interface UserListResponseMeta
 */
export interface UserListResponseMeta {
    /**
     * 
     * @type {number}
     * @memberof UserListResponseMeta
     */
    'totalCount': number;
}
/**
 * 
 * @export
 * @interface UserListResponseResultInner
 */
export interface UserListResponseResultInner {
    /**
     * 
     * @type {string}
     * @memberof UserListResponseResultInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserListResponseResultInner
     */
    'name'?: string | null;
    /**
     * 
     * @type {UserListResponseResultInnerEmail}
     * @memberof UserListResponseResultInner
     */
    'email': UserListResponseResultInnerEmail;
    /**
     * 
     * @type {boolean}
     * @memberof UserListResponseResultInner
     */
    'emailVerified': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserListResponseResultInner
     */
    'isAdmin': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserListResponseResultInner
     */
    'username': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserListResponseResultInner
     */
    'permissions': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UserListResponseResultInner
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserListResponseResultInner
     */
    'updatedAt': string;
}
/**
 * @type UserListResponseResultInnerEmail
 * @export
 */
export type UserListResponseResultInnerEmail = string;

/**
 * 
 * @export
 * @interface UserSessionListResponse
 */
export interface UserSessionListResponse {
    /**
     * 
     * @type {UserListResponseMeta}
     * @memberof UserSessionListResponse
     */
    'meta': UserListResponseMeta;
    /**
     * 
     * @type {Array<UserSessionListResponseResultInner>}
     * @memberof UserSessionListResponse
     */
    'result': Array<UserSessionListResponseResultInner>;
}
/**
 * 
 * @export
 * @interface UserSessionListResponseResultInner
 */
export interface UserSessionListResponseResultInner {
    /**
     * 
     * @type {string}
     * @memberof UserSessionListResponseResultInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserSessionListResponseResultInner
     */
    'expiresAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserSessionListResponseResultInner
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserSessionListResponseResultInner
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface UserStorageProvisionDTO
 */
export interface UserStorageProvisionDTO {
    /**
     * 
     * @type {string}
     * @memberof UserStorageProvisionDTO
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserStorageProvisionDTO
     */
    'accessKeyHashId': string;
    /**
     * 
     * @type {string}
     * @memberof UserStorageProvisionDTO
     */
    'endpoint': string;
    /**
     * 
     * @type {string}
     * @memberof UserStorageProvisionDTO
     */
    'bucket': string;
    /**
     * 
     * @type {string}
     * @memberof UserStorageProvisionDTO
     */
    'region': string;
    /**
     * 
     * @type {string}
     * @memberof UserStorageProvisionDTO
     */
    'accessKeyId': string;
    /**
     * 
     * @type {string}
     * @memberof UserStorageProvisionDTO
     */
    'prefix'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserStorageProvisionDTO
     */
    'provisionTypes': Array<UserStorageProvisionDTOProvisionTypesEnum>;
    /**
     * 
     * @type {string}
     * @memberof UserStorageProvisionDTO
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof UserStorageProvisionDTO
     */
    'description': string;
}

export const UserStorageProvisionDTOProvisionTypesEnum = {
    Content: 'CONTENT',
    Metadata: 'METADATA',
    Redundancy: 'REDUNDANCY'
} as const;

export type UserStorageProvisionDTOProvisionTypesEnum = typeof UserStorageProvisionDTOProvisionTypesEnum[keyof typeof UserStorageProvisionDTOProvisionTypesEnum];

/**
 * 
 * @export
 * @interface UserStorageProvisionGetResponse
 */
export interface UserStorageProvisionGetResponse {
    /**
     * 
     * @type {UserStorageProvisionListResponseResultInner}
     * @memberof UserStorageProvisionGetResponse
     */
    'userStorageProvision': UserStorageProvisionListResponseResultInner;
}
/**
 * 
 * @export
 * @interface UserStorageProvisionInputDTO
 */
export interface UserStorageProvisionInputDTO {
    /**
     * 
     * @type {string}
     * @memberof UserStorageProvisionInputDTO
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof UserStorageProvisionInputDTO
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof UserStorageProvisionInputDTO
     */
    'endpoint': string;
    /**
     * 
     * @type {string}
     * @memberof UserStorageProvisionInputDTO
     */
    'bucket': string;
    /**
     * 
     * @type {string}
     * @memberof UserStorageProvisionInputDTO
     */
    'region': string;
    /**
     * 
     * @type {string}
     * @memberof UserStorageProvisionInputDTO
     */
    'accessKeyId': string;
    /**
     * 
     * @type {string}
     * @memberof UserStorageProvisionInputDTO
     */
    'secretAccessKey': string;
    /**
     * 
     * @type {string}
     * @memberof UserStorageProvisionInputDTO
     */
    'prefix'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserStorageProvisionInputDTO
     */
    'provisionTypes': Array<UserStorageProvisionInputDTOProvisionTypesEnum>;
}

export const UserStorageProvisionInputDTOProvisionTypesEnum = {
    Content: 'CONTENT',
    Metadata: 'METADATA',
    Redundancy: 'REDUNDANCY'
} as const;

export type UserStorageProvisionInputDTOProvisionTypesEnum = typeof UserStorageProvisionInputDTOProvisionTypesEnum[keyof typeof UserStorageProvisionInputDTOProvisionTypesEnum];

/**
 * 
 * @export
 * @interface UserStorageProvisionListResponse
 */
export interface UserStorageProvisionListResponse {
    /**
     * 
     * @type {Array<UserStorageProvisionListResponseResultInner>}
     * @memberof UserStorageProvisionListResponse
     */
    'result': Array<UserStorageProvisionListResponseResultInner>;
}
/**
 * 
 * @export
 * @interface UserStorageProvisionListResponseResultInner
 */
export interface UserStorageProvisionListResponseResultInner {
    /**
     * 
     * @type {string}
     * @memberof UserStorageProvisionListResponseResultInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserStorageProvisionListResponseResultInner
     */
    'accessKeyHashId': string;
    /**
     * 
     * @type {string}
     * @memberof UserStorageProvisionListResponseResultInner
     */
    'endpoint': string;
    /**
     * 
     * @type {string}
     * @memberof UserStorageProvisionListResponseResultInner
     */
    'bucket': string;
    /**
     * 
     * @type {string}
     * @memberof UserStorageProvisionListResponseResultInner
     */
    'region': string;
    /**
     * 
     * @type {string}
     * @memberof UserStorageProvisionListResponseResultInner
     */
    'accessKeyId': string;
    /**
     * 
     * @type {string}
     * @memberof UserStorageProvisionListResponseResultInner
     */
    'prefix'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserStorageProvisionListResponseResultInner
     */
    'provisionTypes': Array<UserStorageProvisionListResponseResultInnerProvisionTypesEnum>;
    /**
     * 
     * @type {string}
     * @memberof UserStorageProvisionListResponseResultInner
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof UserStorageProvisionListResponseResultInner
     */
    'description': string;
}

export const UserStorageProvisionListResponseResultInnerProvisionTypesEnum = {
    Content: 'CONTENT',
    Metadata: 'METADATA',
    Redundancy: 'REDUNDANCY'
} as const;

export type UserStorageProvisionListResponseResultInnerProvisionTypesEnum = typeof UserStorageProvisionListResponseResultInnerProvisionTypesEnum[keyof typeof UserStorageProvisionListResponseResultInnerProvisionTypesEnum];

/**
 * 
 * @export
 * @interface UserUpdateInputDTO
 */
export interface UserUpdateInputDTO {
    /**
     * 
     * @type {string}
     * @memberof UserUpdateInputDTO
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUpdateInputDTO
     */
    'email'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserUpdateInputDTO
     */
    'isAdmin'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserUpdateInputDTO
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdateInputDTO
     */
    'password'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserUpdateInputDTO
     */
    'permissions'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ViewerGetResponse
 */
export interface ViewerGetResponse {
    /**
     * 
     * @type {SignupResponseUser}
     * @memberof ViewerGetResponse
     */
    'user': SignupResponseUser;
}
/**
 * 
 * @export
 * @interface ViewerUpdateInputDTO
 */
export interface ViewerUpdateInputDTO {
    /**
     * 
     * @type {string}
     * @memberof ViewerUpdateInputDTO
     */
    'name': string;
}

/**
 * AccessKeysApi - axios parameter creator
 * @export
 */
export const AccessKeysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get an access key by id.
         * @param {string} accessKeyHashId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessKey: async (accessKeyHashId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKeyHashId' is not null or undefined
            assertParamExists('getAccessKey', 'accessKeyHashId', accessKeyHashId)
            const localVarPath = `/api/v1/access-keys/{accessKeyHashId}`
                .replace(`{${"accessKeyHashId"}}`, encodeURIComponent(String(accessKeyHashId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List buckets for an access key.
         * @param {string} accessKeyHashId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccessKeyBuckets: async (accessKeyHashId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKeyHashId' is not null or undefined
            assertParamExists('listAccessKeyBuckets', 'accessKeyHashId', accessKeyHashId)
            const localVarPath = `/api/v1/access-keys/{accessKeyHashId}/buckets`
                .replace(`{${"accessKeyHashId"}}`, encodeURIComponent(String(accessKeyHashId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List access keys.
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {ListAccessKeysSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccessKeys: async (offset?: number, limit?: number, sort?: ListAccessKeysSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/access-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Rotate an access key.
         * @param {string} accessKeyHashId 
         * @param {RotateAccessKeyInputDTO} rotateAccessKeyInputDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rotateAccessKey: async (accessKeyHashId: string, rotateAccessKeyInputDTO: RotateAccessKeyInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKeyHashId' is not null or undefined
            assertParamExists('rotateAccessKey', 'accessKeyHashId', accessKeyHashId)
            // verify required parameter 'rotateAccessKeyInputDTO' is not null or undefined
            assertParamExists('rotateAccessKey', 'rotateAccessKeyInputDTO', rotateAccessKeyInputDTO)
            const localVarPath = `/api/v1/access-keys/{accessKeyHashId}`
                .replace(`{${"accessKeyHashId"}}`, encodeURIComponent(String(accessKeyHashId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rotateAccessKeyInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessKeysApi - functional programming interface
 * @export
 */
export const AccessKeysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccessKeysApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get an access key by id.
         * @param {string} accessKeyHashId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessKey(accessKeyHashId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessKeyGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessKey(accessKeyHashId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessKeysApi.getAccessKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List buckets for an access key.
         * @param {string} accessKeyHashId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAccessKeyBuckets(accessKeyHashId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessKeyBucketsListResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccessKeyBuckets(accessKeyHashId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessKeysApi.listAccessKeyBuckets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List access keys.
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {ListAccessKeysSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAccessKeys(offset?: number, limit?: number, sort?: ListAccessKeysSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessKeyListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccessKeys(offset, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessKeysApi.listAccessKeys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Rotate an access key.
         * @param {string} accessKeyHashId 
         * @param {RotateAccessKeyInputDTO} rotateAccessKeyInputDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rotateAccessKey(accessKeyHashId: string, rotateAccessKeyInputDTO: RotateAccessKeyInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessKeyRotateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rotateAccessKey(accessKeyHashId, rotateAccessKeyInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessKeysApi.rotateAccessKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccessKeysApi - factory interface
 * @export
 */
export const AccessKeysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccessKeysApiFp(configuration)
    return {
        /**
         * 
         * @summary Get an access key by id.
         * @param {AccessKeysApiGetAccessKeyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessKey(requestParameters: AccessKeysApiGetAccessKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccessKeyGetResponse> {
            return localVarFp.getAccessKey(requestParameters.accessKeyHashId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List buckets for an access key.
         * @param {AccessKeysApiListAccessKeyBucketsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccessKeyBuckets(requestParameters: AccessKeysApiListAccessKeyBucketsRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccessKeyBucketsListResponseDTO> {
            return localVarFp.listAccessKeyBuckets(requestParameters.accessKeyHashId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List access keys.
         * @param {AccessKeysApiListAccessKeysRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccessKeys(requestParameters: AccessKeysApiListAccessKeysRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<AccessKeyListResponse> {
            return localVarFp.listAccessKeys(requestParameters.offset, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Rotate an access key.
         * @param {AccessKeysApiRotateAccessKeyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rotateAccessKey(requestParameters: AccessKeysApiRotateAccessKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccessKeyRotateResponse> {
            return localVarFp.rotateAccessKey(requestParameters.accessKeyHashId, requestParameters.rotateAccessKeyInputDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getAccessKey operation in AccessKeysApi.
 * @export
 * @interface AccessKeysApiGetAccessKeyRequest
 */
export interface AccessKeysApiGetAccessKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof AccessKeysApiGetAccessKey
     */
    readonly accessKeyHashId: string
}

/**
 * Request parameters for listAccessKeyBuckets operation in AccessKeysApi.
 * @export
 * @interface AccessKeysApiListAccessKeyBucketsRequest
 */
export interface AccessKeysApiListAccessKeyBucketsRequest {
    /**
     * 
     * @type {string}
     * @memberof AccessKeysApiListAccessKeyBuckets
     */
    readonly accessKeyHashId: string
}

/**
 * Request parameters for listAccessKeys operation in AccessKeysApi.
 * @export
 * @interface AccessKeysApiListAccessKeysRequest
 */
export interface AccessKeysApiListAccessKeysRequest {
    /**
     * 
     * @type {number}
     * @memberof AccessKeysApiListAccessKeys
     */
    readonly offset?: number

    /**
     * 
     * @type {number}
     * @memberof AccessKeysApiListAccessKeys
     */
    readonly limit?: number

    /**
     * 
     * @type {'accessKeyId-asc' | 'accessKeyId-desc' | 'accessKeyHashId-asc' | 'accessKeyHashId-desc' | 'endpoint-asc' | 'endpoint-desc' | 'region-asc' | 'region-desc' | 'updatedAt-asc' | 'updatedAt-desc'}
     * @memberof AccessKeysApiListAccessKeys
     */
    readonly sort?: ListAccessKeysSortEnum
}

/**
 * Request parameters for rotateAccessKey operation in AccessKeysApi.
 * @export
 * @interface AccessKeysApiRotateAccessKeyRequest
 */
export interface AccessKeysApiRotateAccessKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof AccessKeysApiRotateAccessKey
     */
    readonly accessKeyHashId: string

    /**
     * 
     * @type {RotateAccessKeyInputDTO}
     * @memberof AccessKeysApiRotateAccessKey
     */
    readonly rotateAccessKeyInputDTO: RotateAccessKeyInputDTO
}

/**
 * AccessKeysApi - object-oriented interface
 * @export
 * @class AccessKeysApi
 * @extends {BaseAPI}
 */
export class AccessKeysApi extends BaseAPI {
    /**
     * 
     * @summary Get an access key by id.
     * @param {AccessKeysApiGetAccessKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessKeysApi
     */
    public getAccessKey(requestParameters: AccessKeysApiGetAccessKeyRequest, options?: RawAxiosRequestConfig) {
        return AccessKeysApiFp(this.configuration).getAccessKey(requestParameters.accessKeyHashId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List buckets for an access key.
     * @param {AccessKeysApiListAccessKeyBucketsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessKeysApi
     */
    public listAccessKeyBuckets(requestParameters: AccessKeysApiListAccessKeyBucketsRequest, options?: RawAxiosRequestConfig) {
        return AccessKeysApiFp(this.configuration).listAccessKeyBuckets(requestParameters.accessKeyHashId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List access keys.
     * @param {AccessKeysApiListAccessKeysRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessKeysApi
     */
    public listAccessKeys(requestParameters: AccessKeysApiListAccessKeysRequest = {}, options?: RawAxiosRequestConfig) {
        return AccessKeysApiFp(this.configuration).listAccessKeys(requestParameters.offset, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Rotate an access key.
     * @param {AccessKeysApiRotateAccessKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessKeysApi
     */
    public rotateAccessKey(requestParameters: AccessKeysApiRotateAccessKeyRequest, options?: RawAxiosRequestConfig) {
        return AccessKeysApiFp(this.configuration).rotateAccessKey(requestParameters.accessKeyHashId, requestParameters.rotateAccessKeyInputDTO, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListAccessKeysSortEnum = {
    AccessKeyIdAsc: 'accessKeyId-asc',
    AccessKeyIdDesc: 'accessKeyId-desc',
    AccessKeyHashIdAsc: 'accessKeyHashId-asc',
    AccessKeyHashIdDesc: 'accessKeyHashId-desc',
    EndpointAsc: 'endpoint-asc',
    EndpointDesc: 'endpoint-desc',
    RegionAsc: 'region-asc',
    RegionDesc: 'region-desc',
    UpdatedAtAsc: 'updatedAt-asc',
    UpdatedAtDesc: 'updatedAt-desc'
} as const;
export type ListAccessKeysSortEnum = typeof ListAccessKeysSortEnum[keyof typeof ListAccessKeysSortEnum];


/**
 * AppsApi - axios parameter creator
 * @export
 */
export const AppsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} appIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApp: async (appIdentifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appIdentifier' is not null or undefined
            assertParamExists('getApp', 'appIdentifier', appIdentifier)
            const localVarPath = `/api/v1/server/apps/{appIdentifier}`
                .replace(`{${"appIdentifier"}}`, encodeURIComponent(String(appIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApps: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/server/apps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppsApi - functional programming interface
 * @export
 */
export const AppsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AppsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} appIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApp(appIdentifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApp(appIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppsApi.getApp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApps(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApps(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppsApi.listApps']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AppsApi - factory interface
 * @export
 */
export const AppsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AppsApiFp(configuration)
    return {
        /**
         * 
         * @param {AppsApiGetAppRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApp(requestParameters: AppsApiGetAppRequest, options?: RawAxiosRequestConfig): AxiosPromise<AppGetResponse> {
            return localVarFp.getApp(requestParameters.appIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApps(options?: RawAxiosRequestConfig): AxiosPromise<AppListResponse> {
            return localVarFp.listApps(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getApp operation in AppsApi.
 * @export
 * @interface AppsApiGetAppRequest
 */
export interface AppsApiGetAppRequest {
    /**
     * 
     * @type {string}
     * @memberof AppsApiGetApp
     */
    readonly appIdentifier: string
}

/**
 * AppsApi - object-oriented interface
 * @export
 * @class AppsApi
 * @extends {BaseAPI}
 */
export class AppsApi extends BaseAPI {
    /**
     * 
     * @param {AppsApiGetAppRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApi
     */
    public getApp(requestParameters: AppsApiGetAppRequest, options?: RawAxiosRequestConfig) {
        return AppsApiFp(this.configuration).getApp(requestParameters.appIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApi
     */
    public listApps(options?: RawAxiosRequestConfig) {
        return AppsApiFp(this.configuration).listApps(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Authenticate the user and return access and refresh tokens.
         * @param {LoginCredentialsDTO} loginCredentialsDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginCredentialsDTO: LoginCredentialsDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginCredentialsDTO' is not null or undefined
            assertParamExists('login', 'loginCredentialsDTO', loginCredentialsDTO)
            const localVarPath = `/api/v1/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginCredentialsDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logout. Kill the current session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refresh a session with a refresh token.
         * @param {string} refreshToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: async (refreshToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshToken' is not null or undefined
            assertParamExists('refreshToken', 'refreshToken', refreshToken)
            const localVarPath = `/api/v1/auth/{refreshToken}`
                .replace(`{${"refreshToken"}}`, encodeURIComponent(String(refreshToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new user.
         * @param {SignupCredentialsDTO} signupCredentialsDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signup: async (signupCredentialsDTO: SignupCredentialsDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signupCredentialsDTO' is not null or undefined
            assertParamExists('signup', 'signupCredentialsDTO', signupCredentialsDTO)
            const localVarPath = `/api/v1/auth/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signupCredentialsDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Authenticate the user and return access and refresh tokens.
         * @param {LoginCredentialsDTO} loginCredentialsDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginCredentialsDTO: LoginCredentialsDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginCredentialsDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Logout. Kill the current session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.logout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Refresh a session with a refresh token.
         * @param {string} refreshToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken(refreshToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenRefreshResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(refreshToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.refreshToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Register a new user.
         * @param {SignupCredentialsDTO} signupCredentialsDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signup(signupCredentialsDTO: SignupCredentialsDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signup(signupCredentialsDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.signup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Authenticate the user and return access and refresh tokens.
         * @param {AuthApiLoginRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(requestParameters: AuthApiLoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponse> {
            return localVarFp.login(requestParameters.loginCredentialsDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logout. Kill the current session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refresh a session with a refresh token.
         * @param {AuthApiRefreshTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(requestParameters: AuthApiRefreshTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenRefreshResponse> {
            return localVarFp.refreshToken(requestParameters.refreshToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new user.
         * @param {AuthApiSignupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signup(requestParameters: AuthApiSignupRequest, options?: RawAxiosRequestConfig): AxiosPromise<SignupResponse> {
            return localVarFp.signup(requestParameters.signupCredentialsDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for login operation in AuthApi.
 * @export
 * @interface AuthApiLoginRequest
 */
export interface AuthApiLoginRequest {
    /**
     * 
     * @type {LoginCredentialsDTO}
     * @memberof AuthApiLogin
     */
    readonly loginCredentialsDTO: LoginCredentialsDTO
}

/**
 * Request parameters for refreshToken operation in AuthApi.
 * @export
 * @interface AuthApiRefreshTokenRequest
 */
export interface AuthApiRefreshTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthApiRefreshToken
     */
    readonly refreshToken: string
}

/**
 * Request parameters for signup operation in AuthApi.
 * @export
 * @interface AuthApiSignupRequest
 */
export interface AuthApiSignupRequest {
    /**
     * 
     * @type {SignupCredentialsDTO}
     * @memberof AuthApiSignup
     */
    readonly signupCredentialsDTO: SignupCredentialsDTO
}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Authenticate the user and return access and refresh tokens.
     * @param {AuthApiLoginRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public login(requestParameters: AuthApiLoginRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).login(requestParameters.loginCredentialsDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logout. Kill the current session.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public logout(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refresh a session with a refresh token.
     * @param {AuthApiRefreshTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public refreshToken(requestParameters: AuthApiRefreshTokenRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).refreshToken(requestParameters.refreshToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new user.
     * @param {AuthApiSignupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public signup(requestParameters: AuthApiSignupRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).signup(requestParameters.signupCredentialsDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FolderEventsApi - axios parameter creator
 * @export
 */
export const FolderEventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a folder event by id.
         * @param {string} folderId 
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderEvent: async (folderId: string, eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('getFolderEvent', 'folderId', folderId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getFolderEvent', 'eventId', eventId)
            const localVarPath = `/api/v1/folders/{folderId}/events/{eventId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List tasks.
         * @param {string} folderId 
         * @param {ListFolderEventsSortEnum} [sort] 
         * @param {string} [objectKey] 
         * @param {string} [search] 
         * @param {ListFolderEventsIncludeTraceEnum} [includeTrace] 
         * @param {ListFolderEventsIncludeDebugEnum} [includeDebug] 
         * @param {ListFolderEventsIncludeInfoEnum} [includeInfo] 
         * @param {ListFolderEventsIncludeWarningEnum} [includeWarning] 
         * @param {ListFolderEventsIncludeErrorEnum} [includeError] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFolderEvents: async (folderId: string, sort?: ListFolderEventsSortEnum, objectKey?: string, search?: string, includeTrace?: ListFolderEventsIncludeTraceEnum, includeDebug?: ListFolderEventsIncludeDebugEnum, includeInfo?: ListFolderEventsIncludeInfoEnum, includeWarning?: ListFolderEventsIncludeWarningEnum, includeError?: ListFolderEventsIncludeErrorEnum, offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('listFolderEvents', 'folderId', folderId)
            const localVarPath = `/api/v1/folders/{folderId}/events`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (objectKey !== undefined) {
                localVarQueryParameter['objectKey'] = objectKey;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (includeTrace !== undefined) {
                localVarQueryParameter['includeTrace'] = includeTrace;
            }

            if (includeDebug !== undefined) {
                localVarQueryParameter['includeDebug'] = includeDebug;
            }

            if (includeInfo !== undefined) {
                localVarQueryParameter['includeInfo'] = includeInfo;
            }

            if (includeWarning !== undefined) {
                localVarQueryParameter['includeWarning'] = includeWarning;
            }

            if (includeError !== undefined) {
                localVarQueryParameter['includeError'] = includeError;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FolderEventsApi - functional programming interface
 * @export
 */
export const FolderEventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FolderEventsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a folder event by id.
         * @param {string} folderId 
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolderEvent(folderId: string, eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolderEvent(folderId, eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FolderEventsApi.getFolderEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List tasks.
         * @param {string} folderId 
         * @param {ListFolderEventsSortEnum} [sort] 
         * @param {string} [objectKey] 
         * @param {string} [search] 
         * @param {ListFolderEventsIncludeTraceEnum} [includeTrace] 
         * @param {ListFolderEventsIncludeDebugEnum} [includeDebug] 
         * @param {ListFolderEventsIncludeInfoEnum} [includeInfo] 
         * @param {ListFolderEventsIncludeWarningEnum} [includeWarning] 
         * @param {ListFolderEventsIncludeErrorEnum} [includeError] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFolderEvents(folderId: string, sort?: ListFolderEventsSortEnum, objectKey?: string, search?: string, includeTrace?: ListFolderEventsIncludeTraceEnum, includeDebug?: ListFolderEventsIncludeDebugEnum, includeInfo?: ListFolderEventsIncludeInfoEnum, includeWarning?: ListFolderEventsIncludeWarningEnum, includeError?: ListFolderEventsIncludeErrorEnum, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFolderEvents(folderId, sort, objectKey, search, includeTrace, includeDebug, includeInfo, includeWarning, includeError, offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FolderEventsApi.listFolderEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FolderEventsApi - factory interface
 * @export
 */
export const FolderEventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FolderEventsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a folder event by id.
         * @param {FolderEventsApiGetFolderEventRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderEvent(requestParameters: FolderEventsApiGetFolderEventRequest, options?: RawAxiosRequestConfig): AxiosPromise<EventGetResponse> {
            return localVarFp.getFolderEvent(requestParameters.folderId, requestParameters.eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List tasks.
         * @param {FolderEventsApiListFolderEventsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFolderEvents(requestParameters: FolderEventsApiListFolderEventsRequest, options?: RawAxiosRequestConfig): AxiosPromise<EventListResponse> {
            return localVarFp.listFolderEvents(requestParameters.folderId, requestParameters.sort, requestParameters.objectKey, requestParameters.search, requestParameters.includeTrace, requestParameters.includeDebug, requestParameters.includeInfo, requestParameters.includeWarning, requestParameters.includeError, requestParameters.offset, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getFolderEvent operation in FolderEventsApi.
 * @export
 * @interface FolderEventsApiGetFolderEventRequest
 */
export interface FolderEventsApiGetFolderEventRequest {
    /**
     * 
     * @type {string}
     * @memberof FolderEventsApiGetFolderEvent
     */
    readonly folderId: string

    /**
     * 
     * @type {string}
     * @memberof FolderEventsApiGetFolderEvent
     */
    readonly eventId: string
}

/**
 * Request parameters for listFolderEvents operation in FolderEventsApi.
 * @export
 * @interface FolderEventsApiListFolderEventsRequest
 */
export interface FolderEventsApiListFolderEventsRequest {
    /**
     * 
     * @type {string}
     * @memberof FolderEventsApiListFolderEvents
     */
    readonly folderId: string

    /**
     * 
     * @type {'createdAt-asc' | 'createdAt-desc' | 'updatedAt-asc' | 'updatedAt-desc'}
     * @memberof FolderEventsApiListFolderEvents
     */
    readonly sort?: ListFolderEventsSortEnum

    /**
     * 
     * @type {string}
     * @memberof FolderEventsApiListFolderEvents
     */
    readonly objectKey?: string

    /**
     * 
     * @type {string}
     * @memberof FolderEventsApiListFolderEvents
     */
    readonly search?: string

    /**
     * 
     * @type {'true'}
     * @memberof FolderEventsApiListFolderEvents
     */
    readonly includeTrace?: ListFolderEventsIncludeTraceEnum

    /**
     * 
     * @type {'true'}
     * @memberof FolderEventsApiListFolderEvents
     */
    readonly includeDebug?: ListFolderEventsIncludeDebugEnum

    /**
     * 
     * @type {'true'}
     * @memberof FolderEventsApiListFolderEvents
     */
    readonly includeInfo?: ListFolderEventsIncludeInfoEnum

    /**
     * 
     * @type {'true'}
     * @memberof FolderEventsApiListFolderEvents
     */
    readonly includeWarning?: ListFolderEventsIncludeWarningEnum

    /**
     * 
     * @type {'true'}
     * @memberof FolderEventsApiListFolderEvents
     */
    readonly includeError?: ListFolderEventsIncludeErrorEnum

    /**
     * 
     * @type {number}
     * @memberof FolderEventsApiListFolderEvents
     */
    readonly offset?: number

    /**
     * 
     * @type {number}
     * @memberof FolderEventsApiListFolderEvents
     */
    readonly limit?: number
}

/**
 * FolderEventsApi - object-oriented interface
 * @export
 * @class FolderEventsApi
 * @extends {BaseAPI}
 */
export class FolderEventsApi extends BaseAPI {
    /**
     * 
     * @summary Get a folder event by id.
     * @param {FolderEventsApiGetFolderEventRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FolderEventsApi
     */
    public getFolderEvent(requestParameters: FolderEventsApiGetFolderEventRequest, options?: RawAxiosRequestConfig) {
        return FolderEventsApiFp(this.configuration).getFolderEvent(requestParameters.folderId, requestParameters.eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List tasks.
     * @param {FolderEventsApiListFolderEventsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FolderEventsApi
     */
    public listFolderEvents(requestParameters: FolderEventsApiListFolderEventsRequest, options?: RawAxiosRequestConfig) {
        return FolderEventsApiFp(this.configuration).listFolderEvents(requestParameters.folderId, requestParameters.sort, requestParameters.objectKey, requestParameters.search, requestParameters.includeTrace, requestParameters.includeDebug, requestParameters.includeInfo, requestParameters.includeWarning, requestParameters.includeError, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListFolderEventsSortEnum = {
    CreatedAtAsc: 'createdAt-asc',
    CreatedAtDesc: 'createdAt-desc',
    UpdatedAtAsc: 'updatedAt-asc',
    UpdatedAtDesc: 'updatedAt-desc'
} as const;
export type ListFolderEventsSortEnum = typeof ListFolderEventsSortEnum[keyof typeof ListFolderEventsSortEnum];
/**
 * @export
 */
export const ListFolderEventsIncludeTraceEnum = {
    True: 'true'
} as const;
export type ListFolderEventsIncludeTraceEnum = typeof ListFolderEventsIncludeTraceEnum[keyof typeof ListFolderEventsIncludeTraceEnum];
/**
 * @export
 */
export const ListFolderEventsIncludeDebugEnum = {
    True: 'true'
} as const;
export type ListFolderEventsIncludeDebugEnum = typeof ListFolderEventsIncludeDebugEnum[keyof typeof ListFolderEventsIncludeDebugEnum];
/**
 * @export
 */
export const ListFolderEventsIncludeInfoEnum = {
    True: 'true'
} as const;
export type ListFolderEventsIncludeInfoEnum = typeof ListFolderEventsIncludeInfoEnum[keyof typeof ListFolderEventsIncludeInfoEnum];
/**
 * @export
 */
export const ListFolderEventsIncludeWarningEnum = {
    True: 'true'
} as const;
export type ListFolderEventsIncludeWarningEnum = typeof ListFolderEventsIncludeWarningEnum[keyof typeof ListFolderEventsIncludeWarningEnum];
/**
 * @export
 */
export const ListFolderEventsIncludeErrorEnum = {
    True: 'true'
} as const;
export type ListFolderEventsIncludeErrorEnum = typeof ListFolderEventsIncludeErrorEnum[keyof typeof ListFolderEventsIncludeErrorEnum];


/**
 * FoldersApi - axios parameter creator
 * @export
 */
export const FoldersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a folder.
         * @param {FolderCreateInputDTO} folderCreateInputDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolder: async (folderCreateInputDTO: FolderCreateInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderCreateInputDTO' is not null or undefined
            assertParamExists('createFolder', 'folderCreateInputDTO', folderCreateInputDTO)
            const localVarPath = `/api/v1/folders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(folderCreateInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create presigned urls for objects in a folder.
         * @param {string} folderId 
         * @param {Array<FolderCreateSignedUrlInputDTOInner>} folderCreateSignedUrlInputDTOInner 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPresignedUrls: async (folderId: string, folderCreateSignedUrlInputDTOInner: Array<FolderCreateSignedUrlInputDTOInner>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('createPresignedUrls', 'folderId', folderId)
            // verify required parameter 'folderCreateSignedUrlInputDTOInner' is not null or undefined
            assertParamExists('createPresignedUrls', 'folderCreateSignedUrlInputDTOInner', folderCreateSignedUrlInputDTOInner)
            const localVarPath = `/api/v1/folders/{folderId}/presigned-urls`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(folderCreateSignedUrlInputDTOInner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a folder by id.
         * @param {string} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolder: async (folderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('deleteFolder', 'folderId', folderId)
            const localVarPath = `/api/v1/folders/{folderId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a folder object by folderId and objectKey.
         * @param {string} folderId 
         * @param {string} objectKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolderObject: async (folderId: string, objectKey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('deleteFolderObject', 'folderId', folderId)
            // verify required parameter 'objectKey' is not null or undefined
            assertParamExists('deleteFolderObject', 'objectKey', objectKey)
            const localVarPath = `/api/v1/folders/{folderId}/objects/{objectKey}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
                .replace(`{${"objectKey"}}`, encodeURIComponent(String(objectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a folder by id.
         * @param {string} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolder: async (folderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('getFolder', 'folderId', folderId)
            const localVarPath = `/api/v1/folders/{folderId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the metadata for a folder by id.
         * @param {string} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderMetadata: async (folderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('getFolderMetadata', 'folderId', folderId)
            const localVarPath = `/api/v1/folders/{folderId}/metadata`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a folder object by folderId and objectKey.
         * @param {string} folderId 
         * @param {string} objectKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderObject: async (folderId: string, objectKey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('getFolderObject', 'folderId', folderId)
            // verify required parameter 'objectKey' is not null or undefined
            assertParamExists('getFolderObject', 'objectKey', objectKey)
            const localVarPath = `/api/v1/folders/{folderId}/objects/{objectKey}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
                .replace(`{${"objectKey"}}`, encodeURIComponent(String(objectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get folder share for a user
         * @param {string} folderId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderShares: async (folderId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('getFolderShares', 'folderId', folderId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getFolderShares', 'userId', userId)
            const localVarPath = `/api/v1/folders/{folderId}/shares/{userId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Handle app task trigger
         * @param {string} folderId 
         * @param {string} appIdentifier 
         * @param {string} taskKey 
         * @param {TriggerAppTaskInputDTO} triggerAppTaskInputDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleAppTaskTrigger: async (folderId: string, appIdentifier: string, taskKey: string, triggerAppTaskInputDTO: TriggerAppTaskInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('handleAppTaskTrigger', 'folderId', folderId)
            // verify required parameter 'appIdentifier' is not null or undefined
            assertParamExists('handleAppTaskTrigger', 'appIdentifier', appIdentifier)
            // verify required parameter 'taskKey' is not null or undefined
            assertParamExists('handleAppTaskTrigger', 'taskKey', taskKey)
            // verify required parameter 'triggerAppTaskInputDTO' is not null or undefined
            assertParamExists('handleAppTaskTrigger', 'triggerAppTaskInputDTO', triggerAppTaskInputDTO)
            const localVarPath = `/api/v1/folders/{folderId}/apps/{appIdentifier}/trigger/{taskKey}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
                .replace(`{${"appIdentifier"}}`, encodeURIComponent(String(appIdentifier)))
                .replace(`{${"taskKey"}}`, encodeURIComponent(String(taskKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(triggerAppTaskInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List folder objects by folderId.
         * @param {string} folderId 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [search] 
         * @param {ListFolderObjectsSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFolderObjects: async (folderId: string, offset?: number, limit?: number, search?: string, sort?: ListFolderObjectsSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('listFolderObjects', 'folderId', folderId)
            const localVarPath = `/api/v1/folders/{folderId}/objects`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List prospective folder share users
         * @param {string} folderId 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFolderShareUsers: async (folderId: string, offset?: number, limit?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('listFolderShareUsers', 'folderId', folderId)
            const localVarPath = `/api/v1/folders/{folderId}/user-share-options`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List folder shares
         * @param {string} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFolderShares: async (folderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('listFolderShares', 'folderId', folderId)
            const localVarPath = `/api/v1/folders/{folderId}/shares`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List folders.
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {ListFoldersSortEnum} [sort] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFolders: async (offset?: number, limit?: number, sort?: ListFoldersSortEnum, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/folders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Scan the object again in the underlying storage, and update its state in our db.
         * @param {string} folderId 
         * @param {string} objectKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshFolderObjectS3Metadata: async (folderId: string, objectKey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('refreshFolderObjectS3Metadata', 'folderId', folderId)
            // verify required parameter 'objectKey' is not null or undefined
            assertParamExists('refreshFolderObjectS3Metadata', 'objectKey', objectKey)
            const localVarPath = `/api/v1/folders/{folderId}/objects/{objectKey}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
                .replace(`{${"objectKey"}}`, encodeURIComponent(String(objectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Scan the underlying S3 location and update our local representation of it.
         * @param {string} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reindexFolder: async (folderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('reindexFolder', 'folderId', folderId)
            const localVarPath = `/api/v1/folders/{folderId}/reindex`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a folder share
         * @param {string} folderId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFolderShare: async (folderId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('removeFolderShare', 'folderId', folderId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('removeFolderShare', 'userId', userId)
            const localVarPath = `/api/v1/folders/{folderId}/shares/{userId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add or update a folder share
         * @param {string} folderId 
         * @param {string} userId 
         * @param {FolderShareCreateInputDTO} folderShareCreateInputDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertFolderShare: async (folderId: string, userId: string, folderShareCreateInputDTO: FolderShareCreateInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('upsertFolderShare', 'folderId', folderId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('upsertFolderShare', 'userId', userId)
            // verify required parameter 'folderShareCreateInputDTO' is not null or undefined
            assertParamExists('upsertFolderShare', 'folderShareCreateInputDTO', folderShareCreateInputDTO)
            const localVarPath = `/api/v1/folders/{folderId}/shares/{userId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(folderShareCreateInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FoldersApi - functional programming interface
 * @export
 */
export const FoldersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FoldersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a folder.
         * @param {FolderCreateInputDTO} folderCreateInputDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFolder(folderCreateInputDTO: FolderCreateInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFolder(folderCreateInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoldersApi.createFolder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create presigned urls for objects in a folder.
         * @param {string} folderId 
         * @param {Array<FolderCreateSignedUrlInputDTOInner>} folderCreateSignedUrlInputDTOInner 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPresignedUrls(folderId: string, folderCreateSignedUrlInputDTOInner: Array<FolderCreateSignedUrlInputDTOInner>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderCreateSignedUrlsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPresignedUrls(folderId, folderCreateSignedUrlInputDTOInner, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoldersApi.createPresignedUrls']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a folder by id.
         * @param {string} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFolder(folderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFolder(folderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoldersApi.deleteFolder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a folder object by folderId and objectKey.
         * @param {string} folderId 
         * @param {string} objectKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFolderObject(folderId: string, objectKey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFolderObject(folderId, objectKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoldersApi.deleteFolderObject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a folder by id.
         * @param {string} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolder(folderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolder(folderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoldersApi.getFolder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the metadata for a folder by id.
         * @param {string} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolderMetadata(folderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderGetMetadataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolderMetadata(folderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoldersApi.getFolderMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a folder object by folderId and objectKey.
         * @param {string} folderId 
         * @param {string} objectKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolderObject(folderId: string, objectKey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderObjectGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolderObject(folderId, objectKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoldersApi.getFolderObject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get folder share for a user
         * @param {string} folderId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolderShares(folderId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderShareGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolderShares(folderId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoldersApi.getFolderShares']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Handle app task trigger
         * @param {string} folderId 
         * @param {string} appIdentifier 
         * @param {string} taskKey 
         * @param {TriggerAppTaskInputDTO} triggerAppTaskInputDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleAppTaskTrigger(folderId: string, appIdentifier: string, taskKey: string, triggerAppTaskInputDTO: TriggerAppTaskInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleAppTaskTrigger(folderId, appIdentifier, taskKey, triggerAppTaskInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoldersApi.handleAppTaskTrigger']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List folder objects by folderId.
         * @param {string} folderId 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [search] 
         * @param {ListFolderObjectsSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFolderObjects(folderId: string, offset?: number, limit?: number, search?: string, sort?: ListFolderObjectsSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderObjectListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFolderObjects(folderId, offset, limit, search, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoldersApi.listFolderObjects']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List prospective folder share users
         * @param {string} folderId 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFolderShareUsers(folderId: string, offset?: number, limit?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderShareUserListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFolderShareUsers(folderId, offset, limit, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoldersApi.listFolderShareUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List folder shares
         * @param {string} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFolderShares(folderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderShareListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFolderShares(folderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoldersApi.listFolderShares']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List folders.
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {ListFoldersSortEnum} [sort] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFolders(offset?: number, limit?: number, sort?: ListFoldersSortEnum, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFolders(offset, limit, sort, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoldersApi.listFolders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Scan the object again in the underlying storage, and update its state in our db.
         * @param {string} folderId 
         * @param {string} objectKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshFolderObjectS3Metadata(folderId: string, objectKey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderObjectGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshFolderObjectS3Metadata(folderId, objectKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoldersApi.refreshFolderObjectS3Metadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Scan the underlying S3 location and update our local representation of it.
         * @param {string} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reindexFolder(folderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reindexFolder(folderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoldersApi.reindexFolder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove a folder share
         * @param {string} folderId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeFolderShare(folderId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeFolderShare(folderId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoldersApi.removeFolderShare']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add or update a folder share
         * @param {string} folderId 
         * @param {string} userId 
         * @param {FolderShareCreateInputDTO} folderShareCreateInputDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upsertFolderShare(folderId: string, userId: string, folderShareCreateInputDTO: FolderShareCreateInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderShareGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.upsertFolderShare(folderId, userId, folderShareCreateInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoldersApi.upsertFolderShare']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FoldersApi - factory interface
 * @export
 */
export const FoldersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FoldersApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a folder.
         * @param {FoldersApiCreateFolderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolder(requestParameters: FoldersApiCreateFolderRequest, options?: RawAxiosRequestConfig): AxiosPromise<FolderCreateResponse> {
            return localVarFp.createFolder(requestParameters.folderCreateInputDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create presigned urls for objects in a folder.
         * @param {FoldersApiCreatePresignedUrlsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPresignedUrls(requestParameters: FoldersApiCreatePresignedUrlsRequest, options?: RawAxiosRequestConfig): AxiosPromise<FolderCreateSignedUrlsResponse> {
            return localVarFp.createPresignedUrls(requestParameters.folderId, requestParameters.folderCreateSignedUrlInputDTOInner, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a folder by id.
         * @param {FoldersApiDeleteFolderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolder(requestParameters: FoldersApiDeleteFolderRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteFolder(requestParameters.folderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a folder object by folderId and objectKey.
         * @param {FoldersApiDeleteFolderObjectRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolderObject(requestParameters: FoldersApiDeleteFolderObjectRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteFolderObject(requestParameters.folderId, requestParameters.objectKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a folder by id.
         * @param {FoldersApiGetFolderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolder(requestParameters: FoldersApiGetFolderRequest, options?: RawAxiosRequestConfig): AxiosPromise<FolderGetResponse> {
            return localVarFp.getFolder(requestParameters.folderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the metadata for a folder by id.
         * @param {FoldersApiGetFolderMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderMetadata(requestParameters: FoldersApiGetFolderMetadataRequest, options?: RawAxiosRequestConfig): AxiosPromise<FolderGetMetadataResponse> {
            return localVarFp.getFolderMetadata(requestParameters.folderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a folder object by folderId and objectKey.
         * @param {FoldersApiGetFolderObjectRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderObject(requestParameters: FoldersApiGetFolderObjectRequest, options?: RawAxiosRequestConfig): AxiosPromise<FolderObjectGetResponse> {
            return localVarFp.getFolderObject(requestParameters.folderId, requestParameters.objectKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get folder share for a user
         * @param {FoldersApiGetFolderSharesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderShares(requestParameters: FoldersApiGetFolderSharesRequest, options?: RawAxiosRequestConfig): AxiosPromise<FolderShareGetResponse> {
            return localVarFp.getFolderShares(requestParameters.folderId, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Handle app task trigger
         * @param {FoldersApiHandleAppTaskTriggerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleAppTaskTrigger(requestParameters: FoldersApiHandleAppTaskTriggerRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.handleAppTaskTrigger(requestParameters.folderId, requestParameters.appIdentifier, requestParameters.taskKey, requestParameters.triggerAppTaskInputDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List folder objects by folderId.
         * @param {FoldersApiListFolderObjectsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFolderObjects(requestParameters: FoldersApiListFolderObjectsRequest, options?: RawAxiosRequestConfig): AxiosPromise<FolderObjectListResponse> {
            return localVarFp.listFolderObjects(requestParameters.folderId, requestParameters.offset, requestParameters.limit, requestParameters.search, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List prospective folder share users
         * @param {FoldersApiListFolderShareUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFolderShareUsers(requestParameters: FoldersApiListFolderShareUsersRequest, options?: RawAxiosRequestConfig): AxiosPromise<FolderShareUserListResponse> {
            return localVarFp.listFolderShareUsers(requestParameters.folderId, requestParameters.offset, requestParameters.limit, requestParameters.search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List folder shares
         * @param {FoldersApiListFolderSharesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFolderShares(requestParameters: FoldersApiListFolderSharesRequest, options?: RawAxiosRequestConfig): AxiosPromise<FolderShareListResponse> {
            return localVarFp.listFolderShares(requestParameters.folderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List folders.
         * @param {FoldersApiListFoldersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFolders(requestParameters: FoldersApiListFoldersRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<FolderListResponse> {
            return localVarFp.listFolders(requestParameters.offset, requestParameters.limit, requestParameters.sort, requestParameters.search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Scan the object again in the underlying storage, and update its state in our db.
         * @param {FoldersApiRefreshFolderObjectS3MetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshFolderObjectS3Metadata(requestParameters: FoldersApiRefreshFolderObjectS3MetadataRequest, options?: RawAxiosRequestConfig): AxiosPromise<FolderObjectGetResponse> {
            return localVarFp.refreshFolderObjectS3Metadata(requestParameters.folderId, requestParameters.objectKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Scan the underlying S3 location and update our local representation of it.
         * @param {FoldersApiReindexFolderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reindexFolder(requestParameters: FoldersApiReindexFolderRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.reindexFolder(requestParameters.folderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a folder share
         * @param {FoldersApiRemoveFolderShareRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFolderShare(requestParameters: FoldersApiRemoveFolderShareRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeFolderShare(requestParameters.folderId, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add or update a folder share
         * @param {FoldersApiUpsertFolderShareRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertFolderShare(requestParameters: FoldersApiUpsertFolderShareRequest, options?: RawAxiosRequestConfig): AxiosPromise<FolderShareGetResponse> {
            return localVarFp.upsertFolderShare(requestParameters.folderId, requestParameters.userId, requestParameters.folderShareCreateInputDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createFolder operation in FoldersApi.
 * @export
 * @interface FoldersApiCreateFolderRequest
 */
export interface FoldersApiCreateFolderRequest {
    /**
     * 
     * @type {FolderCreateInputDTO}
     * @memberof FoldersApiCreateFolder
     */
    readonly folderCreateInputDTO: FolderCreateInputDTO
}

/**
 * Request parameters for createPresignedUrls operation in FoldersApi.
 * @export
 * @interface FoldersApiCreatePresignedUrlsRequest
 */
export interface FoldersApiCreatePresignedUrlsRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiCreatePresignedUrls
     */
    readonly folderId: string

    /**
     * 
     * @type {Array<FolderCreateSignedUrlInputDTOInner>}
     * @memberof FoldersApiCreatePresignedUrls
     */
    readonly folderCreateSignedUrlInputDTOInner: Array<FolderCreateSignedUrlInputDTOInner>
}

/**
 * Request parameters for deleteFolder operation in FoldersApi.
 * @export
 * @interface FoldersApiDeleteFolderRequest
 */
export interface FoldersApiDeleteFolderRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiDeleteFolder
     */
    readonly folderId: string
}

/**
 * Request parameters for deleteFolderObject operation in FoldersApi.
 * @export
 * @interface FoldersApiDeleteFolderObjectRequest
 */
export interface FoldersApiDeleteFolderObjectRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiDeleteFolderObject
     */
    readonly folderId: string

    /**
     * 
     * @type {string}
     * @memberof FoldersApiDeleteFolderObject
     */
    readonly objectKey: string
}

/**
 * Request parameters for getFolder operation in FoldersApi.
 * @export
 * @interface FoldersApiGetFolderRequest
 */
export interface FoldersApiGetFolderRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiGetFolder
     */
    readonly folderId: string
}

/**
 * Request parameters for getFolderMetadata operation in FoldersApi.
 * @export
 * @interface FoldersApiGetFolderMetadataRequest
 */
export interface FoldersApiGetFolderMetadataRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiGetFolderMetadata
     */
    readonly folderId: string
}

/**
 * Request parameters for getFolderObject operation in FoldersApi.
 * @export
 * @interface FoldersApiGetFolderObjectRequest
 */
export interface FoldersApiGetFolderObjectRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiGetFolderObject
     */
    readonly folderId: string

    /**
     * 
     * @type {string}
     * @memberof FoldersApiGetFolderObject
     */
    readonly objectKey: string
}

/**
 * Request parameters for getFolderShares operation in FoldersApi.
 * @export
 * @interface FoldersApiGetFolderSharesRequest
 */
export interface FoldersApiGetFolderSharesRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiGetFolderShares
     */
    readonly folderId: string

    /**
     * 
     * @type {string}
     * @memberof FoldersApiGetFolderShares
     */
    readonly userId: string
}

/**
 * Request parameters for handleAppTaskTrigger operation in FoldersApi.
 * @export
 * @interface FoldersApiHandleAppTaskTriggerRequest
 */
export interface FoldersApiHandleAppTaskTriggerRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiHandleAppTaskTrigger
     */
    readonly folderId: string

    /**
     * 
     * @type {string}
     * @memberof FoldersApiHandleAppTaskTrigger
     */
    readonly appIdentifier: string

    /**
     * 
     * @type {string}
     * @memberof FoldersApiHandleAppTaskTrigger
     */
    readonly taskKey: string

    /**
     * 
     * @type {TriggerAppTaskInputDTO}
     * @memberof FoldersApiHandleAppTaskTrigger
     */
    readonly triggerAppTaskInputDTO: TriggerAppTaskInputDTO
}

/**
 * Request parameters for listFolderObjects operation in FoldersApi.
 * @export
 * @interface FoldersApiListFolderObjectsRequest
 */
export interface FoldersApiListFolderObjectsRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiListFolderObjects
     */
    readonly folderId: string

    /**
     * 
     * @type {number}
     * @memberof FoldersApiListFolderObjects
     */
    readonly offset?: number

    /**
     * 
     * @type {number}
     * @memberof FoldersApiListFolderObjects
     */
    readonly limit?: number

    /**
     * 
     * @type {string}
     * @memberof FoldersApiListFolderObjects
     */
    readonly search?: string

    /**
     * 
     * @type {'size-asc' | 'size-desc' | 'filename-asc' | 'filename-desc' | 'objectKey-asc' | 'objectKey-desc' | 'createdAt-asc' | 'createdAt-desc' | 'updatedAt-asc' | 'updatedAt-desc'}
     * @memberof FoldersApiListFolderObjects
     */
    readonly sort?: ListFolderObjectsSortEnum
}

/**
 * Request parameters for listFolderShareUsers operation in FoldersApi.
 * @export
 * @interface FoldersApiListFolderShareUsersRequest
 */
export interface FoldersApiListFolderShareUsersRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiListFolderShareUsers
     */
    readonly folderId: string

    /**
     * 
     * @type {number}
     * @memberof FoldersApiListFolderShareUsers
     */
    readonly offset?: number

    /**
     * 
     * @type {number}
     * @memberof FoldersApiListFolderShareUsers
     */
    readonly limit?: number

    /**
     * 
     * @type {string}
     * @memberof FoldersApiListFolderShareUsers
     */
    readonly search?: string
}

/**
 * Request parameters for listFolderShares operation in FoldersApi.
 * @export
 * @interface FoldersApiListFolderSharesRequest
 */
export interface FoldersApiListFolderSharesRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiListFolderShares
     */
    readonly folderId: string
}

/**
 * Request parameters for listFolders operation in FoldersApi.
 * @export
 * @interface FoldersApiListFoldersRequest
 */
export interface FoldersApiListFoldersRequest {
    /**
     * 
     * @type {number}
     * @memberof FoldersApiListFolders
     */
    readonly offset?: number

    /**
     * 
     * @type {number}
     * @memberof FoldersApiListFolders
     */
    readonly limit?: number

    /**
     * 
     * @type {'name-asc' | 'name-desc' | 'createdAt-asc' | 'createdAt-desc' | 'updatedAt-asc' | 'updatedAt-desc'}
     * @memberof FoldersApiListFolders
     */
    readonly sort?: ListFoldersSortEnum

    /**
     * 
     * @type {string}
     * @memberof FoldersApiListFolders
     */
    readonly search?: string
}

/**
 * Request parameters for refreshFolderObjectS3Metadata operation in FoldersApi.
 * @export
 * @interface FoldersApiRefreshFolderObjectS3MetadataRequest
 */
export interface FoldersApiRefreshFolderObjectS3MetadataRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiRefreshFolderObjectS3Metadata
     */
    readonly folderId: string

    /**
     * 
     * @type {string}
     * @memberof FoldersApiRefreshFolderObjectS3Metadata
     */
    readonly objectKey: string
}

/**
 * Request parameters for reindexFolder operation in FoldersApi.
 * @export
 * @interface FoldersApiReindexFolderRequest
 */
export interface FoldersApiReindexFolderRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiReindexFolder
     */
    readonly folderId: string
}

/**
 * Request parameters for removeFolderShare operation in FoldersApi.
 * @export
 * @interface FoldersApiRemoveFolderShareRequest
 */
export interface FoldersApiRemoveFolderShareRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiRemoveFolderShare
     */
    readonly folderId: string

    /**
     * 
     * @type {string}
     * @memberof FoldersApiRemoveFolderShare
     */
    readonly userId: string
}

/**
 * Request parameters for upsertFolderShare operation in FoldersApi.
 * @export
 * @interface FoldersApiUpsertFolderShareRequest
 */
export interface FoldersApiUpsertFolderShareRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiUpsertFolderShare
     */
    readonly folderId: string

    /**
     * 
     * @type {string}
     * @memberof FoldersApiUpsertFolderShare
     */
    readonly userId: string

    /**
     * 
     * @type {FolderShareCreateInputDTO}
     * @memberof FoldersApiUpsertFolderShare
     */
    readonly folderShareCreateInputDTO: FolderShareCreateInputDTO
}

/**
 * FoldersApi - object-oriented interface
 * @export
 * @class FoldersApi
 * @extends {BaseAPI}
 */
export class FoldersApi extends BaseAPI {
    /**
     * 
     * @summary Create a folder.
     * @param {FoldersApiCreateFolderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public createFolder(requestParameters: FoldersApiCreateFolderRequest, options?: RawAxiosRequestConfig) {
        return FoldersApiFp(this.configuration).createFolder(requestParameters.folderCreateInputDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create presigned urls for objects in a folder.
     * @param {FoldersApiCreatePresignedUrlsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public createPresignedUrls(requestParameters: FoldersApiCreatePresignedUrlsRequest, options?: RawAxiosRequestConfig) {
        return FoldersApiFp(this.configuration).createPresignedUrls(requestParameters.folderId, requestParameters.folderCreateSignedUrlInputDTOInner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a folder by id.
     * @param {FoldersApiDeleteFolderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public deleteFolder(requestParameters: FoldersApiDeleteFolderRequest, options?: RawAxiosRequestConfig) {
        return FoldersApiFp(this.configuration).deleteFolder(requestParameters.folderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a folder object by folderId and objectKey.
     * @param {FoldersApiDeleteFolderObjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public deleteFolderObject(requestParameters: FoldersApiDeleteFolderObjectRequest, options?: RawAxiosRequestConfig) {
        return FoldersApiFp(this.configuration).deleteFolderObject(requestParameters.folderId, requestParameters.objectKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a folder by id.
     * @param {FoldersApiGetFolderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public getFolder(requestParameters: FoldersApiGetFolderRequest, options?: RawAxiosRequestConfig) {
        return FoldersApiFp(this.configuration).getFolder(requestParameters.folderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the metadata for a folder by id.
     * @param {FoldersApiGetFolderMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public getFolderMetadata(requestParameters: FoldersApiGetFolderMetadataRequest, options?: RawAxiosRequestConfig) {
        return FoldersApiFp(this.configuration).getFolderMetadata(requestParameters.folderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a folder object by folderId and objectKey.
     * @param {FoldersApiGetFolderObjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public getFolderObject(requestParameters: FoldersApiGetFolderObjectRequest, options?: RawAxiosRequestConfig) {
        return FoldersApiFp(this.configuration).getFolderObject(requestParameters.folderId, requestParameters.objectKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get folder share for a user
     * @param {FoldersApiGetFolderSharesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public getFolderShares(requestParameters: FoldersApiGetFolderSharesRequest, options?: RawAxiosRequestConfig) {
        return FoldersApiFp(this.configuration).getFolderShares(requestParameters.folderId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Handle app task trigger
     * @param {FoldersApiHandleAppTaskTriggerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public handleAppTaskTrigger(requestParameters: FoldersApiHandleAppTaskTriggerRequest, options?: RawAxiosRequestConfig) {
        return FoldersApiFp(this.configuration).handleAppTaskTrigger(requestParameters.folderId, requestParameters.appIdentifier, requestParameters.taskKey, requestParameters.triggerAppTaskInputDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List folder objects by folderId.
     * @param {FoldersApiListFolderObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public listFolderObjects(requestParameters: FoldersApiListFolderObjectsRequest, options?: RawAxiosRequestConfig) {
        return FoldersApiFp(this.configuration).listFolderObjects(requestParameters.folderId, requestParameters.offset, requestParameters.limit, requestParameters.search, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List prospective folder share users
     * @param {FoldersApiListFolderShareUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public listFolderShareUsers(requestParameters: FoldersApiListFolderShareUsersRequest, options?: RawAxiosRequestConfig) {
        return FoldersApiFp(this.configuration).listFolderShareUsers(requestParameters.folderId, requestParameters.offset, requestParameters.limit, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List folder shares
     * @param {FoldersApiListFolderSharesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public listFolderShares(requestParameters: FoldersApiListFolderSharesRequest, options?: RawAxiosRequestConfig) {
        return FoldersApiFp(this.configuration).listFolderShares(requestParameters.folderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List folders.
     * @param {FoldersApiListFoldersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public listFolders(requestParameters: FoldersApiListFoldersRequest = {}, options?: RawAxiosRequestConfig) {
        return FoldersApiFp(this.configuration).listFolders(requestParameters.offset, requestParameters.limit, requestParameters.sort, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Scan the object again in the underlying storage, and update its state in our db.
     * @param {FoldersApiRefreshFolderObjectS3MetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public refreshFolderObjectS3Metadata(requestParameters: FoldersApiRefreshFolderObjectS3MetadataRequest, options?: RawAxiosRequestConfig) {
        return FoldersApiFp(this.configuration).refreshFolderObjectS3Metadata(requestParameters.folderId, requestParameters.objectKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Scan the underlying S3 location and update our local representation of it.
     * @param {FoldersApiReindexFolderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public reindexFolder(requestParameters: FoldersApiReindexFolderRequest, options?: RawAxiosRequestConfig) {
        return FoldersApiFp(this.configuration).reindexFolder(requestParameters.folderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a folder share
     * @param {FoldersApiRemoveFolderShareRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public removeFolderShare(requestParameters: FoldersApiRemoveFolderShareRequest, options?: RawAxiosRequestConfig) {
        return FoldersApiFp(this.configuration).removeFolderShare(requestParameters.folderId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add or update a folder share
     * @param {FoldersApiUpsertFolderShareRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public upsertFolderShare(requestParameters: FoldersApiUpsertFolderShareRequest, options?: RawAxiosRequestConfig) {
        return FoldersApiFp(this.configuration).upsertFolderShare(requestParameters.folderId, requestParameters.userId, requestParameters.folderShareCreateInputDTO, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListFolderObjectsSortEnum = {
    SizeAsc: 'size-asc',
    SizeDesc: 'size-desc',
    FilenameAsc: 'filename-asc',
    FilenameDesc: 'filename-desc',
    ObjectKeyAsc: 'objectKey-asc',
    ObjectKeyDesc: 'objectKey-desc',
    CreatedAtAsc: 'createdAt-asc',
    CreatedAtDesc: 'createdAt-desc',
    UpdatedAtAsc: 'updatedAt-asc',
    UpdatedAtDesc: 'updatedAt-desc'
} as const;
export type ListFolderObjectsSortEnum = typeof ListFolderObjectsSortEnum[keyof typeof ListFolderObjectsSortEnum];
/**
 * @export
 */
export const ListFoldersSortEnum = {
    NameAsc: 'name-asc',
    NameDesc: 'name-desc',
    CreatedAtAsc: 'createdAt-asc',
    CreatedAtDesc: 'createdAt-desc',
    UpdatedAtAsc: 'updatedAt-asc',
    UpdatedAtDesc: 'updatedAt-desc'
} as const;
export type ListFoldersSortEnum = typeof ListFoldersSortEnum[keyof typeof ListFoldersSortEnum];


/**
 * ServerApi - axios parameter creator
 * @export
 */
export const ServerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the server settings object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/server/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset a setting in the server settings objects.
         * @param {string} settingKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetServerSetting: async (settingKey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'settingKey' is not null or undefined
            assertParamExists('resetServerSetting', 'settingKey', settingKey)
            const localVarPath = `/api/v1/server/settings/{settingKey}`
                .replace(`{${"settingKey"}}`, encodeURIComponent(String(settingKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set a setting in the server settings objects.
         * @param {string} settingKey 
         * @param {SetSettingInputDTO} setSettingInputDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setServerSetting: async (settingKey: string, setSettingInputDTO: SetSettingInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'settingKey' is not null or undefined
            assertParamExists('setServerSetting', 'settingKey', settingKey)
            // verify required parameter 'setSettingInputDTO' is not null or undefined
            assertParamExists('setServerSetting', 'setSettingInputDTO', setSettingInputDTO)
            const localVarPath = `/api/v1/server/settings/{settingKey}`
                .replace(`{${"settingKey"}}`, encodeURIComponent(String(settingKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setSettingInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServerApi - functional programming interface
 * @export
 */
export const ServerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get the server settings object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SettingsGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServerApi.getServerSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Reset a setting in the server settings objects.
         * @param {string} settingKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetServerSetting(settingKey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SettingSetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetServerSetting(settingKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServerApi.resetServerSetting']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set a setting in the server settings objects.
         * @param {string} settingKey 
         * @param {SetSettingInputDTO} setSettingInputDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setServerSetting(settingKey: string, setSettingInputDTO: SetSettingInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SettingSetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setServerSetting(settingKey, setSettingInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServerApi.setServerSetting']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ServerApi - factory interface
 * @export
 */
export const ServerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServerApiFp(configuration)
    return {
        /**
         * 
         * @summary Get the server settings object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerSettings(options?: RawAxiosRequestConfig): AxiosPromise<SettingsGetResponse> {
            return localVarFp.getServerSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset a setting in the server settings objects.
         * @param {ServerApiResetServerSettingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetServerSetting(requestParameters: ServerApiResetServerSettingRequest, options?: RawAxiosRequestConfig): AxiosPromise<SettingSetResponse> {
            return localVarFp.resetServerSetting(requestParameters.settingKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set a setting in the server settings objects.
         * @param {ServerApiSetServerSettingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setServerSetting(requestParameters: ServerApiSetServerSettingRequest, options?: RawAxiosRequestConfig): AxiosPromise<SettingSetResponse> {
            return localVarFp.setServerSetting(requestParameters.settingKey, requestParameters.setSettingInputDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for resetServerSetting operation in ServerApi.
 * @export
 * @interface ServerApiResetServerSettingRequest
 */
export interface ServerApiResetServerSettingRequest {
    /**
     * 
     * @type {string}
     * @memberof ServerApiResetServerSetting
     */
    readonly settingKey: string
}

/**
 * Request parameters for setServerSetting operation in ServerApi.
 * @export
 * @interface ServerApiSetServerSettingRequest
 */
export interface ServerApiSetServerSettingRequest {
    /**
     * 
     * @type {string}
     * @memberof ServerApiSetServerSetting
     */
    readonly settingKey: string

    /**
     * 
     * @type {SetSettingInputDTO}
     * @memberof ServerApiSetServerSetting
     */
    readonly setSettingInputDTO: SetSettingInputDTO
}

/**
 * ServerApi - object-oriented interface
 * @export
 * @class ServerApi
 * @extends {BaseAPI}
 */
export class ServerApi extends BaseAPI {
    /**
     * 
     * @summary Get the server settings object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public getServerSettings(options?: RawAxiosRequestConfig) {
        return ServerApiFp(this.configuration).getServerSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset a setting in the server settings objects.
     * @param {ServerApiResetServerSettingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public resetServerSetting(requestParameters: ServerApiResetServerSettingRequest, options?: RawAxiosRequestConfig) {
        return ServerApiFp(this.configuration).resetServerSetting(requestParameters.settingKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set a setting in the server settings objects.
     * @param {ServerApiSetServerSettingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public setServerSetting(requestParameters: ServerApiSetServerSettingRequest, options?: RawAxiosRequestConfig) {
        return ServerApiFp(this.configuration).setServerSetting(requestParameters.settingKey, requestParameters.setSettingInputDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ServerAccessKeysApi - axios parameter creator
 * @export
 */
export const ServerAccessKeysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get server access key by id.
         * @param {string} accessKeyHashId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerAccessKey: async (accessKeyHashId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKeyHashId' is not null or undefined
            assertParamExists('getServerAccessKey', 'accessKeyHashId', accessKeyHashId)
            const localVarPath = `/api/v1/server/access-keys/{accessKeyHashId}`
                .replace(`{${"accessKeyHashId"}}`, encodeURIComponent(String(accessKeyHashId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List buckets for an access key.
         * @param {string} accessKeyHashId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServerAccessKeyBuckets: async (accessKeyHashId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKeyHashId' is not null or undefined
            assertParamExists('listServerAccessKeyBuckets', 'accessKeyHashId', accessKeyHashId)
            const localVarPath = `/api/v1/server/access-keys/{accessKeyHashId}/buckets`
                .replace(`{${"accessKeyHashId"}}`, encodeURIComponent(String(accessKeyHashId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List server access keys.
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {ListServerAccessKeysSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServerAccessKeys: async (offset?: number, limit?: number, sort?: ListServerAccessKeysSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/server/access-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Rotate a server access key.
         * @param {string} accessKeyHashId 
         * @param {RotateAccessKeyInputDTO} rotateAccessKeyInputDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rotateServerAccessKey: async (accessKeyHashId: string, rotateAccessKeyInputDTO: RotateAccessKeyInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessKeyHashId' is not null or undefined
            assertParamExists('rotateServerAccessKey', 'accessKeyHashId', accessKeyHashId)
            // verify required parameter 'rotateAccessKeyInputDTO' is not null or undefined
            assertParamExists('rotateServerAccessKey', 'rotateAccessKeyInputDTO', rotateAccessKeyInputDTO)
            const localVarPath = `/api/v1/server/access-keys/{accessKeyHashId}`
                .replace(`{${"accessKeyHashId"}}`, encodeURIComponent(String(accessKeyHashId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rotateAccessKeyInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServerAccessKeysApi - functional programming interface
 * @export
 */
export const ServerAccessKeysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServerAccessKeysApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get server access key by id.
         * @param {string} accessKeyHashId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerAccessKey(accessKeyHashId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessKeyGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerAccessKey(accessKeyHashId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServerAccessKeysApi.getServerAccessKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List buckets for an access key.
         * @param {string} accessKeyHashId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listServerAccessKeyBuckets(accessKeyHashId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessKeyBucketsListResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listServerAccessKeyBuckets(accessKeyHashId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServerAccessKeysApi.listServerAccessKeyBuckets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List server access keys.
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {ListServerAccessKeysSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listServerAccessKeys(offset?: number, limit?: number, sort?: ListServerAccessKeysSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessKeyListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listServerAccessKeys(offset, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServerAccessKeysApi.listServerAccessKeys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Rotate a server access key.
         * @param {string} accessKeyHashId 
         * @param {RotateAccessKeyInputDTO} rotateAccessKeyInputDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rotateServerAccessKey(accessKeyHashId: string, rotateAccessKeyInputDTO: RotateAccessKeyInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessKeyRotateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rotateServerAccessKey(accessKeyHashId, rotateAccessKeyInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServerAccessKeysApi.rotateServerAccessKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ServerAccessKeysApi - factory interface
 * @export
 */
export const ServerAccessKeysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServerAccessKeysApiFp(configuration)
    return {
        /**
         * 
         * @summary Get server access key by id.
         * @param {ServerAccessKeysApiGetServerAccessKeyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerAccessKey(requestParameters: ServerAccessKeysApiGetServerAccessKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccessKeyGetResponse> {
            return localVarFp.getServerAccessKey(requestParameters.accessKeyHashId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List buckets for an access key.
         * @param {ServerAccessKeysApiListServerAccessKeyBucketsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServerAccessKeyBuckets(requestParameters: ServerAccessKeysApiListServerAccessKeyBucketsRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccessKeyBucketsListResponseDTO> {
            return localVarFp.listServerAccessKeyBuckets(requestParameters.accessKeyHashId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List server access keys.
         * @param {ServerAccessKeysApiListServerAccessKeysRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServerAccessKeys(requestParameters: ServerAccessKeysApiListServerAccessKeysRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<AccessKeyListResponse> {
            return localVarFp.listServerAccessKeys(requestParameters.offset, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Rotate a server access key.
         * @param {ServerAccessKeysApiRotateServerAccessKeyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rotateServerAccessKey(requestParameters: ServerAccessKeysApiRotateServerAccessKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccessKeyRotateResponse> {
            return localVarFp.rotateServerAccessKey(requestParameters.accessKeyHashId, requestParameters.rotateAccessKeyInputDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getServerAccessKey operation in ServerAccessKeysApi.
 * @export
 * @interface ServerAccessKeysApiGetServerAccessKeyRequest
 */
export interface ServerAccessKeysApiGetServerAccessKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof ServerAccessKeysApiGetServerAccessKey
     */
    readonly accessKeyHashId: string
}

/**
 * Request parameters for listServerAccessKeyBuckets operation in ServerAccessKeysApi.
 * @export
 * @interface ServerAccessKeysApiListServerAccessKeyBucketsRequest
 */
export interface ServerAccessKeysApiListServerAccessKeyBucketsRequest {
    /**
     * 
     * @type {string}
     * @memberof ServerAccessKeysApiListServerAccessKeyBuckets
     */
    readonly accessKeyHashId: string
}

/**
 * Request parameters for listServerAccessKeys operation in ServerAccessKeysApi.
 * @export
 * @interface ServerAccessKeysApiListServerAccessKeysRequest
 */
export interface ServerAccessKeysApiListServerAccessKeysRequest {
    /**
     * 
     * @type {number}
     * @memberof ServerAccessKeysApiListServerAccessKeys
     */
    readonly offset?: number

    /**
     * 
     * @type {number}
     * @memberof ServerAccessKeysApiListServerAccessKeys
     */
    readonly limit?: number

    /**
     * 
     * @type {'accessKeyId-asc' | 'accessKeyId-desc' | 'accessKeyHashId-asc' | 'accessKeyHashId-desc' | 'endpoint-asc' | 'endpoint-desc' | 'region-asc' | 'region-desc' | 'updatedAt-asc' | 'updatedAt-desc'}
     * @memberof ServerAccessKeysApiListServerAccessKeys
     */
    readonly sort?: ListServerAccessKeysSortEnum
}

/**
 * Request parameters for rotateServerAccessKey operation in ServerAccessKeysApi.
 * @export
 * @interface ServerAccessKeysApiRotateServerAccessKeyRequest
 */
export interface ServerAccessKeysApiRotateServerAccessKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof ServerAccessKeysApiRotateServerAccessKey
     */
    readonly accessKeyHashId: string

    /**
     * 
     * @type {RotateAccessKeyInputDTO}
     * @memberof ServerAccessKeysApiRotateServerAccessKey
     */
    readonly rotateAccessKeyInputDTO: RotateAccessKeyInputDTO
}

/**
 * ServerAccessKeysApi - object-oriented interface
 * @export
 * @class ServerAccessKeysApi
 * @extends {BaseAPI}
 */
export class ServerAccessKeysApi extends BaseAPI {
    /**
     * 
     * @summary Get server access key by id.
     * @param {ServerAccessKeysApiGetServerAccessKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerAccessKeysApi
     */
    public getServerAccessKey(requestParameters: ServerAccessKeysApiGetServerAccessKeyRequest, options?: RawAxiosRequestConfig) {
        return ServerAccessKeysApiFp(this.configuration).getServerAccessKey(requestParameters.accessKeyHashId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List buckets for an access key.
     * @param {ServerAccessKeysApiListServerAccessKeyBucketsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerAccessKeysApi
     */
    public listServerAccessKeyBuckets(requestParameters: ServerAccessKeysApiListServerAccessKeyBucketsRequest, options?: RawAxiosRequestConfig) {
        return ServerAccessKeysApiFp(this.configuration).listServerAccessKeyBuckets(requestParameters.accessKeyHashId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List server access keys.
     * @param {ServerAccessKeysApiListServerAccessKeysRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerAccessKeysApi
     */
    public listServerAccessKeys(requestParameters: ServerAccessKeysApiListServerAccessKeysRequest = {}, options?: RawAxiosRequestConfig) {
        return ServerAccessKeysApiFp(this.configuration).listServerAccessKeys(requestParameters.offset, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Rotate a server access key.
     * @param {ServerAccessKeysApiRotateServerAccessKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerAccessKeysApi
     */
    public rotateServerAccessKey(requestParameters: ServerAccessKeysApiRotateServerAccessKeyRequest, options?: RawAxiosRequestConfig) {
        return ServerAccessKeysApiFp(this.configuration).rotateServerAccessKey(requestParameters.accessKeyHashId, requestParameters.rotateAccessKeyInputDTO, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListServerAccessKeysSortEnum = {
    AccessKeyIdAsc: 'accessKeyId-asc',
    AccessKeyIdDesc: 'accessKeyId-desc',
    AccessKeyHashIdAsc: 'accessKeyHashId-asc',
    AccessKeyHashIdDesc: 'accessKeyHashId-desc',
    EndpointAsc: 'endpoint-asc',
    EndpointDesc: 'endpoint-desc',
    RegionAsc: 'region-asc',
    RegionDesc: 'region-desc',
    UpdatedAtAsc: 'updatedAt-asc',
    UpdatedAtDesc: 'updatedAt-desc'
} as const;
export type ListServerAccessKeysSortEnum = typeof ListServerAccessKeysSortEnum[keyof typeof ListServerAccessKeysSortEnum];


/**
 * ServerEventsApi - axios parameter creator
 * @export
 */
export const ServerEventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get an event by id.
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEvent', 'eventId', eventId)
            const localVarPath = `/api/v1/server/events/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List events.
         * @param {ListEventsSortEnum} [sort] 
         * @param {string} [folderId] 
         * @param {string} [objectKey] 
         * @param {string} [search] 
         * @param {ListEventsIncludeTraceEnum} [includeTrace] 
         * @param {ListEventsIncludeDebugEnum} [includeDebug] 
         * @param {ListEventsIncludeInfoEnum} [includeInfo] 
         * @param {ListEventsIncludeWarningEnum} [includeWarning] 
         * @param {ListEventsIncludeErrorEnum} [includeError] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvents: async (sort?: ListEventsSortEnum, folderId?: string, objectKey?: string, search?: string, includeTrace?: ListEventsIncludeTraceEnum, includeDebug?: ListEventsIncludeDebugEnum, includeInfo?: ListEventsIncludeInfoEnum, includeWarning?: ListEventsIncludeWarningEnum, includeError?: ListEventsIncludeErrorEnum, offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/server/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (folderId !== undefined) {
                localVarQueryParameter['folderId'] = folderId;
            }

            if (objectKey !== undefined) {
                localVarQueryParameter['objectKey'] = objectKey;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (includeTrace !== undefined) {
                localVarQueryParameter['includeTrace'] = includeTrace;
            }

            if (includeDebug !== undefined) {
                localVarQueryParameter['includeDebug'] = includeDebug;
            }

            if (includeInfo !== undefined) {
                localVarQueryParameter['includeInfo'] = includeInfo;
            }

            if (includeWarning !== undefined) {
                localVarQueryParameter['includeWarning'] = includeWarning;
            }

            if (includeError !== undefined) {
                localVarQueryParameter['includeError'] = includeError;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServerEventsApi - functional programming interface
 * @export
 */
export const ServerEventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServerEventsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get an event by id.
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvent(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvent(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServerEventsApi.getEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List events.
         * @param {ListEventsSortEnum} [sort] 
         * @param {string} [folderId] 
         * @param {string} [objectKey] 
         * @param {string} [search] 
         * @param {ListEventsIncludeTraceEnum} [includeTrace] 
         * @param {ListEventsIncludeDebugEnum} [includeDebug] 
         * @param {ListEventsIncludeInfoEnum} [includeInfo] 
         * @param {ListEventsIncludeWarningEnum} [includeWarning] 
         * @param {ListEventsIncludeErrorEnum} [includeError] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEvents(sort?: ListEventsSortEnum, folderId?: string, objectKey?: string, search?: string, includeTrace?: ListEventsIncludeTraceEnum, includeDebug?: ListEventsIncludeDebugEnum, includeInfo?: ListEventsIncludeInfoEnum, includeWarning?: ListEventsIncludeWarningEnum, includeError?: ListEventsIncludeErrorEnum, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEvents(sort, folderId, objectKey, search, includeTrace, includeDebug, includeInfo, includeWarning, includeError, offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServerEventsApi.listEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ServerEventsApi - factory interface
 * @export
 */
export const ServerEventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServerEventsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get an event by id.
         * @param {ServerEventsApiGetEventRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent(requestParameters: ServerEventsApiGetEventRequest, options?: RawAxiosRequestConfig): AxiosPromise<EventGetResponse> {
            return localVarFp.getEvent(requestParameters.eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List events.
         * @param {ServerEventsApiListEventsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvents(requestParameters: ServerEventsApiListEventsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<EventListResponse> {
            return localVarFp.listEvents(requestParameters.sort, requestParameters.folderId, requestParameters.objectKey, requestParameters.search, requestParameters.includeTrace, requestParameters.includeDebug, requestParameters.includeInfo, requestParameters.includeWarning, requestParameters.includeError, requestParameters.offset, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getEvent operation in ServerEventsApi.
 * @export
 * @interface ServerEventsApiGetEventRequest
 */
export interface ServerEventsApiGetEventRequest {
    /**
     * 
     * @type {string}
     * @memberof ServerEventsApiGetEvent
     */
    readonly eventId: string
}

/**
 * Request parameters for listEvents operation in ServerEventsApi.
 * @export
 * @interface ServerEventsApiListEventsRequest
 */
export interface ServerEventsApiListEventsRequest {
    /**
     * 
     * @type {'createdAt-asc' | 'createdAt-desc' | 'updatedAt-asc' | 'updatedAt-desc'}
     * @memberof ServerEventsApiListEvents
     */
    readonly sort?: ListEventsSortEnum

    /**
     * 
     * @type {string}
     * @memberof ServerEventsApiListEvents
     */
    readonly folderId?: string

    /**
     * 
     * @type {string}
     * @memberof ServerEventsApiListEvents
     */
    readonly objectKey?: string

    /**
     * 
     * @type {string}
     * @memberof ServerEventsApiListEvents
     */
    readonly search?: string

    /**
     * 
     * @type {'true'}
     * @memberof ServerEventsApiListEvents
     */
    readonly includeTrace?: ListEventsIncludeTraceEnum

    /**
     * 
     * @type {'true'}
     * @memberof ServerEventsApiListEvents
     */
    readonly includeDebug?: ListEventsIncludeDebugEnum

    /**
     * 
     * @type {'true'}
     * @memberof ServerEventsApiListEvents
     */
    readonly includeInfo?: ListEventsIncludeInfoEnum

    /**
     * 
     * @type {'true'}
     * @memberof ServerEventsApiListEvents
     */
    readonly includeWarning?: ListEventsIncludeWarningEnum

    /**
     * 
     * @type {'true'}
     * @memberof ServerEventsApiListEvents
     */
    readonly includeError?: ListEventsIncludeErrorEnum

    /**
     * 
     * @type {number}
     * @memberof ServerEventsApiListEvents
     */
    readonly offset?: number

    /**
     * 
     * @type {number}
     * @memberof ServerEventsApiListEvents
     */
    readonly limit?: number
}

/**
 * ServerEventsApi - object-oriented interface
 * @export
 * @class ServerEventsApi
 * @extends {BaseAPI}
 */
export class ServerEventsApi extends BaseAPI {
    /**
     * 
     * @summary Get an event by id.
     * @param {ServerEventsApiGetEventRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerEventsApi
     */
    public getEvent(requestParameters: ServerEventsApiGetEventRequest, options?: RawAxiosRequestConfig) {
        return ServerEventsApiFp(this.configuration).getEvent(requestParameters.eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List events.
     * @param {ServerEventsApiListEventsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerEventsApi
     */
    public listEvents(requestParameters: ServerEventsApiListEventsRequest = {}, options?: RawAxiosRequestConfig) {
        return ServerEventsApiFp(this.configuration).listEvents(requestParameters.sort, requestParameters.folderId, requestParameters.objectKey, requestParameters.search, requestParameters.includeTrace, requestParameters.includeDebug, requestParameters.includeInfo, requestParameters.includeWarning, requestParameters.includeError, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListEventsSortEnum = {
    CreatedAtAsc: 'createdAt-asc',
    CreatedAtDesc: 'createdAt-desc',
    UpdatedAtAsc: 'updatedAt-asc',
    UpdatedAtDesc: 'updatedAt-desc'
} as const;
export type ListEventsSortEnum = typeof ListEventsSortEnum[keyof typeof ListEventsSortEnum];
/**
 * @export
 */
export const ListEventsIncludeTraceEnum = {
    True: 'true'
} as const;
export type ListEventsIncludeTraceEnum = typeof ListEventsIncludeTraceEnum[keyof typeof ListEventsIncludeTraceEnum];
/**
 * @export
 */
export const ListEventsIncludeDebugEnum = {
    True: 'true'
} as const;
export type ListEventsIncludeDebugEnum = typeof ListEventsIncludeDebugEnum[keyof typeof ListEventsIncludeDebugEnum];
/**
 * @export
 */
export const ListEventsIncludeInfoEnum = {
    True: 'true'
} as const;
export type ListEventsIncludeInfoEnum = typeof ListEventsIncludeInfoEnum[keyof typeof ListEventsIncludeInfoEnum];
/**
 * @export
 */
export const ListEventsIncludeWarningEnum = {
    True: 'true'
} as const;
export type ListEventsIncludeWarningEnum = typeof ListEventsIncludeWarningEnum[keyof typeof ListEventsIncludeWarningEnum];
/**
 * @export
 */
export const ListEventsIncludeErrorEnum = {
    True: 'true'
} as const;
export type ListEventsIncludeErrorEnum = typeof ListEventsIncludeErrorEnum[keyof typeof ListEventsIncludeErrorEnum];


/**
 * ServerStorageLocationApi - axios parameter creator
 * @export
 */
export const ServerStorageLocationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete any set server storage location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteServerStorageLocation: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/server/server-storage-location`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the server storage location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerStorageLocation: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/server/server-storage-location`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new server provision.
         * @param {ServerStorageLocationInputDTO} serverStorageLocationInputDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setServerStorageLocation: async (serverStorageLocationInputDTO: ServerStorageLocationInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverStorageLocationInputDTO' is not null or undefined
            assertParamExists('setServerStorageLocation', 'serverStorageLocationInputDTO', serverStorageLocationInputDTO)
            const localVarPath = `/api/v1/server/server-storage-location`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serverStorageLocationInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServerStorageLocationApi - functional programming interface
 * @export
 */
export const ServerStorageLocationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServerStorageLocationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete any set server storage location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteServerStorageLocation(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteServerStorageLocation(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServerStorageLocationApi.deleteServerStorageLocation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the server storage location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerStorageLocation(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerStorageLocationGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerStorageLocation(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServerStorageLocationApi.getServerStorageLocation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new server provision.
         * @param {ServerStorageLocationInputDTO} serverStorageLocationInputDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setServerStorageLocation(serverStorageLocationInputDTO: ServerStorageLocationInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerStorageLocationGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setServerStorageLocation(serverStorageLocationInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServerStorageLocationApi.setServerStorageLocation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ServerStorageLocationApi - factory interface
 * @export
 */
export const ServerStorageLocationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServerStorageLocationApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete any set server storage location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteServerStorageLocation(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteServerStorageLocation(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the server storage location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerStorageLocation(options?: RawAxiosRequestConfig): AxiosPromise<ServerStorageLocationGetResponse> {
            return localVarFp.getServerStorageLocation(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new server provision.
         * @param {ServerStorageLocationApiSetServerStorageLocationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setServerStorageLocation(requestParameters: ServerStorageLocationApiSetServerStorageLocationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ServerStorageLocationGetResponse> {
            return localVarFp.setServerStorageLocation(requestParameters.serverStorageLocationInputDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for setServerStorageLocation operation in ServerStorageLocationApi.
 * @export
 * @interface ServerStorageLocationApiSetServerStorageLocationRequest
 */
export interface ServerStorageLocationApiSetServerStorageLocationRequest {
    /**
     * 
     * @type {ServerStorageLocationInputDTO}
     * @memberof ServerStorageLocationApiSetServerStorageLocation
     */
    readonly serverStorageLocationInputDTO: ServerStorageLocationInputDTO
}

/**
 * ServerStorageLocationApi - object-oriented interface
 * @export
 * @class ServerStorageLocationApi
 * @extends {BaseAPI}
 */
export class ServerStorageLocationApi extends BaseAPI {
    /**
     * 
     * @summary Delete any set server storage location.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerStorageLocationApi
     */
    public deleteServerStorageLocation(options?: RawAxiosRequestConfig) {
        return ServerStorageLocationApiFp(this.configuration).deleteServerStorageLocation(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the server storage location.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerStorageLocationApi
     */
    public getServerStorageLocation(options?: RawAxiosRequestConfig) {
        return ServerStorageLocationApiFp(this.configuration).getServerStorageLocation(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new server provision.
     * @param {ServerStorageLocationApiSetServerStorageLocationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerStorageLocationApi
     */
    public setServerStorageLocation(requestParameters: ServerStorageLocationApiSetServerStorageLocationRequest, options?: RawAxiosRequestConfig) {
        return ServerStorageLocationApiFp(this.configuration).setServerStorageLocation(requestParameters.serverStorageLocationInputDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ServerTasksApi - axios parameter creator
 * @export
 */
export const ServerTasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a task by id.
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask: async (taskId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('getTask', 'taskId', taskId)
            const localVarPath = `/api/v1/server/tasks/{taskId}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List tasks.
         * @param {string} [objectKey] 
         * @param {ListTasksSortEnum} [sort] 
         * @param {string} [search] 
         * @param {ListTasksIncludeWaitingEnum} [includeWaiting] 
         * @param {ListTasksIncludeRunningEnum} [includeRunning] 
         * @param {ListTasksIncludeCompleteEnum} [includeComplete] 
         * @param {ListTasksIncludeFailedEnum} [includeFailed] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [folderId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTasks: async (objectKey?: string, sort?: ListTasksSortEnum, search?: string, includeWaiting?: ListTasksIncludeWaitingEnum, includeRunning?: ListTasksIncludeRunningEnum, includeComplete?: ListTasksIncludeCompleteEnum, includeFailed?: ListTasksIncludeFailedEnum, offset?: number, limit?: number, folderId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/server/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (objectKey !== undefined) {
                localVarQueryParameter['objectKey'] = objectKey;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (includeWaiting !== undefined) {
                localVarQueryParameter['includeWaiting'] = includeWaiting;
            }

            if (includeRunning !== undefined) {
                localVarQueryParameter['includeRunning'] = includeRunning;
            }

            if (includeComplete !== undefined) {
                localVarQueryParameter['includeComplete'] = includeComplete;
            }

            if (includeFailed !== undefined) {
                localVarQueryParameter['includeFailed'] = includeFailed;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (folderId !== undefined) {
                localVarQueryParameter['folderId'] = folderId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServerTasksApi - functional programming interface
 * @export
 */
export const ServerTasksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServerTasksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a task by id.
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTask(taskId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTask(taskId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServerTasksApi.getTask']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List tasks.
         * @param {string} [objectKey] 
         * @param {ListTasksSortEnum} [sort] 
         * @param {string} [search] 
         * @param {ListTasksIncludeWaitingEnum} [includeWaiting] 
         * @param {ListTasksIncludeRunningEnum} [includeRunning] 
         * @param {ListTasksIncludeCompleteEnum} [includeComplete] 
         * @param {ListTasksIncludeFailedEnum} [includeFailed] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [folderId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTasks(objectKey?: string, sort?: ListTasksSortEnum, search?: string, includeWaiting?: ListTasksIncludeWaitingEnum, includeRunning?: ListTasksIncludeRunningEnum, includeComplete?: ListTasksIncludeCompleteEnum, includeFailed?: ListTasksIncludeFailedEnum, offset?: number, limit?: number, folderId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTasks(objectKey, sort, search, includeWaiting, includeRunning, includeComplete, includeFailed, offset, limit, folderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServerTasksApi.listTasks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ServerTasksApi - factory interface
 * @export
 */
export const ServerTasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServerTasksApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a task by id.
         * @param {ServerTasksApiGetTaskRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask(requestParameters: ServerTasksApiGetTaskRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskGetResponse> {
            return localVarFp.getTask(requestParameters.taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List tasks.
         * @param {ServerTasksApiListTasksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTasks(requestParameters: ServerTasksApiListTasksRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<TaskListResponse> {
            return localVarFp.listTasks(requestParameters.objectKey, requestParameters.sort, requestParameters.search, requestParameters.includeWaiting, requestParameters.includeRunning, requestParameters.includeComplete, requestParameters.includeFailed, requestParameters.offset, requestParameters.limit, requestParameters.folderId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getTask operation in ServerTasksApi.
 * @export
 * @interface ServerTasksApiGetTaskRequest
 */
export interface ServerTasksApiGetTaskRequest {
    /**
     * 
     * @type {string}
     * @memberof ServerTasksApiGetTask
     */
    readonly taskId: string
}

/**
 * Request parameters for listTasks operation in ServerTasksApi.
 * @export
 * @interface ServerTasksApiListTasksRequest
 */
export interface ServerTasksApiListTasksRequest {
    /**
     * 
     * @type {string}
     * @memberof ServerTasksApiListTasks
     */
    readonly objectKey?: string

    /**
     * 
     * @type {'createdAt-asc' | 'createdAt-desc' | 'updatedAt-asc' | 'updatedAt-desc'}
     * @memberof ServerTasksApiListTasks
     */
    readonly sort?: ListTasksSortEnum

    /**
     * 
     * @type {string}
     * @memberof ServerTasksApiListTasks
     */
    readonly search?: string

    /**
     * 
     * @type {'true'}
     * @memberof ServerTasksApiListTasks
     */
    readonly includeWaiting?: ListTasksIncludeWaitingEnum

    /**
     * 
     * @type {'true'}
     * @memberof ServerTasksApiListTasks
     */
    readonly includeRunning?: ListTasksIncludeRunningEnum

    /**
     * 
     * @type {'true'}
     * @memberof ServerTasksApiListTasks
     */
    readonly includeComplete?: ListTasksIncludeCompleteEnum

    /**
     * 
     * @type {'true'}
     * @memberof ServerTasksApiListTasks
     */
    readonly includeFailed?: ListTasksIncludeFailedEnum

    /**
     * 
     * @type {number}
     * @memberof ServerTasksApiListTasks
     */
    readonly offset?: number

    /**
     * 
     * @type {number}
     * @memberof ServerTasksApiListTasks
     */
    readonly limit?: number

    /**
     * 
     * @type {string}
     * @memberof ServerTasksApiListTasks
     */
    readonly folderId?: string
}

/**
 * ServerTasksApi - object-oriented interface
 * @export
 * @class ServerTasksApi
 * @extends {BaseAPI}
 */
export class ServerTasksApi extends BaseAPI {
    /**
     * 
     * @summary Get a task by id.
     * @param {ServerTasksApiGetTaskRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerTasksApi
     */
    public getTask(requestParameters: ServerTasksApiGetTaskRequest, options?: RawAxiosRequestConfig) {
        return ServerTasksApiFp(this.configuration).getTask(requestParameters.taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List tasks.
     * @param {ServerTasksApiListTasksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerTasksApi
     */
    public listTasks(requestParameters: ServerTasksApiListTasksRequest = {}, options?: RawAxiosRequestConfig) {
        return ServerTasksApiFp(this.configuration).listTasks(requestParameters.objectKey, requestParameters.sort, requestParameters.search, requestParameters.includeWaiting, requestParameters.includeRunning, requestParameters.includeComplete, requestParameters.includeFailed, requestParameters.offset, requestParameters.limit, requestParameters.folderId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListTasksSortEnum = {
    CreatedAtAsc: 'createdAt-asc',
    CreatedAtDesc: 'createdAt-desc',
    UpdatedAtAsc: 'updatedAt-asc',
    UpdatedAtDesc: 'updatedAt-desc'
} as const;
export type ListTasksSortEnum = typeof ListTasksSortEnum[keyof typeof ListTasksSortEnum];
/**
 * @export
 */
export const ListTasksIncludeWaitingEnum = {
    True: 'true'
} as const;
export type ListTasksIncludeWaitingEnum = typeof ListTasksIncludeWaitingEnum[keyof typeof ListTasksIncludeWaitingEnum];
/**
 * @export
 */
export const ListTasksIncludeRunningEnum = {
    True: 'true'
} as const;
export type ListTasksIncludeRunningEnum = typeof ListTasksIncludeRunningEnum[keyof typeof ListTasksIncludeRunningEnum];
/**
 * @export
 */
export const ListTasksIncludeCompleteEnum = {
    True: 'true'
} as const;
export type ListTasksIncludeCompleteEnum = typeof ListTasksIncludeCompleteEnum[keyof typeof ListTasksIncludeCompleteEnum];
/**
 * @export
 */
export const ListTasksIncludeFailedEnum = {
    True: 'true'
} as const;
export type ListTasksIncludeFailedEnum = typeof ListTasksIncludeFailedEnum[keyof typeof ListTasksIncludeFailedEnum];


/**
 * TasksApi - axios parameter creator
 * @export
 */
export const TasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a folder task by id.
         * @param {string} folderId 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderTask: async (folderId: string, taskId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('getFolderTask', 'folderId', folderId)
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('getFolderTask', 'taskId', taskId)
            const localVarPath = `/api/v1/folders/{folderId}/tasks/{taskId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List tasks.
         * @param {string} folderId 
         * @param {string} [objectKey] 
         * @param {ListFolderTasksSortEnum} [sort] 
         * @param {string} [search] 
         * @param {ListFolderTasksIncludeWaitingEnum} [includeWaiting] 
         * @param {ListFolderTasksIncludeRunningEnum} [includeRunning] 
         * @param {ListFolderTasksIncludeCompleteEnum} [includeComplete] 
         * @param {ListFolderTasksIncludeFailedEnum} [includeFailed] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFolderTasks: async (folderId: string, objectKey?: string, sort?: ListFolderTasksSortEnum, search?: string, includeWaiting?: ListFolderTasksIncludeWaitingEnum, includeRunning?: ListFolderTasksIncludeRunningEnum, includeComplete?: ListFolderTasksIncludeCompleteEnum, includeFailed?: ListFolderTasksIncludeFailedEnum, offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('listFolderTasks', 'folderId', folderId)
            const localVarPath = `/api/v1/folders/{folderId}/tasks`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (objectKey !== undefined) {
                localVarQueryParameter['objectKey'] = objectKey;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (includeWaiting !== undefined) {
                localVarQueryParameter['includeWaiting'] = includeWaiting;
            }

            if (includeRunning !== undefined) {
                localVarQueryParameter['includeRunning'] = includeRunning;
            }

            if (includeComplete !== undefined) {
                localVarQueryParameter['includeComplete'] = includeComplete;
            }

            if (includeFailed !== undefined) {
                localVarQueryParameter['includeFailed'] = includeFailed;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TasksApi - functional programming interface
 * @export
 */
export const TasksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TasksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a folder task by id.
         * @param {string} folderId 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolderTask(folderId: string, taskId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolderTask(folderId, taskId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.getFolderTask']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List tasks.
         * @param {string} folderId 
         * @param {string} [objectKey] 
         * @param {ListFolderTasksSortEnum} [sort] 
         * @param {string} [search] 
         * @param {ListFolderTasksIncludeWaitingEnum} [includeWaiting] 
         * @param {ListFolderTasksIncludeRunningEnum} [includeRunning] 
         * @param {ListFolderTasksIncludeCompleteEnum} [includeComplete] 
         * @param {ListFolderTasksIncludeFailedEnum} [includeFailed] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFolderTasks(folderId: string, objectKey?: string, sort?: ListFolderTasksSortEnum, search?: string, includeWaiting?: ListFolderTasksIncludeWaitingEnum, includeRunning?: ListFolderTasksIncludeRunningEnum, includeComplete?: ListFolderTasksIncludeCompleteEnum, includeFailed?: ListFolderTasksIncludeFailedEnum, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFolderTasks(folderId, objectKey, sort, search, includeWaiting, includeRunning, includeComplete, includeFailed, offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.listFolderTasks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TasksApi - factory interface
 * @export
 */
export const TasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TasksApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a folder task by id.
         * @param {TasksApiGetFolderTaskRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderTask(requestParameters: TasksApiGetFolderTaskRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskGetResponse> {
            return localVarFp.getFolderTask(requestParameters.folderId, requestParameters.taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List tasks.
         * @param {TasksApiListFolderTasksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFolderTasks(requestParameters: TasksApiListFolderTasksRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskListResponse> {
            return localVarFp.listFolderTasks(requestParameters.folderId, requestParameters.objectKey, requestParameters.sort, requestParameters.search, requestParameters.includeWaiting, requestParameters.includeRunning, requestParameters.includeComplete, requestParameters.includeFailed, requestParameters.offset, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getFolderTask operation in TasksApi.
 * @export
 * @interface TasksApiGetFolderTaskRequest
 */
export interface TasksApiGetFolderTaskRequest {
    /**
     * 
     * @type {string}
     * @memberof TasksApiGetFolderTask
     */
    readonly folderId: string

    /**
     * 
     * @type {string}
     * @memberof TasksApiGetFolderTask
     */
    readonly taskId: string
}

/**
 * Request parameters for listFolderTasks operation in TasksApi.
 * @export
 * @interface TasksApiListFolderTasksRequest
 */
export interface TasksApiListFolderTasksRequest {
    /**
     * 
     * @type {string}
     * @memberof TasksApiListFolderTasks
     */
    readonly folderId: string

    /**
     * 
     * @type {string}
     * @memberof TasksApiListFolderTasks
     */
    readonly objectKey?: string

    /**
     * 
     * @type {'createdAt-asc' | 'createdAt-desc' | 'updatedAt-asc' | 'updatedAt-desc'}
     * @memberof TasksApiListFolderTasks
     */
    readonly sort?: ListFolderTasksSortEnum

    /**
     * 
     * @type {string}
     * @memberof TasksApiListFolderTasks
     */
    readonly search?: string

    /**
     * 
     * @type {'true'}
     * @memberof TasksApiListFolderTasks
     */
    readonly includeWaiting?: ListFolderTasksIncludeWaitingEnum

    /**
     * 
     * @type {'true'}
     * @memberof TasksApiListFolderTasks
     */
    readonly includeRunning?: ListFolderTasksIncludeRunningEnum

    /**
     * 
     * @type {'true'}
     * @memberof TasksApiListFolderTasks
     */
    readonly includeComplete?: ListFolderTasksIncludeCompleteEnum

    /**
     * 
     * @type {'true'}
     * @memberof TasksApiListFolderTasks
     */
    readonly includeFailed?: ListFolderTasksIncludeFailedEnum

    /**
     * 
     * @type {number}
     * @memberof TasksApiListFolderTasks
     */
    readonly offset?: number

    /**
     * 
     * @type {number}
     * @memberof TasksApiListFolderTasks
     */
    readonly limit?: number
}

/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
export class TasksApi extends BaseAPI {
    /**
     * 
     * @summary Get a folder task by id.
     * @param {TasksApiGetFolderTaskRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getFolderTask(requestParameters: TasksApiGetFolderTaskRequest, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).getFolderTask(requestParameters.folderId, requestParameters.taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List tasks.
     * @param {TasksApiListFolderTasksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public listFolderTasks(requestParameters: TasksApiListFolderTasksRequest, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).listFolderTasks(requestParameters.folderId, requestParameters.objectKey, requestParameters.sort, requestParameters.search, requestParameters.includeWaiting, requestParameters.includeRunning, requestParameters.includeComplete, requestParameters.includeFailed, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListFolderTasksSortEnum = {
    CreatedAtAsc: 'createdAt-asc',
    CreatedAtDesc: 'createdAt-desc',
    UpdatedAtAsc: 'updatedAt-asc',
    UpdatedAtDesc: 'updatedAt-desc'
} as const;
export type ListFolderTasksSortEnum = typeof ListFolderTasksSortEnum[keyof typeof ListFolderTasksSortEnum];
/**
 * @export
 */
export const ListFolderTasksIncludeWaitingEnum = {
    True: 'true'
} as const;
export type ListFolderTasksIncludeWaitingEnum = typeof ListFolderTasksIncludeWaitingEnum[keyof typeof ListFolderTasksIncludeWaitingEnum];
/**
 * @export
 */
export const ListFolderTasksIncludeRunningEnum = {
    True: 'true'
} as const;
export type ListFolderTasksIncludeRunningEnum = typeof ListFolderTasksIncludeRunningEnum[keyof typeof ListFolderTasksIncludeRunningEnum];
/**
 * @export
 */
export const ListFolderTasksIncludeCompleteEnum = {
    True: 'true'
} as const;
export type ListFolderTasksIncludeCompleteEnum = typeof ListFolderTasksIncludeCompleteEnum[keyof typeof ListFolderTasksIncludeCompleteEnum];
/**
 * @export
 */
export const ListFolderTasksIncludeFailedEnum = {
    True: 'true'
} as const;
export type ListFolderTasksIncludeFailedEnum = typeof ListFolderTasksIncludeFailedEnum[keyof typeof ListFolderTasksIncludeFailedEnum];


/**
 * UserStorageProvisionsApi - axios parameter creator
 * @export
 */
export const UserStorageProvisionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new user storage provision.
         * @param {UserStorageProvisionInputDTO} userStorageProvisionInputDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserStorageProvision: async (userStorageProvisionInputDTO: UserStorageProvisionInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userStorageProvisionInputDTO' is not null or undefined
            assertParamExists('createUserStorageProvision', 'userStorageProvisionInputDTO', userStorageProvisionInputDTO)
            const localVarPath = `/api/v1/server/user-storage-provisions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userStorageProvisionInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a server provision by id.
         * @param {string} userStorageProvisionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserStorageProvision: async (userStorageProvisionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userStorageProvisionId' is not null or undefined
            assertParamExists('deleteUserStorageProvision', 'userStorageProvisionId', userStorageProvisionId)
            const localVarPath = `/api/v1/server/user-storage-provisions/{userStorageProvisionId}`
                .replace(`{${"userStorageProvisionId"}}`, encodeURIComponent(String(userStorageProvisionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user storage provision by id.
         * @param {string} userStorageProvisionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserStorageProvision: async (userStorageProvisionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userStorageProvisionId' is not null or undefined
            assertParamExists('getUserStorageProvision', 'userStorageProvisionId', userStorageProvisionId)
            const localVarPath = `/api/v1/server/user-storage-provisions/{userStorageProvisionId}`
                .replace(`{${"userStorageProvisionId"}}`, encodeURIComponent(String(userStorageProvisionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the user storage provisions.
         * @param {ListUserStorageProvisionsProvisionTypeEnum} [provisionType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserStorageProvisions: async (provisionType?: ListUserStorageProvisionsProvisionTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/server/user-storage-provisions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (provisionType !== undefined) {
                localVarQueryParameter['provisionType'] = provisionType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a server provision by id.
         * @param {string} userStorageProvisionId 
         * @param {UserStorageProvisionInputDTO} userStorageProvisionInputDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserStorageProvision: async (userStorageProvisionId: string, userStorageProvisionInputDTO: UserStorageProvisionInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userStorageProvisionId' is not null or undefined
            assertParamExists('updateUserStorageProvision', 'userStorageProvisionId', userStorageProvisionId)
            // verify required parameter 'userStorageProvisionInputDTO' is not null or undefined
            assertParamExists('updateUserStorageProvision', 'userStorageProvisionInputDTO', userStorageProvisionInputDTO)
            const localVarPath = `/api/v1/server/user-storage-provisions/{userStorageProvisionId}`
                .replace(`{${"userStorageProvisionId"}}`, encodeURIComponent(String(userStorageProvisionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userStorageProvisionInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserStorageProvisionsApi - functional programming interface
 * @export
 */
export const UserStorageProvisionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserStorageProvisionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new user storage provision.
         * @param {UserStorageProvisionInputDTO} userStorageProvisionInputDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserStorageProvision(userStorageProvisionInputDTO: UserStorageProvisionInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserStorageProvisionListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserStorageProvision(userStorageProvisionInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserStorageProvisionsApi.createUserStorageProvision']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a server provision by id.
         * @param {string} userStorageProvisionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserStorageProvision(userStorageProvisionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserStorageProvisionListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserStorageProvision(userStorageProvisionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserStorageProvisionsApi.deleteUserStorageProvision']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a user storage provision by id.
         * @param {string} userStorageProvisionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserStorageProvision(userStorageProvisionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserStorageProvisionGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserStorageProvision(userStorageProvisionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserStorageProvisionsApi.getUserStorageProvision']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List the user storage provisions.
         * @param {ListUserStorageProvisionsProvisionTypeEnum} [provisionType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserStorageProvisions(provisionType?: ListUserStorageProvisionsProvisionTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserStorageProvisionListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserStorageProvisions(provisionType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserStorageProvisionsApi.listUserStorageProvisions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a server provision by id.
         * @param {string} userStorageProvisionId 
         * @param {UserStorageProvisionInputDTO} userStorageProvisionInputDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserStorageProvision(userStorageProvisionId: string, userStorageProvisionInputDTO: UserStorageProvisionInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserStorageProvisionListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserStorageProvision(userStorageProvisionId, userStorageProvisionInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserStorageProvisionsApi.updateUserStorageProvision']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserStorageProvisionsApi - factory interface
 * @export
 */
export const UserStorageProvisionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserStorageProvisionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new user storage provision.
         * @param {UserStorageProvisionsApiCreateUserStorageProvisionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserStorageProvision(requestParameters: UserStorageProvisionsApiCreateUserStorageProvisionRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserStorageProvisionListResponse> {
            return localVarFp.createUserStorageProvision(requestParameters.userStorageProvisionInputDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a server provision by id.
         * @param {UserStorageProvisionsApiDeleteUserStorageProvisionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserStorageProvision(requestParameters: UserStorageProvisionsApiDeleteUserStorageProvisionRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserStorageProvisionListResponse> {
            return localVarFp.deleteUserStorageProvision(requestParameters.userStorageProvisionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user storage provision by id.
         * @param {UserStorageProvisionsApiGetUserStorageProvisionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserStorageProvision(requestParameters: UserStorageProvisionsApiGetUserStorageProvisionRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserStorageProvisionGetResponse> {
            return localVarFp.getUserStorageProvision(requestParameters.userStorageProvisionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the user storage provisions.
         * @param {UserStorageProvisionsApiListUserStorageProvisionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserStorageProvisions(requestParameters: UserStorageProvisionsApiListUserStorageProvisionsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<UserStorageProvisionListResponse> {
            return localVarFp.listUserStorageProvisions(requestParameters.provisionType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a server provision by id.
         * @param {UserStorageProvisionsApiUpdateUserStorageProvisionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserStorageProvision(requestParameters: UserStorageProvisionsApiUpdateUserStorageProvisionRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserStorageProvisionListResponse> {
            return localVarFp.updateUserStorageProvision(requestParameters.userStorageProvisionId, requestParameters.userStorageProvisionInputDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createUserStorageProvision operation in UserStorageProvisionsApi.
 * @export
 * @interface UserStorageProvisionsApiCreateUserStorageProvisionRequest
 */
export interface UserStorageProvisionsApiCreateUserStorageProvisionRequest {
    /**
     * 
     * @type {UserStorageProvisionInputDTO}
     * @memberof UserStorageProvisionsApiCreateUserStorageProvision
     */
    readonly userStorageProvisionInputDTO: UserStorageProvisionInputDTO
}

/**
 * Request parameters for deleteUserStorageProvision operation in UserStorageProvisionsApi.
 * @export
 * @interface UserStorageProvisionsApiDeleteUserStorageProvisionRequest
 */
export interface UserStorageProvisionsApiDeleteUserStorageProvisionRequest {
    /**
     * 
     * @type {string}
     * @memberof UserStorageProvisionsApiDeleteUserStorageProvision
     */
    readonly userStorageProvisionId: string
}

/**
 * Request parameters for getUserStorageProvision operation in UserStorageProvisionsApi.
 * @export
 * @interface UserStorageProvisionsApiGetUserStorageProvisionRequest
 */
export interface UserStorageProvisionsApiGetUserStorageProvisionRequest {
    /**
     * 
     * @type {string}
     * @memberof UserStorageProvisionsApiGetUserStorageProvision
     */
    readonly userStorageProvisionId: string
}

/**
 * Request parameters for listUserStorageProvisions operation in UserStorageProvisionsApi.
 * @export
 * @interface UserStorageProvisionsApiListUserStorageProvisionsRequest
 */
export interface UserStorageProvisionsApiListUserStorageProvisionsRequest {
    /**
     * 
     * @type {'CONTENT' | 'METADATA' | 'REDUNDANCY'}
     * @memberof UserStorageProvisionsApiListUserStorageProvisions
     */
    readonly provisionType?: ListUserStorageProvisionsProvisionTypeEnum
}

/**
 * Request parameters for updateUserStorageProvision operation in UserStorageProvisionsApi.
 * @export
 * @interface UserStorageProvisionsApiUpdateUserStorageProvisionRequest
 */
export interface UserStorageProvisionsApiUpdateUserStorageProvisionRequest {
    /**
     * 
     * @type {string}
     * @memberof UserStorageProvisionsApiUpdateUserStorageProvision
     */
    readonly userStorageProvisionId: string

    /**
     * 
     * @type {UserStorageProvisionInputDTO}
     * @memberof UserStorageProvisionsApiUpdateUserStorageProvision
     */
    readonly userStorageProvisionInputDTO: UserStorageProvisionInputDTO
}

/**
 * UserStorageProvisionsApi - object-oriented interface
 * @export
 * @class UserStorageProvisionsApi
 * @extends {BaseAPI}
 */
export class UserStorageProvisionsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new user storage provision.
     * @param {UserStorageProvisionsApiCreateUserStorageProvisionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserStorageProvisionsApi
     */
    public createUserStorageProvision(requestParameters: UserStorageProvisionsApiCreateUserStorageProvisionRequest, options?: RawAxiosRequestConfig) {
        return UserStorageProvisionsApiFp(this.configuration).createUserStorageProvision(requestParameters.userStorageProvisionInputDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a server provision by id.
     * @param {UserStorageProvisionsApiDeleteUserStorageProvisionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserStorageProvisionsApi
     */
    public deleteUserStorageProvision(requestParameters: UserStorageProvisionsApiDeleteUserStorageProvisionRequest, options?: RawAxiosRequestConfig) {
        return UserStorageProvisionsApiFp(this.configuration).deleteUserStorageProvision(requestParameters.userStorageProvisionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user storage provision by id.
     * @param {UserStorageProvisionsApiGetUserStorageProvisionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserStorageProvisionsApi
     */
    public getUserStorageProvision(requestParameters: UserStorageProvisionsApiGetUserStorageProvisionRequest, options?: RawAxiosRequestConfig) {
        return UserStorageProvisionsApiFp(this.configuration).getUserStorageProvision(requestParameters.userStorageProvisionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the user storage provisions.
     * @param {UserStorageProvisionsApiListUserStorageProvisionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserStorageProvisionsApi
     */
    public listUserStorageProvisions(requestParameters: UserStorageProvisionsApiListUserStorageProvisionsRequest = {}, options?: RawAxiosRequestConfig) {
        return UserStorageProvisionsApiFp(this.configuration).listUserStorageProvisions(requestParameters.provisionType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a server provision by id.
     * @param {UserStorageProvisionsApiUpdateUserStorageProvisionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserStorageProvisionsApi
     */
    public updateUserStorageProvision(requestParameters: UserStorageProvisionsApiUpdateUserStorageProvisionRequest, options?: RawAxiosRequestConfig) {
        return UserStorageProvisionsApiFp(this.configuration).updateUserStorageProvision(requestParameters.userStorageProvisionId, requestParameters.userStorageProvisionInputDTO, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListUserStorageProvisionsProvisionTypeEnum = {
    Content: 'CONTENT',
    Metadata: 'METADATA',
    Redundancy: 'REDUNDANCY'
} as const;
export type ListUserStorageProvisionsProvisionTypeEnum = typeof ListUserStorageProvisionsProvisionTypeEnum[keyof typeof ListUserStorageProvisionsProvisionTypeEnum];


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a user.
         * @param {UserCreateInputDTO} userCreateInputDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (userCreateInputDTO: UserCreateInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreateInputDTO' is not null or undefined
            assertParamExists('createUser', 'userCreateInputDTO', userCreateInputDTO)
            const localVarPath = `/api/v1/server/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreateInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a server user by id.
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUser', 'userId', userId)
            const localVarPath = `/api/v1/server/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user by id.
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUser', 'userId', userId)
            const localVarPath = `/api/v1/server/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActiveUserSessions: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listActiveUserSessions', 'userId', userId)
            const localVarPath = `/api/v1/server/users/{userId}/sessions`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the users.
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {boolean} [isAdmin] 
         * @param {ListUsersSortEnum} [sort] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers: async (offset?: number, limit?: number, isAdmin?: boolean, sort?: ListUsersSortEnum, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/server/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (isAdmin !== undefined) {
                localVarQueryParameter['isAdmin'] = isAdmin;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a user.
         * @param {string} userId 
         * @param {UserUpdateInputDTO} userUpdateInputDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (userId: string, userUpdateInputDTO: UserUpdateInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUser', 'userId', userId)
            // verify required parameter 'userUpdateInputDTO' is not null or undefined
            assertParamExists('updateUser', 'userUpdateInputDTO', userUpdateInputDTO)
            const localVarPath = `/api/v1/server/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdateInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a user.
         * @param {UserCreateInputDTO} userCreateInputDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(userCreateInputDTO: UserCreateInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(userCreateInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.createUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a server user by id.
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.deleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a user by id.
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listActiveUserSessions(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSessionListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listActiveUserSessions(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.listActiveUserSessions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List the users.
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {boolean} [isAdmin] 
         * @param {ListUsersSortEnum} [sort] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsers(offset?: number, limit?: number, isAdmin?: boolean, sort?: ListUsersSortEnum, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(offset, limit, isAdmin, sort, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.listUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a user.
         * @param {string} userId 
         * @param {UserUpdateInputDTO} userUpdateInputDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(userId: string, userUpdateInputDTO: UserUpdateInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(userId, userUpdateInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a user.
         * @param {UsersApiCreateUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(requestParameters: UsersApiCreateUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserGetResponse> {
            return localVarFp.createUser(requestParameters.userCreateInputDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a server user by id.
         * @param {UsersApiDeleteUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(requestParameters: UsersApiDeleteUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUser(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user by id.
         * @param {UsersApiGetUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(requestParameters: UsersApiGetUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserGetResponse> {
            return localVarFp.getUser(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UsersApiListActiveUserSessionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActiveUserSessions(requestParameters: UsersApiListActiveUserSessionsRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserSessionListResponse> {
            return localVarFp.listActiveUserSessions(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the users.
         * @param {UsersApiListUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(requestParameters: UsersApiListUsersRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<UserListResponse> {
            return localVarFp.listUsers(requestParameters.offset, requestParameters.limit, requestParameters.isAdmin, requestParameters.sort, requestParameters.search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a user.
         * @param {UsersApiUpdateUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(requestParameters: UsersApiUpdateUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserGetResponse> {
            return localVarFp.updateUser(requestParameters.userId, requestParameters.userUpdateInputDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createUser operation in UsersApi.
 * @export
 * @interface UsersApiCreateUserRequest
 */
export interface UsersApiCreateUserRequest {
    /**
     * 
     * @type {UserCreateInputDTO}
     * @memberof UsersApiCreateUser
     */
    readonly userCreateInputDTO: UserCreateInputDTO
}

/**
 * Request parameters for deleteUser operation in UsersApi.
 * @export
 * @interface UsersApiDeleteUserRequest
 */
export interface UsersApiDeleteUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersApiDeleteUser
     */
    readonly userId: string
}

/**
 * Request parameters for getUser operation in UsersApi.
 * @export
 * @interface UsersApiGetUserRequest
 */
export interface UsersApiGetUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersApiGetUser
     */
    readonly userId: string
}

/**
 * Request parameters for listActiveUserSessions operation in UsersApi.
 * @export
 * @interface UsersApiListActiveUserSessionsRequest
 */
export interface UsersApiListActiveUserSessionsRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersApiListActiveUserSessions
     */
    readonly userId: string
}

/**
 * Request parameters for listUsers operation in UsersApi.
 * @export
 * @interface UsersApiListUsersRequest
 */
export interface UsersApiListUsersRequest {
    /**
     * 
     * @type {number}
     * @memberof UsersApiListUsers
     */
    readonly offset?: number

    /**
     * 
     * @type {number}
     * @memberof UsersApiListUsers
     */
    readonly limit?: number

    /**
     * 
     * @type {boolean}
     * @memberof UsersApiListUsers
     */
    readonly isAdmin?: boolean

    /**
     * 
     * @type {'createdAt-asc' | 'createdAt-desc' | 'email-asc' | 'email-desc' | 'name-asc' | 'name-desc' | 'username-asc' | 'username-desc' | 'updatedAt-asc' | 'updatedAt-desc'}
     * @memberof UsersApiListUsers
     */
    readonly sort?: ListUsersSortEnum

    /**
     * 
     * @type {string}
     * @memberof UsersApiListUsers
     */
    readonly search?: string
}

/**
 * Request parameters for updateUser operation in UsersApi.
 * @export
 * @interface UsersApiUpdateUserRequest
 */
export interface UsersApiUpdateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersApiUpdateUser
     */
    readonly userId: string

    /**
     * 
     * @type {UserUpdateInputDTO}
     * @memberof UsersApiUpdateUser
     */
    readonly userUpdateInputDTO: UserUpdateInputDTO
}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Create a user.
     * @param {UsersApiCreateUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUser(requestParameters: UsersApiCreateUserRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).createUser(requestParameters.userCreateInputDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a server user by id.
     * @param {UsersApiDeleteUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(requestParameters: UsersApiDeleteUserRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUser(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user by id.
     * @param {UsersApiGetUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUser(requestParameters: UsersApiGetUserRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUser(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiListActiveUserSessionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listActiveUserSessions(requestParameters: UsersApiListActiveUserSessionsRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).listActiveUserSessions(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the users.
     * @param {UsersApiListUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listUsers(requestParameters: UsersApiListUsersRequest = {}, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).listUsers(requestParameters.offset, requestParameters.limit, requestParameters.isAdmin, requestParameters.sort, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a user.
     * @param {UsersApiUpdateUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUser(requestParameters: UsersApiUpdateUserRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUser(requestParameters.userId, requestParameters.userUpdateInputDTO, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListUsersSortEnum = {
    CreatedAtAsc: 'createdAt-asc',
    CreatedAtDesc: 'createdAt-desc',
    EmailAsc: 'email-asc',
    EmailDesc: 'email-desc',
    NameAsc: 'name-asc',
    NameDesc: 'name-desc',
    UsernameAsc: 'username-asc',
    UsernameDesc: 'username-desc',
    UpdatedAtAsc: 'updatedAt-asc',
    UpdatedAtDesc: 'updatedAt-desc'
} as const;
export type ListUsersSortEnum = typeof ListUsersSortEnum[keyof typeof ListUsersSortEnum];


/**
 * ViewerApi - axios parameter creator
 * @export
 */
export const ViewerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getViewer: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/viewer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ViewerUpdateInputDTO} viewerUpdateInputDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateViewer: async (viewerUpdateInputDTO: ViewerUpdateInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'viewerUpdateInputDTO' is not null or undefined
            assertParamExists('updateViewer', 'viewerUpdateInputDTO', viewerUpdateInputDTO)
            const localVarPath = `/api/v1/viewer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(viewerUpdateInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ViewerApi - functional programming interface
 * @export
 */
export const ViewerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ViewerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getViewer(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViewerGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getViewer(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ViewerApi.getViewer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ViewerUpdateInputDTO} viewerUpdateInputDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateViewer(viewerUpdateInputDTO: ViewerUpdateInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViewerGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateViewer(viewerUpdateInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ViewerApi.updateViewer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ViewerApi - factory interface
 * @export
 */
export const ViewerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ViewerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getViewer(options?: RawAxiosRequestConfig): AxiosPromise<ViewerGetResponse> {
            return localVarFp.getViewer(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ViewerApiUpdateViewerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateViewer(requestParameters: ViewerApiUpdateViewerRequest, options?: RawAxiosRequestConfig): AxiosPromise<ViewerGetResponse> {
            return localVarFp.updateViewer(requestParameters.viewerUpdateInputDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for updateViewer operation in ViewerApi.
 * @export
 * @interface ViewerApiUpdateViewerRequest
 */
export interface ViewerApiUpdateViewerRequest {
    /**
     * 
     * @type {ViewerUpdateInputDTO}
     * @memberof ViewerApiUpdateViewer
     */
    readonly viewerUpdateInputDTO: ViewerUpdateInputDTO
}

/**
 * ViewerApi - object-oriented interface
 * @export
 * @class ViewerApi
 * @extends {BaseAPI}
 */
export class ViewerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewerApi
     */
    public getViewer(options?: RawAxiosRequestConfig) {
        return ViewerApiFp(this.configuration).getViewer(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ViewerApiUpdateViewerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewerApi
     */
    public updateViewer(requestParameters: ViewerApiUpdateViewerRequest, options?: RawAxiosRequestConfig) {
        return ViewerApiFp(this.configuration).updateViewer(requestParameters.viewerUpdateInputDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



