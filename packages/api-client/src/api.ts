/* tslint:disable */
/* eslint-disable */
/**
 * @stellariscloud/api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AppConfigCreateData
 */
export interface AppConfigCreateData {
    /**
     * 
     * @type {string}
     * @memberof AppConfigCreateData
     */
    key: string;
    /**
     * 
     * @type {any}
     * @memberof AppConfigCreateData
     */
    value?: any | null;
}
/**
 * 
 * @export
 * @interface AppConfigGetResponse
 */
export interface AppConfigGetResponse {
    /**
     * 
     * @type {any}
     * @memberof AppConfigGetResponse
     */
    value: any | null;
}
/**
 * 
 * @export
 * @interface CreateFolderSharePayload
 */
export interface CreateFolderSharePayload {
    /**
     * 
     * @type {string}
     * @memberof CreateFolderSharePayload
     */
    userInviteEmail: string;
    /**
     * 
     * @type {FolderShareConfig}
     * @memberof CreateFolderSharePayload
     */
    shareConfiguration: FolderShareConfig;
}
/**
 * 
 * @export
 * @interface ErrorData
 */
export interface ErrorData {
    /**
     * 
     * @type {string}
     * @memberof ErrorData
     */
    code: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorData
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorData
     */
    detail?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ErrorData
     */
    meta?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof ErrorData
     */
    pointer?: string;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {Array<ErrorData>}
     * @memberof ErrorResponse
     */
    errors: Array<ErrorData>;
}
/**
 * 
 * @export
 * @interface FolderAndPermission
 */
export interface FolderAndPermission {
    /**
     * 
     * @type {FolderData}
     * @memberof FolderAndPermission
     */
    folder: FolderData;
    /**
     * 
     * @type {Array<string>}
     * @memberof FolderAndPermission
     */
    permissions: Array<string>;
}
/**
 * 
 * @export
 * @interface FolderData
 */
export interface FolderData {
    /**
     * 
     * @type {string}
     * @memberof FolderData
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof FolderData
     */
    updatedAt: string;
    /**
     * 
     * @type {string}
     * @memberof FolderData
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof FolderData
     */
    ownerId?: string;
    /**
     * 
     * @type {string}
     * @memberof FolderData
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof FolderData
     */
    accessKeyId: string;
    /**
     * 
     * @type {string}
     * @memberof FolderData
     */
    endpoint: string;
    /**
     * 
     * @type {string}
     * @memberof FolderData
     */
    region?: string;
    /**
     * 
     * @type {string}
     * @memberof FolderData
     */
    bucket: string;
    /**
     * 
     * @type {string}
     * @memberof FolderData
     */
    prefix?: string;
}
/**
 * 
 * @export
 * @interface FolderObjectContentMetadata
 */
export interface FolderObjectContentMetadata {
    /**
     * 
     * @type {string}
     * @memberof FolderObjectContentMetadata
     */
    hash: string;
    /**
     * 
     * @type {string}
     * @memberof FolderObjectContentMetadata
     */
    mimeType: string;
    /**
     * 
     * @type {ImagePreviews}
     * @memberof FolderObjectContentMetadata
     */
    previews: ImagePreviews;
    /**
     * 
     * @type {number}
     * @memberof FolderObjectContentMetadata
     */
    lengthMilliseconds: number;
    /**
     * 
     * @type {number}
     * @memberof FolderObjectContentMetadata
     */
    imageOrientation?: number;
    /**
     * 
     * @type {number}
     * @memberof FolderObjectContentMetadata
     */
    height: number;
    /**
     * 
     * @type {number}
     * @memberof FolderObjectContentMetadata
     */
    width: number;
    /**
     * 
     * @type {string}
     * @memberof FolderObjectContentMetadata
     */
    createdAt?: string;
}
/**
 * 
 * @export
 * @interface FolderObjectData
 */
export interface FolderObjectData {
    /**
     * 
     * @type {string}
     * @memberof FolderObjectData
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof FolderObjectData
     */
    updatedAt: string;
    /**
     * 
     * @type {string}
     * @memberof FolderObjectData
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof FolderObjectData
     */
    objectKey: string;
    /**
     * 
     * @type {FolderObjectDataFolder}
     * @memberof FolderObjectData
     */
    folder: FolderObjectDataFolder;
    /**
     * 
     * @type {FolderObjectContentMetadata}
     * @memberof FolderObjectData
     */
    contentMetadata?: FolderObjectContentMetadata;
    /**
     * 
     * @type {number}
     * @memberof FolderObjectData
     */
    lastModified: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof FolderObjectData
     */
    tags: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof FolderObjectData
     */
    eTag: string;
    /**
     * 
     * @type {number}
     * @memberof FolderObjectData
     */
    sizeBytes: number;
    /**
     * 
     * @type {MediaType}
     * @memberof FolderObjectData
     */
    mediaType: MediaType;
}
/**
 * 
 * @export
 * @interface FolderObjectDataFolder
 */
export interface FolderObjectDataFolder {
    /**
     * 
     * @type {string}
     * @memberof FolderObjectDataFolder
     */
    id: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum FolderPermissionName {
    FolderRefresh = 'folder_refresh',
    FolderManageShares = 'folder_manage_shares',
    FolderForget = 'folder_forget',
    ObjectEdit = 'object_edit',
    ObjectManage = 'object_manage',
    TagCreate = 'tag_create',
    TagAssociate = 'tag_associate'
}

/**
 * 
 * @export
 * @interface FolderShareConfig
 */
export interface FolderShareConfig {
    /**
     * 
     * @type {Array<FolderPermissionName>}
     * @memberof FolderShareConfig
     */
    permissions: Array<FolderPermissionName>;
}
/**
 * 
 * @export
 * @interface FolderShareData
 */
export interface FolderShareData {
    /**
     * 
     * @type {string}
     * @memberof FolderShareData
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof FolderShareData
     */
    updatedAt: string;
    /**
     * 
     * @type {string}
     * @memberof FolderShareData
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof FolderShareData
     */
    userId?: string;
    /**
     * 
     * @type {string}
     * @memberof FolderShareData
     */
    userLabel: string;
    /**
     * 
     * @type {string}
     * @memberof FolderShareData
     */
    userInviteEmail: string;
    /**
     * 
     * @type {FolderObjectDataFolder}
     * @memberof FolderShareData
     */
    folder: FolderObjectDataFolder;
    /**
     * 
     * @type {FolderShareConfig}
     * @memberof FolderShareData
     */
    shareConfiguration: FolderShareConfig;
}
/**
 * 
 * @export
 * @interface ImagePreview
 */
export interface ImagePreview {
    /**
     * 
     * @type {number}
     * @memberof ImagePreview
     */
    size: number;
    /**
     * 
     * @type {string}
     * @memberof ImagePreview
     */
    path: string;
}
/**
 * 
 * @export
 * @interface ImagePreviews
 */
export interface ImagePreviews {
    /**
     * 
     * @type {ImagePreview}
     * @memberof ImagePreviews
     */
    large?: ImagePreview;
    /**
     * 
     * @type {ImagePreview}
     * @memberof ImagePreviews
     */
    medium?: ImagePreview;
    /**
     * 
     * @type {ImagePreview}
     * @memberof ImagePreviews
     */
    small?: ImagePreview;
}
/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    prefix?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    bucket: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    s3ConnectionId: string;
}
/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    eTag?: string;
}
/**
 * 
 * @export
 * @interface InlineObject2
 */
export interface InlineObject2 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    name: string;
}
/**
 * 
 * @export
 * @interface InlineObject3
 */
export interface InlineObject3 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    name: string;
}
/**
 * 
 * @export
 * @interface InlineObject4
 */
export interface InlineObject4 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject4
     */
    region: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject4
     */
    endpoint: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject4
     */
    secretAccessKey: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject4
     */
    accessKeyId: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject4
     */
    name: string;
}
/**
 * 
 * @export
 * @interface InlineObject5
 */
export interface InlineObject5 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject5
     */
    region: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject5
     */
    endpoint: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject5
     */
    secretAccessKey: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject5
     */
    accessKeyId: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject5
     */
    name: string;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {FolderData}
     * @memberof InlineResponse200
     */
    folder: FolderData;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {Array<FolderPermissionName>}
     * @memberof InlineResponse2001
     */
    permissions: Array<FolderPermissionName>;
    /**
     * 
     * @type {FolderData}
     * @memberof InlineResponse2001
     */
    folder: FolderData;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2002
     */
    success: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2003
     */
    totalSizeBytes: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2003
     */
    totalCount: number;
}
/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * 
     * @type {InlineResponse2004Meta}
     * @memberof InlineResponse2004
     */
    meta: InlineResponse2004Meta;
    /**
     * 
     * @type {Array<FolderObjectData>}
     * @memberof InlineResponse2004
     */
    result: Array<FolderObjectData>;
}
/**
 * 
 * @export
 * @interface InlineResponse2004Meta
 */
export interface InlineResponse2004Meta {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2004Meta
     */
    totalCount: number;
}
/**
 * 
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     * 
     * @type {InlineResponse2004Meta}
     * @memberof InlineResponse2005
     */
    meta: InlineResponse2004Meta;
    /**
     * 
     * @type {Array<FolderShareData>}
     * @memberof InlineResponse2005
     */
    result: Array<FolderShareData>;
}
/**
 * 
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
    /**
     * 
     * @type {InlineResponse2004Meta}
     * @memberof InlineResponse2006
     */
    meta: InlineResponse2004Meta;
    /**
     * 
     * @type {Array<ObjectTagData>}
     * @memberof InlineResponse2006
     */
    result: Array<ObjectTagData>;
}
/**
 * 
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007
     */
    method: InlineResponse2007MethodEnum;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007
     */
    url: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007
     */
    objectKey: string;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse2007MethodEnum {
    Put = 'PUT',
    Delete = 'DELETE',
    Get = 'GET'
}

/**
 * 
 * @export
 * @interface InlineResponse2008
 */
export interface InlineResponse2008 {
    /**
     * 
     * @type {Array<S3ConnectionData>}
     * @memberof InlineResponse2008
     */
    result: Array<S3ConnectionData>;
    /**
     * 
     * @type {InlineResponse2004Meta}
     * @memberof InlineResponse2008
     */
    meta: InlineResponse2004Meta;
}
/**
 * 
 * @export
 * @interface InlineResponse2009
 */
export interface InlineResponse2009 {
    /**
     * 
     * @type {UserData}
     * @memberof InlineResponse2009
     */
    data: UserData;
}
/**
 * 
 * @export
 * @interface ListFoldersResponse
 */
export interface ListFoldersResponse {
    /**
     * 
     * @type {InlineResponse2004Meta}
     * @memberof ListFoldersResponse
     */
    meta: InlineResponse2004Meta;
    /**
     * 
     * @type {Array<FolderAndPermission>}
     * @memberof ListFoldersResponse
     */
    result: Array<FolderAndPermission>;
}
/**
 * 
 * @export
 * @interface LoginParams
 */
export interface LoginParams {
    /**
     * 
     * @type {string}
     * @memberof LoginParams
     */
    login: string;
    /**
     * 
     * @type {string}
     * @memberof LoginParams
     */
    password: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum MediaType {
    Image = 'IMAGE',
    Video = 'VIDEO',
    Audio = 'AUDIO',
    Document = 'DOCUMENT',
    Unknown = 'UNKNOWN'
}

/**
 * 
 * @export
 * @interface ObjectTagData
 */
export interface ObjectTagData {
    /**
     * 
     * @type {string}
     * @memberof ObjectTagData
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof ObjectTagData
     */
    updatedAt: string;
    /**
     * 
     * @type {string}
     * @memberof ObjectTagData
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof ObjectTagData
     */
    name: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum PlatformRole {
    Anonymous = 'ANONYMOUS',
    Authenticated = 'AUTHENTICATED',
    Admin = 'ADMIN'
}

/**
 * 
 * @export
 * @interface S3ConnectionData
 */
export interface S3ConnectionData {
    /**
     * 
     * @type {string}
     * @memberof S3ConnectionData
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof S3ConnectionData
     */
    updatedAt: string;
    /**
     * 
     * @type {string}
     * @memberof S3ConnectionData
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof S3ConnectionData
     */
    ownerId?: string;
    /**
     * 
     * @type {string}
     * @memberof S3ConnectionData
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof S3ConnectionData
     */
    accessKeyId: string;
    /**
     * 
     * @type {string}
     * @memberof S3ConnectionData
     */
    endpoint: string;
    /**
     * 
     * @type {string}
     * @memberof S3ConnectionData
     */
    region?: string;
}
/**
 * 
 * @export
 * @interface SessionResponse
 */
export interface SessionResponse {
    /**
     * 
     * @type {SessionResponseData}
     * @memberof SessionResponse
     */
    data: SessionResponseData;
}
/**
 * 
 * @export
 * @interface SessionResponseData
 */
export interface SessionResponseData {
    /**
     * 
     * @type {string}
     * @memberof SessionResponseData
     */
    expiresAt: string;
    /**
     * 
     * @type {string}
     * @memberof SessionResponseData
     */
    refreshToken: string;
    /**
     * 
     * @type {string}
     * @memberof SessionResponseData
     */
    accessToken: string;
}
/**
 * 
 * @export
 * @interface UpdateFolderSharePayload
 */
export interface UpdateFolderSharePayload {
    /**
     * 
     * @type {FolderShareConfig}
     * @memberof UpdateFolderSharePayload
     */
    shareConfiguration: FolderShareConfig;
}
/**
 * 
 * @export
 * @interface UserData
 */
export interface UserData {
    /**
     * 
     * @type {string}
     * @memberof UserData
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof UserData
     */
    updatedAt: string;
    /**
     * 
     * @type {string}
     * @memberof UserData
     */
    id: string;
    /**
     * 
     * @type {PlatformRole}
     * @memberof UserData
     */
    role: PlatformRole;
    /**
     * 
     * @type {string}
     * @memberof UserData
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof UserData
     */
    username: string;
}

/**
 * AppConfigApi - axios parameter creator
 * @export
 */
export const AppConfigApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppConfig: async (key: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getAppConfig', 'key', key)
            const localVarPath = `/app-config/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AppConfigCreateData} appConfigCreateData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAppConfig: async (appConfigCreateData: AppConfigCreateData, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'appConfigCreateData' is not null or undefined
            assertParamExists('setAppConfig', 'appConfigCreateData', appConfigCreateData)
            const localVarPath = `/app-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(appConfigCreateData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppConfigApi - functional programming interface
 * @export
 */
export const AppConfigApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AppConfigApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAppConfig(key: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppConfigGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAppConfig(key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {AppConfigCreateData} appConfigCreateData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setAppConfig(appConfigCreateData: AppConfigCreateData, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setAppConfig(appConfigCreateData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AppConfigApi - factory interface
 * @export
 */
export const AppConfigApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AppConfigApiFp(configuration)
    return {
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppConfig(key: string, options?: any): AxiosPromise<AppConfigGetResponse> {
            return localVarFp.getAppConfig(key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AppConfigCreateData} appConfigCreateData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAppConfig(appConfigCreateData: AppConfigCreateData, options?: any): AxiosPromise<void> {
            return localVarFp.setAppConfig(appConfigCreateData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getAppConfig operation in AppConfigApi.
 * @export
 * @interface AppConfigApiGetAppConfigRequest
 */
export interface AppConfigApiGetAppConfigRequest {
    /**
     * 
     * @type {string}
     * @memberof AppConfigApiGetAppConfig
     */
    readonly key: string
}

/**
 * Request parameters for setAppConfig operation in AppConfigApi.
 * @export
 * @interface AppConfigApiSetAppConfigRequest
 */
export interface AppConfigApiSetAppConfigRequest {
    /**
     * 
     * @type {AppConfigCreateData}
     * @memberof AppConfigApiSetAppConfig
     */
    readonly appConfigCreateData: AppConfigCreateData
}

/**
 * AppConfigApi - object-oriented interface
 * @export
 * @class AppConfigApi
 * @extends {BaseAPI}
 */
export class AppConfigApi extends BaseAPI {
    /**
     * 
     * @param {AppConfigApiGetAppConfigRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppConfigApi
     */
    public getAppConfig(requestParameters: AppConfigApiGetAppConfigRequest, options?: any) {
        return AppConfigApiFp(this.configuration).getAppConfig(requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AppConfigApiSetAppConfigRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppConfigApi
     */
    public setAppConfig(requestParameters: AppConfigApiSetAppConfigRequest, options?: any) {
        return AppConfigApiFp(this.configuration).setAppConfig(requestParameters.appConfigCreateData, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {LoginParams} loginParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginParams: LoginParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginParams' is not null or undefined
            assertParamExists('login', 'loginParams', loginParams)
            const localVarPath = `/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication RefreshToken required
            await setApiKeyToObject(localVarQueryParameter, "refresh_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication RefreshToken required
            await setApiKeyToObject(localVarQueryParameter, "refresh_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {LoginParams} loginParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginParams: LoginParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @param {LoginParams} loginParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginParams: LoginParams, options?: any): AxiosPromise<SessionResponse> {
            return localVarFp.login(loginParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any): AxiosPromise<void> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(options?: any): AxiosPromise<SessionResponse> {
            return localVarFp.refreshToken(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for login operation in AuthApi.
 * @export
 * @interface AuthApiLoginRequest
 */
export interface AuthApiLoginRequest {
    /**
     * 
     * @type {LoginParams}
     * @memberof AuthApiLogin
     */
    readonly loginParams: LoginParams
}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @param {AuthApiLoginRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public login(requestParameters: AuthApiLoginRequest, options?: any) {
        return AuthApiFp(this.configuration).login(requestParameters.loginParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public logout(options?: any) {
        return AuthApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public refreshToken(options?: any) {
        return AuthApiFp(this.configuration).refreshToken(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FoldersApi - axios parameter creator
 * @export
 */
export const FoldersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {InlineObject} inlineObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolder: async (inlineObject: InlineObject, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inlineObject' is not null or undefined
            assertParamExists('createFolder', 'inlineObject', inlineObject)
            const localVarPath = `/folders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} folderId 
         * @param {CreateFolderSharePayload} createFolderSharePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolderShare: async (folderId: string, createFolderSharePayload: CreateFolderSharePayload, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('createFolderShare', 'folderId', folderId)
            // verify required parameter 'createFolderSharePayload' is not null or undefined
            assertParamExists('createFolderShare', 'createFolderSharePayload', createFolderSharePayload)
            const localVarPath = `/folders/{folderId}/shares`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFolderSharePayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} folderId 
         * @param {Array<object>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPresignedURLs: async (folderId: string, requestBody: Array<object>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('createPresignedURLs', 'folderId', folderId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('createPresignedURLs', 'requestBody', requestBody)
            const localVarPath = `/folders/{folderId}/presigned-urls`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} folderId 
         * @param {InlineObject2} inlineObject2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTag: async (folderId: string, inlineObject2: InlineObject2, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('createTag', 'folderId', folderId)
            // verify required parameter 'inlineObject2' is not null or undefined
            assertParamExists('createTag', 'inlineObject2', inlineObject2)
            const localVarPath = `/folders/{folderId}/tags`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolder: async (folderId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('deleteFolder', 'folderId', folderId)
            const localVarPath = `/folders/{folderId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} folderId 
         * @param {string} objectKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolderObject: async (folderId: string, objectKey: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('deleteFolderObject', 'folderId', folderId)
            // verify required parameter 'objectKey' is not null or undefined
            assertParamExists('deleteFolderObject', 'objectKey', objectKey)
            const localVarPath = `/folders/{folderId}/objects/{objectKey}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
                .replace(`{${"objectKey"}}`, encodeURIComponent(String(objectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} folderId 
         * @param {string} shareId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolderShare: async (folderId: string, shareId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('deleteFolderShare', 'folderId', folderId)
            // verify required parameter 'shareId' is not null or undefined
            assertParamExists('deleteFolderShare', 'shareId', shareId)
            const localVarPath = `/folders/{folderId}/shares/{shareId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
                .replace(`{${"shareId"}}`, encodeURIComponent(String(shareId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} folderId 
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag: async (folderId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('deleteTag', 'folderId', folderId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('deleteTag', 'tagId', tagId)
            const localVarPath = `/folders/{folderId}/tags/{tagId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolder: async (folderId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('getFolder', 'folderId', folderId)
            const localVarPath = `/folders/{folderId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderMetadata: async (folderId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('getFolderMetadata', 'folderId', folderId)
            const localVarPath = `/folders/{folderId}/metadata`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} folderId 
         * @param {string} objectKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderObject: async (folderId: string, objectKey: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('getFolderObject', 'folderId', folderId)
            // verify required parameter 'objectKey' is not null or undefined
            assertParamExists('getFolderObject', 'objectKey', objectKey)
            const localVarPath = `/folders/{folderId}/objects/{objectKey}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
                .replace(`{${"objectKey"}}`, encodeURIComponent(String(objectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} folderId 
         * @param {string} [search] 
         * @param {string} [tagId] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFolderObjects: async (folderId: string, search?: string, tagId?: string, offset?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('listFolderObjects', 'folderId', folderId)
            const localVarPath = `/folders/{folderId}/objects`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (tagId !== undefined) {
                localVarQueryParameter['tagId'] = tagId;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFolderShares: async (folderId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('listFolderShares', 'folderId', folderId)
            const localVarPath = `/folders/{folderId}/shares`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFolders: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/folders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTags: async (folderId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('listTags', 'folderId', folderId)
            const localVarPath = `/folders/{folderId}/tags`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshFolder: async (folderId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('refreshFolder', 'folderId', folderId)
            const localVarPath = `/folders/{folderId}/refresh`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} folderId 
         * @param {string} objectKey 
         * @param {InlineObject1} inlineObject1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshFolderObjectS3Metadata: async (folderId: string, objectKey: string, inlineObject1: InlineObject1, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('refreshFolderObjectS3Metadata', 'folderId', folderId)
            // verify required parameter 'objectKey' is not null or undefined
            assertParamExists('refreshFolderObjectS3Metadata', 'objectKey', objectKey)
            // verify required parameter 'inlineObject1' is not null or undefined
            assertParamExists('refreshFolderObjectS3Metadata', 'inlineObject1', inlineObject1)
            const localVarPath = `/folders/{folderId}/objects/{objectKey}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
                .replace(`{${"objectKey"}}`, encodeURIComponent(String(objectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject1, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} folderId 
         * @param {string} objectKey 
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagObject: async (folderId: string, objectKey: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('tagObject', 'folderId', folderId)
            // verify required parameter 'objectKey' is not null or undefined
            assertParamExists('tagObject', 'objectKey', objectKey)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('tagObject', 'tagId', tagId)
            const localVarPath = `/folders/{folderId}/objects/{objectKey}/{tagId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
                .replace(`{${"objectKey"}}`, encodeURIComponent(String(objectKey)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} folderId 
         * @param {string} objectKey 
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        untagObject: async (folderId: string, objectKey: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('untagObject', 'folderId', folderId)
            // verify required parameter 'objectKey' is not null or undefined
            assertParamExists('untagObject', 'objectKey', objectKey)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('untagObject', 'tagId', tagId)
            const localVarPath = `/folders/{folderId}/objects/{objectKey}/{tagId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
                .replace(`{${"objectKey"}}`, encodeURIComponent(String(objectKey)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} folderId 
         * @param {string} objectKey 
         * @param {FolderObjectContentMetadata} folderObjectContentMetadata 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFolderObjectContentMetadata: async (folderId: string, objectKey: string, folderObjectContentMetadata: FolderObjectContentMetadata, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('updateFolderObjectContentMetadata', 'folderId', folderId)
            // verify required parameter 'objectKey' is not null or undefined
            assertParamExists('updateFolderObjectContentMetadata', 'objectKey', objectKey)
            // verify required parameter 'folderObjectContentMetadata' is not null or undefined
            assertParamExists('updateFolderObjectContentMetadata', 'folderObjectContentMetadata', folderObjectContentMetadata)
            const localVarPath = `/folders/{folderId}/objects/{objectKey}/content-metadata`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
                .replace(`{${"objectKey"}}`, encodeURIComponent(String(objectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(folderObjectContentMetadata, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} folderId 
         * @param {string} shareId 
         * @param {UpdateFolderSharePayload} updateFolderSharePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFolderShare: async (folderId: string, shareId: string, updateFolderSharePayload: UpdateFolderSharePayload, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('updateFolderShare', 'folderId', folderId)
            // verify required parameter 'shareId' is not null or undefined
            assertParamExists('updateFolderShare', 'shareId', shareId)
            // verify required parameter 'updateFolderSharePayload' is not null or undefined
            assertParamExists('updateFolderShare', 'updateFolderSharePayload', updateFolderSharePayload)
            const localVarPath = `/folders/{folderId}/shares/{shareId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
                .replace(`{${"shareId"}}`, encodeURIComponent(String(shareId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFolderSharePayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} folderId 
         * @param {string} tagId 
         * @param {InlineObject3} inlineObject3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag: async (folderId: string, tagId: string, inlineObject3: InlineObject3, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('updateTag', 'folderId', folderId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('updateTag', 'tagId', tagId)
            // verify required parameter 'inlineObject3' is not null or undefined
            assertParamExists('updateTag', 'inlineObject3', inlineObject3)
            const localVarPath = `/folders/{folderId}/tags/{tagId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject3, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FoldersApi - functional programming interface
 * @export
 */
export const FoldersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FoldersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {InlineObject} inlineObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFolder(inlineObject: InlineObject, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFolder(inlineObject, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} folderId 
         * @param {CreateFolderSharePayload} createFolderSharePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFolderShare(folderId: string, createFolderSharePayload: CreateFolderSharePayload, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderShareData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFolderShare(folderId, createFolderSharePayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} folderId 
         * @param {Array<object>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPresignedURLs(folderId: string, requestBody: Array<object>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse2007>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPresignedURLs(folderId, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} folderId 
         * @param {InlineObject2} inlineObject2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTag(folderId: string, inlineObject2: InlineObject2, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectTagData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTag(folderId, inlineObject2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFolder(folderId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFolder(folderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} folderId 
         * @param {string} objectKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFolderObject(folderId: string, objectKey: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFolderObject(folderId, objectKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} folderId 
         * @param {string} shareId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFolderShare(folderId: string, shareId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFolderShare(folderId, shareId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} folderId 
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTag(folderId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTag(folderId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolder(folderId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolder(folderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolderMetadata(folderId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolderMetadata(folderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} folderId 
         * @param {string} objectKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolderObject(folderId: string, objectKey: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderObjectData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolderObject(folderId, objectKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} folderId 
         * @param {string} [search] 
         * @param {string} [tagId] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFolderObjects(folderId: string, search?: string, tagId?: string, offset?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFolderObjects(folderId, search, tagId, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFolderShares(folderId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFolderShares(folderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFolders(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListFoldersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFolders(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTags(folderId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2006>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTags(folderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshFolder(folderId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshFolder(folderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} folderId 
         * @param {string} objectKey 
         * @param {InlineObject1} inlineObject1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshFolderObjectS3Metadata(folderId: string, objectKey: string, inlineObject1: InlineObject1, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderObjectData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshFolderObjectS3Metadata(folderId, objectKey, inlineObject1, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} folderId 
         * @param {string} objectKey 
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagObject(folderId: string, objectKey: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagObject(folderId, objectKey, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} folderId 
         * @param {string} objectKey 
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async untagObject(folderId: string, objectKey: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.untagObject(folderId, objectKey, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} folderId 
         * @param {string} objectKey 
         * @param {FolderObjectContentMetadata} folderObjectContentMetadata 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFolderObjectContentMetadata(folderId: string, objectKey: string, folderObjectContentMetadata: FolderObjectContentMetadata, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderObjectData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFolderObjectContentMetadata(folderId, objectKey, folderObjectContentMetadata, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} folderId 
         * @param {string} shareId 
         * @param {UpdateFolderSharePayload} updateFolderSharePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFolderShare(folderId: string, shareId: string, updateFolderSharePayload: UpdateFolderSharePayload, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderShareData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFolderShare(folderId, shareId, updateFolderSharePayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} folderId 
         * @param {string} tagId 
         * @param {InlineObject3} inlineObject3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTag(folderId: string, tagId: string, inlineObject3: InlineObject3, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectTagData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTag(folderId, tagId, inlineObject3, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FoldersApi - factory interface
 * @export
 */
export const FoldersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FoldersApiFp(configuration)
    return {
        /**
         * 
         * @param {InlineObject} inlineObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolder(inlineObject: InlineObject, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.createFolder(inlineObject, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} folderId 
         * @param {CreateFolderSharePayload} createFolderSharePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolderShare(folderId: string, createFolderSharePayload: CreateFolderSharePayload, options?: any): AxiosPromise<FolderShareData> {
            return localVarFp.createFolderShare(folderId, createFolderSharePayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} folderId 
         * @param {Array<object>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPresignedURLs(folderId: string, requestBody: Array<object>, options?: any): AxiosPromise<Array<InlineResponse2007>> {
            return localVarFp.createPresignedURLs(folderId, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} folderId 
         * @param {InlineObject2} inlineObject2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTag(folderId: string, inlineObject2: InlineObject2, options?: any): AxiosPromise<ObjectTagData> {
            return localVarFp.createTag(folderId, inlineObject2, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolder(folderId: string, options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.deleteFolder(folderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} folderId 
         * @param {string} objectKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolderObject(folderId: string, objectKey: string, options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.deleteFolderObject(folderId, objectKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} folderId 
         * @param {string} shareId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolderShare(folderId: string, shareId: string, options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.deleteFolderShare(folderId, shareId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} folderId 
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag(folderId: string, tagId: string, options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.deleteTag(folderId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolder(folderId: string, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.getFolder(folderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderMetadata(folderId: string, options?: any): AxiosPromise<InlineResponse2003> {
            return localVarFp.getFolderMetadata(folderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} folderId 
         * @param {string} objectKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderObject(folderId: string, objectKey: string, options?: any): AxiosPromise<FolderObjectData> {
            return localVarFp.getFolderObject(folderId, objectKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} folderId 
         * @param {string} [search] 
         * @param {string} [tagId] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFolderObjects(folderId: string, search?: string, tagId?: string, offset?: number, limit?: number, options?: any): AxiosPromise<InlineResponse2004> {
            return localVarFp.listFolderObjects(folderId, search, tagId, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFolderShares(folderId: string, options?: any): AxiosPromise<InlineResponse2005> {
            return localVarFp.listFolderShares(folderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFolders(options?: any): AxiosPromise<ListFoldersResponse> {
            return localVarFp.listFolders(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTags(folderId: string, options?: any): AxiosPromise<InlineResponse2006> {
            return localVarFp.listTags(folderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshFolder(folderId: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.refreshFolder(folderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} folderId 
         * @param {string} objectKey 
         * @param {InlineObject1} inlineObject1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshFolderObjectS3Metadata(folderId: string, objectKey: string, inlineObject1: InlineObject1, options?: any): AxiosPromise<FolderObjectData> {
            return localVarFp.refreshFolderObjectS3Metadata(folderId, objectKey, inlineObject1, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} folderId 
         * @param {string} objectKey 
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagObject(folderId: string, objectKey: string, tagId: string, options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.tagObject(folderId, objectKey, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} folderId 
         * @param {string} objectKey 
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        untagObject(folderId: string, objectKey: string, tagId: string, options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.untagObject(folderId, objectKey, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} folderId 
         * @param {string} objectKey 
         * @param {FolderObjectContentMetadata} folderObjectContentMetadata 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFolderObjectContentMetadata(folderId: string, objectKey: string, folderObjectContentMetadata: FolderObjectContentMetadata, options?: any): AxiosPromise<FolderObjectData> {
            return localVarFp.updateFolderObjectContentMetadata(folderId, objectKey, folderObjectContentMetadata, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} folderId 
         * @param {string} shareId 
         * @param {UpdateFolderSharePayload} updateFolderSharePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFolderShare(folderId: string, shareId: string, updateFolderSharePayload: UpdateFolderSharePayload, options?: any): AxiosPromise<FolderShareData> {
            return localVarFp.updateFolderShare(folderId, shareId, updateFolderSharePayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} folderId 
         * @param {string} tagId 
         * @param {InlineObject3} inlineObject3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag(folderId: string, tagId: string, inlineObject3: InlineObject3, options?: any): AxiosPromise<ObjectTagData> {
            return localVarFp.updateTag(folderId, tagId, inlineObject3, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createFolder operation in FoldersApi.
 * @export
 * @interface FoldersApiCreateFolderRequest
 */
export interface FoldersApiCreateFolderRequest {
    /**
     * 
     * @type {InlineObject}
     * @memberof FoldersApiCreateFolder
     */
    readonly inlineObject: InlineObject
}

/**
 * Request parameters for createFolderShare operation in FoldersApi.
 * @export
 * @interface FoldersApiCreateFolderShareRequest
 */
export interface FoldersApiCreateFolderShareRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiCreateFolderShare
     */
    readonly folderId: string

    /**
     * 
     * @type {CreateFolderSharePayload}
     * @memberof FoldersApiCreateFolderShare
     */
    readonly createFolderSharePayload: CreateFolderSharePayload
}

/**
 * Request parameters for createPresignedURLs operation in FoldersApi.
 * @export
 * @interface FoldersApiCreatePresignedURLsRequest
 */
export interface FoldersApiCreatePresignedURLsRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiCreatePresignedURLs
     */
    readonly folderId: string

    /**
     * 
     * @type {Array<object>}
     * @memberof FoldersApiCreatePresignedURLs
     */
    readonly requestBody: Array<object>
}

/**
 * Request parameters for createTag operation in FoldersApi.
 * @export
 * @interface FoldersApiCreateTagRequest
 */
export interface FoldersApiCreateTagRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiCreateTag
     */
    readonly folderId: string

    /**
     * 
     * @type {InlineObject2}
     * @memberof FoldersApiCreateTag
     */
    readonly inlineObject2: InlineObject2
}

/**
 * Request parameters for deleteFolder operation in FoldersApi.
 * @export
 * @interface FoldersApiDeleteFolderRequest
 */
export interface FoldersApiDeleteFolderRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiDeleteFolder
     */
    readonly folderId: string
}

/**
 * Request parameters for deleteFolderObject operation in FoldersApi.
 * @export
 * @interface FoldersApiDeleteFolderObjectRequest
 */
export interface FoldersApiDeleteFolderObjectRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiDeleteFolderObject
     */
    readonly folderId: string

    /**
     * 
     * @type {string}
     * @memberof FoldersApiDeleteFolderObject
     */
    readonly objectKey: string
}

/**
 * Request parameters for deleteFolderShare operation in FoldersApi.
 * @export
 * @interface FoldersApiDeleteFolderShareRequest
 */
export interface FoldersApiDeleteFolderShareRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiDeleteFolderShare
     */
    readonly folderId: string

    /**
     * 
     * @type {string}
     * @memberof FoldersApiDeleteFolderShare
     */
    readonly shareId: string
}

/**
 * Request parameters for deleteTag operation in FoldersApi.
 * @export
 * @interface FoldersApiDeleteTagRequest
 */
export interface FoldersApiDeleteTagRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiDeleteTag
     */
    readonly folderId: string

    /**
     * 
     * @type {string}
     * @memberof FoldersApiDeleteTag
     */
    readonly tagId: string
}

/**
 * Request parameters for getFolder operation in FoldersApi.
 * @export
 * @interface FoldersApiGetFolderRequest
 */
export interface FoldersApiGetFolderRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiGetFolder
     */
    readonly folderId: string
}

/**
 * Request parameters for getFolderMetadata operation in FoldersApi.
 * @export
 * @interface FoldersApiGetFolderMetadataRequest
 */
export interface FoldersApiGetFolderMetadataRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiGetFolderMetadata
     */
    readonly folderId: string
}

/**
 * Request parameters for getFolderObject operation in FoldersApi.
 * @export
 * @interface FoldersApiGetFolderObjectRequest
 */
export interface FoldersApiGetFolderObjectRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiGetFolderObject
     */
    readonly folderId: string

    /**
     * 
     * @type {string}
     * @memberof FoldersApiGetFolderObject
     */
    readonly objectKey: string
}

/**
 * Request parameters for listFolderObjects operation in FoldersApi.
 * @export
 * @interface FoldersApiListFolderObjectsRequest
 */
export interface FoldersApiListFolderObjectsRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiListFolderObjects
     */
    readonly folderId: string

    /**
     * 
     * @type {string}
     * @memberof FoldersApiListFolderObjects
     */
    readonly search?: string

    /**
     * 
     * @type {string}
     * @memberof FoldersApiListFolderObjects
     */
    readonly tagId?: string

    /**
     * 
     * @type {number}
     * @memberof FoldersApiListFolderObjects
     */
    readonly offset?: number

    /**
     * 
     * @type {number}
     * @memberof FoldersApiListFolderObjects
     */
    readonly limit?: number
}

/**
 * Request parameters for listFolderShares operation in FoldersApi.
 * @export
 * @interface FoldersApiListFolderSharesRequest
 */
export interface FoldersApiListFolderSharesRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiListFolderShares
     */
    readonly folderId: string
}

/**
 * Request parameters for listTags operation in FoldersApi.
 * @export
 * @interface FoldersApiListTagsRequest
 */
export interface FoldersApiListTagsRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiListTags
     */
    readonly folderId: string
}

/**
 * Request parameters for refreshFolder operation in FoldersApi.
 * @export
 * @interface FoldersApiRefreshFolderRequest
 */
export interface FoldersApiRefreshFolderRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiRefreshFolder
     */
    readonly folderId: string
}

/**
 * Request parameters for refreshFolderObjectS3Metadata operation in FoldersApi.
 * @export
 * @interface FoldersApiRefreshFolderObjectS3MetadataRequest
 */
export interface FoldersApiRefreshFolderObjectS3MetadataRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiRefreshFolderObjectS3Metadata
     */
    readonly folderId: string

    /**
     * 
     * @type {string}
     * @memberof FoldersApiRefreshFolderObjectS3Metadata
     */
    readonly objectKey: string

    /**
     * 
     * @type {InlineObject1}
     * @memberof FoldersApiRefreshFolderObjectS3Metadata
     */
    readonly inlineObject1: InlineObject1
}

/**
 * Request parameters for tagObject operation in FoldersApi.
 * @export
 * @interface FoldersApiTagObjectRequest
 */
export interface FoldersApiTagObjectRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiTagObject
     */
    readonly folderId: string

    /**
     * 
     * @type {string}
     * @memberof FoldersApiTagObject
     */
    readonly objectKey: string

    /**
     * 
     * @type {string}
     * @memberof FoldersApiTagObject
     */
    readonly tagId: string
}

/**
 * Request parameters for untagObject operation in FoldersApi.
 * @export
 * @interface FoldersApiUntagObjectRequest
 */
export interface FoldersApiUntagObjectRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiUntagObject
     */
    readonly folderId: string

    /**
     * 
     * @type {string}
     * @memberof FoldersApiUntagObject
     */
    readonly objectKey: string

    /**
     * 
     * @type {string}
     * @memberof FoldersApiUntagObject
     */
    readonly tagId: string
}

/**
 * Request parameters for updateFolderObjectContentMetadata operation in FoldersApi.
 * @export
 * @interface FoldersApiUpdateFolderObjectContentMetadataRequest
 */
export interface FoldersApiUpdateFolderObjectContentMetadataRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiUpdateFolderObjectContentMetadata
     */
    readonly folderId: string

    /**
     * 
     * @type {string}
     * @memberof FoldersApiUpdateFolderObjectContentMetadata
     */
    readonly objectKey: string

    /**
     * 
     * @type {FolderObjectContentMetadata}
     * @memberof FoldersApiUpdateFolderObjectContentMetadata
     */
    readonly folderObjectContentMetadata: FolderObjectContentMetadata
}

/**
 * Request parameters for updateFolderShare operation in FoldersApi.
 * @export
 * @interface FoldersApiUpdateFolderShareRequest
 */
export interface FoldersApiUpdateFolderShareRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiUpdateFolderShare
     */
    readonly folderId: string

    /**
     * 
     * @type {string}
     * @memberof FoldersApiUpdateFolderShare
     */
    readonly shareId: string

    /**
     * 
     * @type {UpdateFolderSharePayload}
     * @memberof FoldersApiUpdateFolderShare
     */
    readonly updateFolderSharePayload: UpdateFolderSharePayload
}

/**
 * Request parameters for updateTag operation in FoldersApi.
 * @export
 * @interface FoldersApiUpdateTagRequest
 */
export interface FoldersApiUpdateTagRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiUpdateTag
     */
    readonly folderId: string

    /**
     * 
     * @type {string}
     * @memberof FoldersApiUpdateTag
     */
    readonly tagId: string

    /**
     * 
     * @type {InlineObject3}
     * @memberof FoldersApiUpdateTag
     */
    readonly inlineObject3: InlineObject3
}

/**
 * FoldersApi - object-oriented interface
 * @export
 * @class FoldersApi
 * @extends {BaseAPI}
 */
export class FoldersApi extends BaseAPI {
    /**
     * 
     * @param {FoldersApiCreateFolderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public createFolder(requestParameters: FoldersApiCreateFolderRequest, options?: any) {
        return FoldersApiFp(this.configuration).createFolder(requestParameters.inlineObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FoldersApiCreateFolderShareRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public createFolderShare(requestParameters: FoldersApiCreateFolderShareRequest, options?: any) {
        return FoldersApiFp(this.configuration).createFolderShare(requestParameters.folderId, requestParameters.createFolderSharePayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FoldersApiCreatePresignedURLsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public createPresignedURLs(requestParameters: FoldersApiCreatePresignedURLsRequest, options?: any) {
        return FoldersApiFp(this.configuration).createPresignedURLs(requestParameters.folderId, requestParameters.requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FoldersApiCreateTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public createTag(requestParameters: FoldersApiCreateTagRequest, options?: any) {
        return FoldersApiFp(this.configuration).createTag(requestParameters.folderId, requestParameters.inlineObject2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FoldersApiDeleteFolderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public deleteFolder(requestParameters: FoldersApiDeleteFolderRequest, options?: any) {
        return FoldersApiFp(this.configuration).deleteFolder(requestParameters.folderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FoldersApiDeleteFolderObjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public deleteFolderObject(requestParameters: FoldersApiDeleteFolderObjectRequest, options?: any) {
        return FoldersApiFp(this.configuration).deleteFolderObject(requestParameters.folderId, requestParameters.objectKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FoldersApiDeleteFolderShareRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public deleteFolderShare(requestParameters: FoldersApiDeleteFolderShareRequest, options?: any) {
        return FoldersApiFp(this.configuration).deleteFolderShare(requestParameters.folderId, requestParameters.shareId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FoldersApiDeleteTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public deleteTag(requestParameters: FoldersApiDeleteTagRequest, options?: any) {
        return FoldersApiFp(this.configuration).deleteTag(requestParameters.folderId, requestParameters.tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FoldersApiGetFolderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public getFolder(requestParameters: FoldersApiGetFolderRequest, options?: any) {
        return FoldersApiFp(this.configuration).getFolder(requestParameters.folderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FoldersApiGetFolderMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public getFolderMetadata(requestParameters: FoldersApiGetFolderMetadataRequest, options?: any) {
        return FoldersApiFp(this.configuration).getFolderMetadata(requestParameters.folderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FoldersApiGetFolderObjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public getFolderObject(requestParameters: FoldersApiGetFolderObjectRequest, options?: any) {
        return FoldersApiFp(this.configuration).getFolderObject(requestParameters.folderId, requestParameters.objectKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FoldersApiListFolderObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public listFolderObjects(requestParameters: FoldersApiListFolderObjectsRequest, options?: any) {
        return FoldersApiFp(this.configuration).listFolderObjects(requestParameters.folderId, requestParameters.search, requestParameters.tagId, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FoldersApiListFolderSharesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public listFolderShares(requestParameters: FoldersApiListFolderSharesRequest, options?: any) {
        return FoldersApiFp(this.configuration).listFolderShares(requestParameters.folderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public listFolders(options?: any) {
        return FoldersApiFp(this.configuration).listFolders(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FoldersApiListTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public listTags(requestParameters: FoldersApiListTagsRequest, options?: any) {
        return FoldersApiFp(this.configuration).listTags(requestParameters.folderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FoldersApiRefreshFolderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public refreshFolder(requestParameters: FoldersApiRefreshFolderRequest, options?: any) {
        return FoldersApiFp(this.configuration).refreshFolder(requestParameters.folderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FoldersApiRefreshFolderObjectS3MetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public refreshFolderObjectS3Metadata(requestParameters: FoldersApiRefreshFolderObjectS3MetadataRequest, options?: any) {
        return FoldersApiFp(this.configuration).refreshFolderObjectS3Metadata(requestParameters.folderId, requestParameters.objectKey, requestParameters.inlineObject1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FoldersApiTagObjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public tagObject(requestParameters: FoldersApiTagObjectRequest, options?: any) {
        return FoldersApiFp(this.configuration).tagObject(requestParameters.folderId, requestParameters.objectKey, requestParameters.tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FoldersApiUntagObjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public untagObject(requestParameters: FoldersApiUntagObjectRequest, options?: any) {
        return FoldersApiFp(this.configuration).untagObject(requestParameters.folderId, requestParameters.objectKey, requestParameters.tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FoldersApiUpdateFolderObjectContentMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public updateFolderObjectContentMetadata(requestParameters: FoldersApiUpdateFolderObjectContentMetadataRequest, options?: any) {
        return FoldersApiFp(this.configuration).updateFolderObjectContentMetadata(requestParameters.folderId, requestParameters.objectKey, requestParameters.folderObjectContentMetadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FoldersApiUpdateFolderShareRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public updateFolderShare(requestParameters: FoldersApiUpdateFolderShareRequest, options?: any) {
        return FoldersApiFp(this.configuration).updateFolderShare(requestParameters.folderId, requestParameters.shareId, requestParameters.updateFolderSharePayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FoldersApiUpdateTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public updateTag(requestParameters: FoldersApiUpdateTagRequest, options?: any) {
        return FoldersApiFp(this.configuration).updateTag(requestParameters.folderId, requestParameters.tagId, requestParameters.inlineObject3, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * S3ConnectionsApi - axios parameter creator
 * @export
 */
export const S3ConnectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {InlineObject4} inlineObject4 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createS3Connection: async (inlineObject4: InlineObject4, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inlineObject4' is not null or undefined
            assertParamExists('createS3Connection', 'inlineObject4', inlineObject4)
            const localVarPath = `/s3-connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject4, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} s3ConnectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteS3Connection: async (s3ConnectionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 's3ConnectionId' is not null or undefined
            assertParamExists('deleteS3Connection', 's3ConnectionId', s3ConnectionId)
            const localVarPath = `/s3-connections/{s3ConnectionId}`
                .replace(`{${"s3ConnectionId"}}`, encodeURIComponent(String(s3ConnectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} s3ConnectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getS3Connection: async (s3ConnectionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 's3ConnectionId' is not null or undefined
            assertParamExists('getS3Connection', 's3ConnectionId', s3ConnectionId)
            const localVarPath = `/s3-connections/{s3ConnectionId}`
                .replace(`{${"s3ConnectionId"}}`, encodeURIComponent(String(s3ConnectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listS3Connections: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/s3-connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {InlineObject5} inlineObject5 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testS3Connection: async (inlineObject5: InlineObject5, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inlineObject5' is not null or undefined
            assertParamExists('testS3Connection', 'inlineObject5', inlineObject5)
            const localVarPath = `/s3-connections/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject5, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * S3ConnectionsApi - functional programming interface
 * @export
 */
export const S3ConnectionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = S3ConnectionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {InlineObject4} inlineObject4 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createS3Connection(inlineObject4: InlineObject4, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<S3ConnectionData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createS3Connection(inlineObject4, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} s3ConnectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteS3Connection(s3ConnectionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteS3Connection(s3ConnectionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} s3ConnectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getS3Connection(s3ConnectionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<S3ConnectionData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getS3Connection(s3ConnectionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listS3Connections(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2008>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listS3Connections(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {InlineObject5} inlineObject5 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testS3Connection(inlineObject5: InlineObject5, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testS3Connection(inlineObject5, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * S3ConnectionsApi - factory interface
 * @export
 */
export const S3ConnectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = S3ConnectionsApiFp(configuration)
    return {
        /**
         * 
         * @param {InlineObject4} inlineObject4 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createS3Connection(inlineObject4: InlineObject4, options?: any): AxiosPromise<S3ConnectionData> {
            return localVarFp.createS3Connection(inlineObject4, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} s3ConnectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteS3Connection(s3ConnectionId: string, options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.deleteS3Connection(s3ConnectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} s3ConnectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getS3Connection(s3ConnectionId: string, options?: any): AxiosPromise<S3ConnectionData> {
            return localVarFp.getS3Connection(s3ConnectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listS3Connections(options?: any): AxiosPromise<InlineResponse2008> {
            return localVarFp.listS3Connections(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InlineObject5} inlineObject5 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testS3Connection(inlineObject5: InlineObject5, options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.testS3Connection(inlineObject5, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createS3Connection operation in S3ConnectionsApi.
 * @export
 * @interface S3ConnectionsApiCreateS3ConnectionRequest
 */
export interface S3ConnectionsApiCreateS3ConnectionRequest {
    /**
     * 
     * @type {InlineObject4}
     * @memberof S3ConnectionsApiCreateS3Connection
     */
    readonly inlineObject4: InlineObject4
}

/**
 * Request parameters for deleteS3Connection operation in S3ConnectionsApi.
 * @export
 * @interface S3ConnectionsApiDeleteS3ConnectionRequest
 */
export interface S3ConnectionsApiDeleteS3ConnectionRequest {
    /**
     * 
     * @type {string}
     * @memberof S3ConnectionsApiDeleteS3Connection
     */
    readonly s3ConnectionId: string
}

/**
 * Request parameters for getS3Connection operation in S3ConnectionsApi.
 * @export
 * @interface S3ConnectionsApiGetS3ConnectionRequest
 */
export interface S3ConnectionsApiGetS3ConnectionRequest {
    /**
     * 
     * @type {string}
     * @memberof S3ConnectionsApiGetS3Connection
     */
    readonly s3ConnectionId: string
}

/**
 * Request parameters for testS3Connection operation in S3ConnectionsApi.
 * @export
 * @interface S3ConnectionsApiTestS3ConnectionRequest
 */
export interface S3ConnectionsApiTestS3ConnectionRequest {
    /**
     * 
     * @type {InlineObject5}
     * @memberof S3ConnectionsApiTestS3Connection
     */
    readonly inlineObject5: InlineObject5
}

/**
 * S3ConnectionsApi - object-oriented interface
 * @export
 * @class S3ConnectionsApi
 * @extends {BaseAPI}
 */
export class S3ConnectionsApi extends BaseAPI {
    /**
     * 
     * @param {S3ConnectionsApiCreateS3ConnectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof S3ConnectionsApi
     */
    public createS3Connection(requestParameters: S3ConnectionsApiCreateS3ConnectionRequest, options?: any) {
        return S3ConnectionsApiFp(this.configuration).createS3Connection(requestParameters.inlineObject4, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {S3ConnectionsApiDeleteS3ConnectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof S3ConnectionsApi
     */
    public deleteS3Connection(requestParameters: S3ConnectionsApiDeleteS3ConnectionRequest, options?: any) {
        return S3ConnectionsApiFp(this.configuration).deleteS3Connection(requestParameters.s3ConnectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {S3ConnectionsApiGetS3ConnectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof S3ConnectionsApi
     */
    public getS3Connection(requestParameters: S3ConnectionsApiGetS3ConnectionRequest, options?: any) {
        return S3ConnectionsApiFp(this.configuration).getS3Connection(requestParameters.s3ConnectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof S3ConnectionsApi
     */
    public listS3Connections(options?: any) {
        return S3ConnectionsApiFp(this.configuration).listS3Connections(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {S3ConnectionsApiTestS3ConnectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof S3ConnectionsApi
     */
    public testS3Connection(requestParameters: S3ConnectionsApiTestS3ConnectionRequest, options?: any) {
        return S3ConnectionsApiFp(this.configuration).testS3Connection(requestParameters.inlineObject5, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ViewerApi - axios parameter creator
 * @export
 */
export const ViewerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getViewer: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/viewer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ViewerApi - functional programming interface
 * @export
 */
export const ViewerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ViewerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getViewer(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2009>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getViewer(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ViewerApi - factory interface
 * @export
 */
export const ViewerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ViewerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getViewer(options?: any): AxiosPromise<InlineResponse2009> {
            return localVarFp.getViewer(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ViewerApi - object-oriented interface
 * @export
 * @class ViewerApi
 * @extends {BaseAPI}
 */
export class ViewerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewerApi
     */
    public getViewer(options?: any) {
        return ViewerApiFp(this.configuration).getViewer(options).then((request) => request(this.axios, this.basePath));
    }
}


